import { app } from "../../scripts/app.js";
import {
  BRUSHED_METAL_TEXTURE_DATA,
  CONCRETE_TEXTURE_DATA,
  PIXELATED_TEXTURE_DATA,
  TOXIC_SLIME_TEXTURE_DATA,
  WOODEN_TEXTURE_DATA,
} from "./textures.js";

const EXT_NAME = "tetrinode.live";
const NODE_CLASS = "TetriNode";

const GRID_W = 10;
const GRID_H_TOTAL = 40;
const GRID_H_VISIBLE = 20;
const HIDDEN_ROWS = GRID_H_TOTAL - GRID_H_VISIBLE;
const EXTRA_VISIBLE_ROWS = 1 / 3;
const SPAWN_Y = HIDDEN_ROWS - 2;
const PREVIEW_GRID = 4;
const PREVIEW_SCALE = 0.86;
const BLOCK = 16;
const PADDING = 12;
const HEADER_H = 28;
const TOOLBAR_H = 44;
const CONTROL_GAP = 0;
const CONTROL_WIDGET_PADDING = 6;
const CONTROL_MIN = 110;
const DAS_MS = 300;
const ARR_MS = 56;
const IMAGE_CACHE = new Map();
const TETRINODE_VERSION = "2.1.0";
const LOAD_ICON_VIEWBOX = 1536;
const LOAD_ICON_PATH =
  "M316 1180H1220Q1280 1180 1280 1240Q1280 1300 1220 1300H316Q256 1300 256 1240Q256 1180 316 1180ZM708 360H828Q888 360 888 420V780H948Q988 780 988 820Q988 840 974 856L796 1034Q780 1050 768 1050Q756 1050 740 1034L562 856Q548 840 548 820Q548 780 588 780H648V420Q648 360 708 360Z";
let LOAD_ICON_PATH2D = null;
const RESET_ICON_VIEWBOX = 1536;
const RESET_ICON_PATH =
  "M742.67,1305.35C742.58,1305.27 736.06,1304.94 728.19,1304.62C720.32,1304.30 713.42,1303.76 712.87,1303.42C712.31,1303.08 708.63,1302.65 704.68,1302.47C691.20,1301.87 672.89,1299.72 665.88,1297.93C663.90,1297.42 660.97,1296.99 659.38,1296.99C657.80,1296.98 654.02,1296.28 651.00,1295.44C647.98,1294.59 643.25,1293.51 640.50,1293.03C635.32,1292.12 633.55,1291.69 631.00,1290.74C630.17,1290.44 626.12,1289.42 622.00,1288.48C617.88,1287.55 613.77,1286.41 612.87,1285.96C611.98,1285.51 609.50,1284.82 607.37,1284.44C605.24,1284.05 603.05,1283.41 602.50,1283.01C601.62,1282.37 597.43,1281.05 594.50,1280.49C593.95,1280.39 593.16,1280.18 592.75,1280.03C592.34,1279.87 591.66,1279.68 591.25,1279.60C587.34,1278.82 581.00,1276.58 581.00,1275.98C581.00,1275.56 579.31,1274.91 577.25,1274.52C575.19,1274.14 573.05,1273.46 572.50,1273.02C571.95,1272.58 567.90,1270.96 563.50,1269.43C559.10,1267.90 554.61,1266.05 553.53,1265.32C552.44,1264.60 550.85,1264.00 549.99,1264.00C549.13,1264.00 543.87,1261.75 538.29,1259.00C532.72,1256.25 527.45,1254.00 526.58,1254.00C525.71,1254.00 525.00,1253.55 525.00,1253.00C525.00,1252.45 524.53,1252.00 523.95,1252.00C523.36,1252.00 520.78,1251.02 518.20,1249.81C515.61,1248.61 512.97,1247.53 512.31,1247.41C511.66,1247.29 509.86,1246.03 508.32,1244.60C506.78,1243.17 505.14,1242.00 504.66,1242.00C504.19,1242.00 502.61,1241.16 501.15,1240.14C499.69,1239.12 496.76,1237.71 494.63,1237.02C492.51,1236.33 489.92,1234.92 488.88,1233.88C487.85,1232.85 486.24,1232.00 485.30,1232.00C483.57,1232.00 478.57,1228.92 471.55,1223.53C466.93,1219.99 464.76,1218.65 460.05,1216.43C458.15,1215.54 454.78,1213.33 452.55,1211.54C450.32,1209.74 447.49,1207.74 446.25,1207.10C445.01,1206.45 444.00,1205.38 443.99,1204.71C443.99,1204.05 442.98,1202.99 441.74,1202.36C432.61,1197.70 430.22,1196.13 425.27,1191.61C422.20,1188.80 418.62,1186.05 417.31,1185.50C414.80,1184.44 403.47,1174.33 394.07,1164.75C390.97,1161.59 388.08,1159.00 387.66,1159.00C386.84,1159.00 380.58,1152.84 372.90,1144.50C370.38,1141.75 366.78,1138.13 364.90,1136.46C360.40,1132.44 348.88,1119.61 344.88,1114.16C343.12,1111.77 340.17,1108.20 338.32,1106.24C336.46,1104.27 333.16,1100.04 330.97,1096.84C326.94,1090.93 325.83,1089.48 320.50,1083.09C316.88,1078.76 313.93,1074.62 308.34,1066.00C306.02,1062.42 303.61,1058.93 303.00,1058.23C302.38,1057.53 301.19,1055.30 300.34,1053.27C298.77,1049.51 290.27,1035.91 288.91,1034.99C288.50,1034.71 287.85,1033.24 287.47,1031.73C287.09,1030.22 286.41,1028.75 285.95,1028.47C285.50,1028.19 283.94,1025.38 282.48,1022.23C281.02,1019.08 279.35,1015.62 278.77,1014.54C278.19,1013.46 276.66,1010.58 275.36,1008.14C274.06,1005.70 272.53,1003.14 271.94,1002.43C270.81,1001.07 267.73,993.35 265.39,986.02C264.60,983.56 263.11,979.74 262.07,977.52C257.98,968.85 256.15,964.15 253.49,955.50C251.97,950.55 249.92,944.48 248.95,942.00C245.98,934.41 245.71,933.58 245.31,931.00C244.96,928.75 243.68,924.12 241.02,915.50C237.10,902.84 232.65,883.85 231.06,873.00C230.54,869.42 229.63,863.70 229.04,860.28C228.45,856.86 227.80,852.13 227.59,849.78C227.38,847.43 226.68,840.55 226.03,834.50C223.18,808.07 222.79,776.63 225.01,753.11C225.62,746.72 226.51,736.77 227.01,731.00C227.50,725.23 228.85,715.10 230.02,708.50C231.18,701.90 232.56,693.58 233.08,690.00C233.60,686.42 234.49,682.15 235.06,680.50C235.63,678.85 236.74,674.12 237.51,670.00C238.29,665.88 239.88,659.12 241.05,655.00C242.23,650.88 244.27,643.49 245.58,638.59C246.90,633.69 248.64,628.68 249.44,627.46C250.24,626.23 250.84,624.39 250.77,623.37C250.59,620.70 256.88,602.12 260.12,595.76C260.60,594.81 261.00,593.40 261.00,592.64C261.00,591.87 261.63,590.72 262.40,590.09C263.16,589.45 264.08,587.38 264.43,585.50C264.79,583.61 265.62,581.49 266.29,580.78C266.96,580.08 268.36,577.02 269.42,574.00C270.47,570.98 272.38,566.93 273.67,565.02C274.95,563.10 276.00,561.16 276.00,560.69C276.00,560.23 277.80,556.77 280.00,553.00C282.20,549.23 284.00,545.20 284.00,544.04C284.00,542.89 284.68,541.68 285.50,541.36C286.33,541.05 287.00,539.90 287.00,538.82C287.00,537.74 288.24,534.97 289.75,532.66C294.59,525.27 294.98,524.61 298.34,518.00C302.88,509.07 306.57,503.14 312.85,494.69C315.79,490.74 318.59,486.49 319.07,485.25C319.56,484.01 320.34,483.00 320.81,483.00C321.28,483.00 322.30,481.78 323.08,480.29C323.86,478.79 326.41,475.56 328.75,473.11C331.09,470.65 333.00,468.07 333.00,467.36C333.00,466.65 333.82,465.27 334.81,464.29C335.81,463.31 338.36,460.25 340.49,457.50C342.61,454.75 345.06,451.82 345.93,451.00C346.80,450.18 349.18,447.22 351.20,444.44C353.23,441.66 356.17,438.28 357.73,436.94C359.29,435.60 361.36,433.25 362.33,431.72C363.29,430.19 366.28,426.82 368.97,424.22C371.66,421.62 378.12,415.34 383.32,410.25C388.52,405.16 393.01,401.00 393.28,401.00C393.56,401.00 396.05,398.86 398.82,396.25C403.49,391.85 407.94,387.92 417.13,380.09C419.13,378.39 421.17,377.00 421.67,377.00C422.17,377.00 424.59,374.95 427.04,372.44C429.49,369.92 434.05,366.31 437.18,364.41C440.30,362.50 443.00,360.59 443.18,360.16C443.61,359.10 459.66,348.00 460.76,348.00C461.23,348.00 462.50,347.21 463.56,346.24C464.63,345.28 466.62,343.93 468.00,343.25C471.85,341.35 474.43,339.61 475.23,338.38C475.63,337.77 477.31,336.70 478.98,336.01C480.64,335.32 482.00,334.36 482.00,333.88C482.00,333.40 482.48,333.00 483.07,333.00C483.66,333.00 487.37,331.04 491.32,328.64C498.12,324.51 505.18,320.56 513.00,316.49C514.92,315.48 517.17,314.30 518.00,313.85C518.83,313.40 521.52,312.08 524.00,310.91C526.48,309.74 531.55,307.29 535.27,305.47C538.99,303.66 543.94,301.86 546.27,301.47C548.60,301.09 551.62,300.22 553.00,299.55C561.62,295.33 566.92,293.27 580.50,288.88C585.45,287.28 591.52,285.27 594.00,284.40C596.48,283.54 599.62,282.62 601.00,282.34C602.38,282.07 604.40,281.47 605.50,281.02C606.60,280.56 608.40,279.87 609.50,279.49C612.54,278.43 632.96,272.97 637.50,272.00C639.70,271.53 643.30,270.68 645.50,270.09C647.70,269.51 657.33,267.89 666.90,266.49C676.47,265.08 684.62,263.73 685.02,263.49C685.41,263.24 688.16,262.78 691.12,262.46C694.08,262.14 698.75,261.48 701.50,260.99C719.93,257.70 783.02,258.04 804.00,261.55C808.67,262.33 816.10,263.18 820.50,263.44C824.90,263.70 829.62,264.16 831.00,264.45C832.38,264.74 837.33,265.68 842.00,266.53C855.55,268.99 869.02,271.75 875.50,273.37C880.95,274.74 885.54,276.07 900.50,280.61C903.25,281.45 908.88,283.01 913.00,284.09C917.12,285.16 921.85,286.65 923.50,287.41C925.15,288.16 927.62,289.08 929.00,289.45C930.38,289.82 932.40,290.55 933.50,291.07C934.60,291.59 939.26,293.32 943.86,294.92C948.46,296.51 952.71,298.31 953.31,298.91C953.91,299.51 954.80,300.00 955.28,300.00C956.33,300.00 968.91,305.81 978.00,310.49C981.58,312.34 989.00,316.14 994.50,318.95C1004.51,324.06 1006.99,325.46 1017.61,332.00C1020.74,333.93 1025.02,336.40 1027.12,337.50C1033.31,340.73 1051.00,355.88 1051.00,357.95C1051.00,358.41 1052.35,360.23 1054.00,362.00C1055.65,363.77 1057.00,365.79 1057.00,366.50C1057.00,367.21 1057.67,368.05 1058.50,368.36C1059.38,368.70 1060.00,370.20 1060.00,372.00C1060.00,373.68 1060.90,377.74 1062.00,381.01C1063.10,384.28 1064.14,387.87 1064.32,388.99C1064.49,390.10 1066.13,392.57 1067.98,394.48L1071.33,397.93L1077.41,394.53C1083.21,391.28 1089.27,386.25 1100.00,375.75C1102.67,373.14 1105.34,371.00 1105.93,371.00C1106.52,371.00 1107.00,370.63 1107.00,370.17C1107.00,369.71 1109.14,367.84 1111.75,366.01C1114.36,364.18 1117.62,361.66 1119.00,360.41C1124.77,355.15 1136.39,353.32 1147.50,355.92C1152.92,357.19 1153.96,357.88 1158.25,363.07C1160.86,366.23 1163.00,369.30 1163.00,369.90C1163.00,370.51 1163.45,371.00 1164.00,371.00C1164.55,371.00 1164.93,371.34 1164.84,371.75C1164.42,373.65 1166.36,378.00 1167.63,378.00C1168.98,378.00 1171.52,382.82 1170.63,383.70C1170.40,383.93 1171.29,385.29 1172.60,386.71C1173.92,388.13 1175.00,389.94 1175.00,390.73C1175.00,391.52 1176.80,395.80 1179.00,400.24C1181.20,404.68 1183.00,409.53 1183.00,411.02C1183.00,412.51 1184.12,415.38 1185.50,417.40C1186.88,419.43 1188.00,421.46 1188.00,421.91C1188.00,422.36 1189.36,426.02 1191.02,430.05C1192.68,434.08 1194.74,440.11 1195.60,443.44C1196.46,446.77 1197.57,449.93 1198.08,450.45C1198.58,450.97 1199.00,452.17 1199.00,453.12C1199.00,454.06 1199.34,454.98 1199.75,455.17C1200.16,455.35 1201.56,458.43 1202.85,462.00C1207.97,476.19 1212.81,490.67 1213.47,493.75C1213.85,495.54 1214.52,497.00 1214.97,497.00C1215.42,497.00 1216.51,498.81 1217.39,501.02C1218.92,504.84 1219.71,507.59 1222.02,517.25C1222.58,519.59 1223.44,522.40 1223.93,523.50C1225.22,526.41 1228.02,535.17 1228.39,537.50C1228.57,538.60 1229.43,541.19 1230.30,543.25C1231.18,545.31 1232.86,551.70 1234.04,557.46C1235.75,565.81 1235.96,568.59 1235.09,571.22C1234.38,573.39 1234.32,575.64 1234.93,577.76C1235.44,579.54 1235.53,581.00 1235.12,581.00C1234.71,581.00 1233.80,583.25 1233.10,586.00C1232.39,588.75 1231.41,591.00 1230.91,591.00C1230.41,591.00 1230.00,591.47 1230.00,592.04C1230.00,593.91 1225.60,599.08 1222.24,601.16C1220.43,602.28 1216.83,605.43 1214.23,608.15C1209.44,613.18 1205.09,616.12 1201.55,616.72C1200.48,616.90 1198.91,617.65 1198.05,618.38C1197.13,619.18 1194.68,619.61 1192.00,619.45C1189.53,619.30 1186.90,619.67 1186.17,620.27C1185.19,621.09 1184.62,621.01 1183.98,619.96C1183.26,618.80 1182.99,618.86 1182.44,620.30C1181.95,621.58 1181.43,621.77 1180.50,621.00C1179.20,619.92 1154.45,620.51 1150.50,621.72C1149.40,622.05 1147.15,622.40 1145.50,622.49C1139.37,622.81 1117.30,625.12 1111.50,626.03C1108.20,626.56 1101.49,627.23 1096.58,627.54C1091.68,627.84 1087.28,628.33 1086.81,628.62C1086.34,628.91 1083.83,629.32 1081.23,629.55C1076.84,629.92 1066.14,631.20 1065.00,631.48C1063.77,631.78 1052.99,633.08 1048.00,633.52C1044.97,633.78 1040.25,634.55 1037.50,635.23C1034.21,636.04 1023.78,636.47 1007.00,636.48L981.50,636.50L973.67,633.12C964.82,629.31 957.86,623.05 955.18,616.50C953.13,611.49 952.94,595.09 954.88,590.00C957.23,583.83 963.26,571.60 965.47,568.50C966.65,566.85 969.08,562.66 970.86,559.19C972.65,555.72 975.54,550.94 977.30,548.57C979.06,546.21 981.40,542.98 982.50,541.40C983.60,539.82 985.40,537.60 986.50,536.47C987.60,535.33 989.03,533.24 989.67,531.83C990.32,530.41 992.28,527.62 994.03,525.62C995.78,523.63 996.86,522.00 996.43,522.00C996.00,522.00 996.61,520.97 997.79,519.72C998.97,518.47 1000.96,515.59 1002.22,513.32C1008.36,502.22 1011.60,497.14 1014.99,493.28C1017.03,490.97 1020.14,486.13 1021.91,482.53C1023.68,478.94 1025.54,476.00 1026.04,476.00C1026.55,476.00 1027.24,474.91 1027.57,473.57C1027.91,472.24 1029.04,470.37 1030.09,469.42C1031.14,468.47 1032.00,467.09 1032.00,466.36C1032.00,465.63 1033.35,462.24 1035.00,458.84C1036.65,455.43 1038.00,451.85 1038.00,450.88C1038.00,449.91 1038.50,448.81 1039.10,448.44C1039.72,448.05 1039.95,446.52 1039.63,444.92C1039.32,443.36 1039.48,441.82 1039.99,441.50C1041.24,440.73 1039.62,436.62 1037.07,434.07C1035.40,432.40 1034.17,432.15 1029.78,432.58C1026.88,432.87 1023.98,433.27 1023.35,433.48C1022.30,433.83 1015.21,432.63 1002.50,429.97C999.75,429.40 992.50,426.47 986.39,423.46C980.27,420.46 974.76,418.00 974.14,418.00C973.51,418.00 973.00,417.55 973.00,417.00C973.00,416.45 972.12,416.00 971.05,416.00C969.98,416.00 968.74,415.41 968.30,414.68C967.86,413.95 962.10,410.75 955.50,407.56C948.90,404.38 942.04,400.67 940.25,399.33C938.46,397.99 935.53,396.42 933.75,395.84C931.96,395.26 927.24,393.26 923.26,391.39C919.28,389.53 915.50,388.00 914.86,388.00C914.22,388.00 909.15,386.27 903.60,384.15C890.83,379.28 883.91,376.86 882.00,376.58C881.17,376.46 879.23,375.83 877.68,375.18C876.14,374.53 874.38,374.00 873.77,374.00C873.17,374.00 870.39,373.34 867.59,372.53C861.96,370.90 843.64,366.27 840.50,365.68C839.40,365.47 837.83,365.05 837.00,364.74C836.17,364.44 832.35,363.66 828.50,363.01C824.65,362.36 819.02,361.40 816.00,360.88C812.98,360.36 809.38,359.74 808.00,359.51C793.34,356.99 726.68,356.64 704.50,358.96C700.10,359.42 696.19,359.61 695.82,359.38C695.44,359.15 694.88,359.38 694.57,359.88C694.26,360.38 690.74,361.10 686.75,361.48C682.76,361.85 677.92,362.54 676.00,363.01C674.08,363.48 670.13,364.08 667.23,364.34C662.15,364.81 660.03,365.35 642.59,370.61C638.24,371.93 634.18,373.00 633.58,373.00C632.97,373.00 628.88,374.16 624.49,375.58C615.38,378.53 615.75,378.42 610.75,379.45C608.69,379.88 607.00,380.59 607.00,381.03C607.00,381.48 605.62,382.14 603.93,382.51C602.25,382.89 599.66,383.82 598.18,384.59C596.71,385.36 594.70,385.99 593.73,385.99C591.15,386.00 580.61,390.45 575.02,393.89C572.37,395.52 568.36,397.41 566.11,398.08C563.87,398.76 561.28,400.14 560.36,401.15C559.44,402.17 558.20,403.01 557.60,403.02C556.11,403.04 545.27,408.62 535.50,414.39C515.63,426.12 514.11,427.10 503.56,435.00C501.73,436.38 499.22,438.18 497.99,439.00C496.76,439.82 495.25,440.98 494.63,441.57C494.01,442.15 492.15,443.49 490.50,444.54C486.20,447.27 478.31,453.81 473.37,458.75C471.03,461.09 468.73,463.00 468.25,463.00C467.44,463.00 453.58,475.36 450.07,479.22C449.20,480.16 444.00,485.65 438.50,491.41C428.92,501.45 424.73,506.13 419.77,512.35C418.52,513.93 416.71,516.06 415.75,517.10C414.79,518.15 414.00,519.23 414.00,519.51C414.00,519.80 412.09,522.46 409.75,525.43C404.12,532.59 398.77,539.88 397.52,542.11C396.96,543.10 393.01,549.04 388.75,555.31C384.49,561.57 380.99,567.10 380.97,567.60C380.96,568.09 379.61,570.27 377.97,572.43C376.34,574.59 375.00,576.99 375.00,577.77C375.00,578.55 374.19,580.39 373.21,581.85C372.22,583.31 370.32,586.98 368.99,590.00C367.65,593.02 365.60,597.08 364.43,599.00C363.27,600.92 361.52,604.98 360.54,608.00C359.57,611.02 357.87,615.08 356.77,617.00C355.67,618.92 353.64,623.88 352.26,628.00C350.89,632.12 349.43,635.95 349.03,636.50C348.29,637.51 346.53,643.10 340.97,662.00C339.27,667.77 337.23,673.92 336.44,675.65C335.65,677.38 335.00,679.94 335.00,681.34C335.00,682.73 334.56,685.04 334.01,686.46C333.01,689.10 332.42,691.74 331.42,698.00C331.11,699.92 330.25,704.65 329.52,708.50C327.82,717.37 327.21,721.76 326.46,730.50C326.12,734.35 325.38,740.20 324.81,743.50C324.24,746.81 323.81,762.74 323.85,779.00C323.93,808.17 325.46,832.34 328.44,851.50C330.05,861.88 335.40,886.29 336.96,890.39C337.54,891.92 337.78,893.55 337.49,894.01C337.20,894.48 337.42,895.14 337.98,895.49C338.54,895.84 339.00,897.10 338.99,898.31C338.97,901.89 346.27,923.93 351.79,937.00C361.66,960.33 366.27,970.61 367.49,972.00C368.22,972.83 372.25,980.21 376.45,988.41C380.65,996.61 385.08,1004.52 386.29,1006.00C387.51,1007.47 389.62,1010.59 391.00,1012.93C392.38,1015.26 394.92,1019.11 396.65,1021.46C398.38,1023.82 400.36,1026.82 401.04,1028.12C401.73,1029.43 403.79,1032.30 405.61,1034.50C407.44,1036.70 410.05,1039.85 411.41,1041.50C412.77,1043.15 415.00,1045.76 416.36,1047.31C417.72,1048.85 421.21,1053.24 424.11,1057.06C427.02,1060.88 429.73,1064.00 430.14,1064.00C430.90,1064.00 450.19,1083.15 458.12,1091.77C460.53,1094.39 463.62,1097.11 465.00,1097.80C466.38,1098.50 469.33,1100.74 471.57,1102.79C478.01,1108.66 484.61,1114.11 486.81,1115.36C487.92,1115.98 490.91,1117.96 493.46,1119.75C496.01,1121.54 498.44,1123.00 498.85,1123.00C499.27,1123.00 501.33,1124.58 503.43,1126.50C505.53,1128.42 507.42,1130.00 507.62,1130.00C507.82,1130.00 510.05,1131.58 512.57,1133.50C515.09,1135.42 517.79,1137.00 518.58,1137.00C519.36,1137.00 520.00,1137.40 520.00,1137.89C520.00,1138.38 522.14,1139.77 524.75,1140.99C527.36,1142.20 530.40,1144.02 531.50,1145.02C532.60,1146.02 538.23,1149.22 544.00,1152.12C549.77,1155.02 554.74,1157.74 555.04,1158.17C555.34,1158.59 557.41,1159.59 559.65,1160.38C561.88,1161.16 568.61,1164.13 574.61,1166.96C580.60,1169.80 586.40,1172.47 587.50,1172.91C588.60,1173.35 591.65,1174.67 594.28,1175.85C596.90,1177.03 599.91,1178.00 600.97,1178.00C602.02,1178.00 603.13,1178.40 603.43,1178.88C603.73,1179.37 606.12,1180.08 608.74,1180.47C611.36,1180.85 616.20,1182.27 619.50,1183.61C625.11,1185.90 647.14,1191.96 655.00,1193.38C656.92,1193.72 659.62,1194.27 661.00,1194.60C662.38,1194.93 667.10,1195.78 671.50,1196.51C675.90,1197.23 681.46,1198.32 683.86,1198.94C686.26,1199.56 690.98,1200.22 694.36,1200.41C697.74,1200.61 705.67,1201.31 712.00,1201.97C732.17,1204.08 783.17,1203.24 800.39,1200.52C805.40,1199.72 813.05,1198.83 817.39,1198.52C821.73,1198.22 828.71,1197.13 832.89,1196.09C837.08,1195.06 842.70,1193.94 845.40,1193.61C848.09,1193.27 850.79,1192.60 851.40,1192.11C852.79,1191.00 861.10,1188.96 867.00,1188.28C869.48,1188.00 871.73,1187.46 872.00,1187.07C872.27,1186.69 875.20,1185.55 878.50,1184.55C881.80,1183.55 884.95,1182.39 885.50,1181.99C886.05,1181.59 888.98,1180.67 892.00,1179.94C895.02,1179.22 898.78,1178.00 900.35,1177.24C901.91,1176.47 903.98,1175.70 904.94,1175.51C905.91,1175.33 911.47,1172.88 917.32,1170.09C923.16,1167.29 928.38,1165.00 928.90,1165.00C929.43,1165.00 933.83,1162.94 938.68,1160.43C943.53,1157.91 949.30,1154.94 951.50,1153.83C964.54,1147.24 972.11,1143.06 974.08,1141.36C974.95,1140.61 976.18,1140.00 976.82,1140.00C977.46,1140.00 980.00,1138.54 982.46,1136.75C989.34,1131.76 996.88,1127.00 997.91,1127.00C998.42,1127.00 998.98,1126.61 999.17,1126.14C999.35,1125.67 1004.00,1121.91 1009.50,1117.80C1015.00,1113.69 1020.12,1109.57 1020.87,1108.66C1021.63,1107.75 1022.69,1107.00 1023.23,1107.00C1024.31,1107.00 1032.30,1100.97 1032.83,1099.76C1033.02,1099.34 1033.48,1099.00 1033.85,1099.00C1034.79,1099.00 1045.05,1089.87 1052.69,1082.25C1056.13,1078.81 1059.33,1076.00 1059.80,1076.00C1060.27,1076.00 1067.88,1068.01 1076.73,1058.25C1085.57,1048.49 1093.87,1039.58 1095.16,1038.45C1096.45,1037.33 1099.08,1034.25 1101.00,1031.61C1102.92,1028.97 1106.53,1024.48 1109.00,1021.62C1111.47,1018.77 1115.30,1012.94 1117.49,1008.67C1119.69,1004.40 1122.95,999.24 1124.73,997.21C1126.51,995.17 1128.27,992.60 1128.62,991.50C1128.98,990.40 1129.57,989.27 1129.95,989.00C1132.17,987.36 1153.28,945.16 1157.95,933.00C1159.75,928.33 1161.85,923.15 1162.61,921.50C1163.37,919.85 1164.28,916.92 1164.64,915.00C1164.99,913.08 1165.63,911.05 1166.05,910.50C1167.28,908.90 1171.00,898.66 1171.00,896.86C1171.00,895.96 1172.11,891.91 1173.48,887.85C1174.84,883.80 1176.64,877.11 1177.48,872.99C1178.32,868.87 1179.20,864.60 1179.44,863.50C1179.67,862.40 1180.38,857.90 1181.00,853.50C1181.62,849.10 1182.35,844.38 1182.62,843.00C1185.15,829.94 1186.68,813.84 1186.90,797.89C1187.04,788.37 1187.31,780.31 1187.50,779.99C1187.97,779.25 1185.21,733.16 1184.65,732.21C1184.26,731.56 1183.71,727.30 1182.43,715.00C1182.17,712.52 1181.75,709.38 1181.50,708.00C1181.25,706.62 1180.76,703.25 1180.43,700.50C1180.09,697.75 1179.23,691.23 1178.52,686.00C1176.98,674.73 1177.06,660.83 1178.69,658.88C1179.33,658.11 1180.78,653.90 1181.93,649.52C1183.26,644.45 1185.10,640.21 1187.01,637.83C1188.66,635.78 1190.41,633.06 1190.90,631.77C1191.44,630.36 1192.69,629.37 1194.10,629.27C1195.38,629.17 1197.22,628.06 1198.19,626.80C1200.41,623.91 1200.44,623.00 1198.33,623.00C1196.40,623.00 1197.36,621.71 1199.53,621.39C1200.34,621.27 1201.00,621.81 1201.00,622.59C1201.00,623.37 1202.00,624.02 1203.25,624.05C1219.25,624.39 1238.00,626.60 1238.00,628.14C1238.00,628.61 1239.06,629.00 1240.37,629.00C1241.67,629.00 1243.80,629.84 1245.12,630.87C1246.43,631.90 1248.94,633.05 1250.70,633.44C1254.59,634.29 1264.49,644.60 1267.65,651.08C1270.39,656.73 1273.78,667.28 1274.61,672.75C1274.97,675.09 1275.65,677.00 1276.13,677.00C1276.61,677.00 1277.00,678.92 1277.00,681.28C1277.00,683.63 1277.63,686.46 1278.41,687.56C1279.18,688.67 1280.12,691.81 1280.51,694.54C1280.89,697.27 1281.81,702.42 1282.56,706.00C1283.31,709.58 1284.14,714.08 1284.41,716.00C1284.68,717.92 1285.37,722.65 1285.93,726.50C1287.63,738.07 1288.28,752.01 1288.55,782.00C1288.77,807.00 1288.51,812.83 1286.43,829.50C1285.12,839.95 1283.59,850.07 1283.03,851.99C1282.46,853.91 1282.00,857.84 1282.00,860.71C1282.00,863.58 1281.38,867.41 1280.62,869.22C1279.86,871.02 1278.22,877.00 1276.97,882.50C1273.92,895.89 1272.39,901.67 1270.56,906.73C1269.71,909.06 1268.81,912.43 1268.55,914.23C1268.29,916.03 1267.35,919.52 1266.45,922.00C1265.55,924.48 1264.65,927.71 1264.46,929.19C1264.27,930.68 1263.41,933.24 1262.55,934.90C1261.69,936.56 1260.83,939.17 1260.64,940.71C1260.45,942.24 1259.81,944.62 1259.23,946.00C1258.25,948.29 1256.90,951.78 1256.52,953.00C1256.13,954.21 1253.46,960.03 1250.36,966.41C1248.51,970.21 1247.00,973.90 1247.00,974.61C1247.00,975.33 1245.88,977.57 1244.50,979.60C1243.12,981.62 1242.00,984.05 1242.00,984.99C1242.00,985.93 1240.81,988.91 1239.36,991.60C1233.13,1003.15 1224.50,1020.59 1224.49,1021.66C1224.48,1022.30 1223.73,1023.65 1222.83,1024.66C1219.87,1027.98 1212.00,1040.24 1212.00,1041.53C1212.00,1042.22 1211.33,1043.05 1210.50,1043.36C1209.67,1043.68 1209.00,1044.85 1209.00,1045.97C1209.00,1047.09 1208.60,1048.00 1208.11,1048.00C1207.63,1048.00 1206.44,1049.69 1205.47,1051.75C1204.50,1053.81 1203.41,1055.72 1203.06,1056.00C1202.20,1056.67 1193.00,1069.97 1193.00,1070.55C1193.00,1070.80 1192.31,1071.79 1191.46,1072.75C1187.06,1077.76 1185.00,1081.00 1185.00,1082.89C1185.00,1084.05 1184.38,1085.00 1183.63,1085.00C1182.88,1085.00 1181.14,1086.69 1179.76,1088.75C1178.38,1090.81 1174.72,1095.18 1171.62,1098.45C1168.53,1101.73 1166.00,1104.74 1166.00,1105.14C1166.00,1105.79 1163.85,1108.32 1155.20,1117.86C1153.94,1119.25 1152.22,1121.85 1151.37,1123.64C1150.52,1125.42 1148.63,1127.66 1147.16,1128.61C1143.78,1130.81 1130.00,1144.83 1130.00,1146.07C1130.00,1146.58 1129.55,1147.00 1129.00,1147.00C1128.45,1147.00 1126.28,1148.72 1124.17,1150.83C1122.07,1152.93 1119.59,1154.94 1118.67,1155.30C1117.75,1155.65 1117.00,1156.57 1117.00,1157.35C1117.00,1158.12 1115.65,1159.32 1114.00,1160.00C1112.35,1160.68 1111.00,1161.63 1111.00,1162.11C1111.00,1163.07 1105.07,1169.00 1104.10,1169.00C1103.57,1169.01 1098.30,1173.41 1093.92,1177.52C1093.04,1178.33 1091.92,1179.00 1091.41,1179.00C1090.90,1179.00 1089.08,1180.46 1087.36,1182.25C1083.56,1186.19 1077.58,1191.04 1074.37,1192.78C1073.07,1193.49 1072.00,1194.50 1072.00,1195.03C1072.00,1195.56 1071.33,1196.00 1070.50,1196.00C1069.67,1196.00 1069.00,1196.67 1069.00,1197.50C1069.00,1198.33 1068.47,1199.00 1067.82,1199.00C1066.27,1199.00 1056.00,1206.09 1056.00,1207.17C1056.00,1207.62 1055.33,1208.00 1054.50,1208.00C1053.67,1208.00 1052.10,1208.90 1051.00,1210.00C1049.90,1211.10 1048.80,1212.00 1048.55,1212.00C1048.30,1212.00 1047.00,1213.03 1045.64,1214.28C1044.29,1215.53 1042.34,1216.62 1041.31,1216.70C1039.49,1216.84 1031.43,1221.75 1025.63,1226.27C1024.05,1227.50 1020.90,1229.49 1018.63,1230.70C1016.36,1231.91 1014.05,1233.29 1013.50,1233.76C1012.95,1234.22 1011.15,1235.32 1009.50,1236.20C1007.85,1237.07 1004.02,1239.16 1001.00,1240.84C989.24,1247.36 971.89,1256.30 965.50,1259.11C962.75,1260.33 960.27,1261.39 960.00,1261.48C959.73,1261.57 958.38,1262.12 957.00,1262.71C951.05,1265.26 945.53,1267.51 945.03,1267.58C944.74,1267.63 943.15,1268.24 941.50,1268.95C939.85,1269.65 936.48,1270.82 934.00,1271.55C931.52,1272.27 924.57,1274.70 918.55,1276.93C912.53,1279.17 906.62,1281.00 905.43,1281.00C904.23,1281.00 902.68,1281.69 901.98,1282.52C901.28,1283.36 900.50,1283.83 900.23,1283.57C899.97,1283.30 898.04,1283.96 895.95,1285.03C893.85,1286.10 890.20,1287.15 887.82,1287.36C885.44,1287.58 880.58,1288.46 877.00,1289.32C859.29,1293.59 848.91,1295.91 843.00,1296.92C831.75,1298.84 815.71,1301.14 810.00,1301.65C806.98,1301.92 803.15,1302.54 801.50,1303.04C797.50,1304.25 777.08,1305.39 758.17,1305.45C749.74,1305.48 742.76,1305.43 742.67,1305.35ZM1198.50,619.00C1198.84,618.45 1199.32,618.00 1199.56,618.00C1199.80,618.00 1200.00,618.45 1200.00,619.00C1200.00,619.55 1199.52,620.00 1198.94,620.00C1198.36,620.00 1198.16,619.55 1198.50,619.00Z";
let RESET_ICON_PATH2D = null;
const PAUSE_ICON_VIEWBOX = 1536;
const PAUSE_ICON_PATH =
  "M520 360H640Q700 360 700 420V1116Q700 1176 640 1176H520Q460 1176 460 1116V420Q460 360 520 360ZM896 360H1016Q1076 360 1076 420V1116Q1076 1176 1016 1176H896Q836 1176 836 1116V420Q836 360 896 360Z";
let PAUSE_ICON_PATH2D = null;
const PLAY_ICON_VIEWBOX = 1536;
const PLAY_ICON_PATH =
  "M540 360H620Q640 360 656 372L1100 720Q1136 750 1136 768Q1136 786 1100 816L656 1164Q640 1176 620 1176H540Q480 1176 480 1116V420Q480 360 540 360Z";
let PLAY_ICON_PATH2D = null;
const SETTINGS_ICON_VIEWBOX = 1536;
const SETTINGS_ICON_PATH =
  "M735.50,1385.84C717.16,1384.98 711.75,1384.34 707.37,1382.51C705.38,1381.68 702.94,1381.00 701.94,1381.00C700.93,1381.00 698.63,1380.13 696.81,1379.07C694.99,1378.01 691.70,1376.82 689.50,1376.43C685.59,1375.73 676.00,1370.28 676.00,1368.77C676.00,1368.34 675.34,1368.00 674.53,1368.00C673.71,1368.00 672.30,1366.54 671.39,1364.75C670.47,1362.96 669.41,1361.28 669.03,1361.00C667.31,1359.75 658.79,1338.76 654.84,1326.00C653.22,1320.78 650.81,1311.78 649.48,1306.00C648.16,1300.22 646.16,1291.94 645.04,1287.59C643.92,1283.24 643.00,1278.84 643.00,1277.80C643.00,1276.77 642.38,1274.93 641.61,1273.71C640.85,1272.50 639.93,1269.70 639.56,1267.50C637.85,1257.14 630.91,1242.85 625.24,1238.00C623.73,1236.71 620.31,1233.71 617.64,1231.33C614.97,1228.95 612.18,1227.00 611.43,1227.00C610.69,1227.00 603.15,1223.62 594.66,1219.50C586.18,1215.38 578.92,1212.00 578.52,1212.00C578.13,1212.00 576.50,1211.07 574.90,1209.93C573.31,1208.79 572.00,1208.15 572.00,1208.49C572.00,1208.84 569.41,1207.79 566.25,1206.16C557.40,1201.61 552.08,1199.33 545.11,1197.08C541.60,1195.95 538.21,1194.59 537.58,1194.07C536.07,1192.81 522.47,1190.00 517.92,1190.00C512.19,1190.00 502.81,1192.01 498.86,1194.09C496.86,1195.14 494.68,1196.00 494.02,1196.00C493.35,1196.00 491.61,1196.84 490.15,1197.87C488.69,1198.89 484.37,1201.44 480.55,1203.53C475.02,1206.55 457.87,1218.33 452.45,1222.83C451.88,1223.31 450.96,1223.88 450.41,1224.10C449.86,1224.32 445.48,1226.97 440.68,1230.00C435.87,1233.03 431.10,1235.97 430.08,1236.54C429.05,1237.11 427.60,1238.09 426.85,1238.71C426.11,1239.33 423.02,1240.81 420.00,1242.00C416.97,1243.19 413.82,1244.75 413.00,1245.46C410.76,1247.41 401.47,1249.78 393.00,1250.56C388.88,1250.94 384.44,1251.35 383.15,1251.47C380.36,1251.73 370.77,1248.01 368.17,1245.65C367.16,1244.74 366.03,1244.00 365.64,1244.00C365.26,1244.00 362.66,1242.20 359.88,1240.00C357.10,1237.80 354.22,1236.00 353.48,1236.00C352.75,1236.00 351.54,1235.44 350.81,1234.75C350.08,1234.06 346.33,1230.81 342.49,1227.52C332.28,1218.78 319.92,1206.30 315.24,1200.00C312.99,1196.97 309.05,1192.25 306.48,1189.50C303.91,1186.75 301.07,1183.38 300.16,1182.00C299.26,1180.62 297.05,1177.55 295.26,1175.17C293.47,1172.79 292.00,1170.30 292.00,1169.64C292.00,1168.98 290.42,1165.99 288.50,1163.00C286.57,1160.01 285.00,1156.31 285.00,1154.78C285.00,1153.25 284.55,1152.00 284.00,1152.00C283.45,1152.00 283.00,1149.76 283.00,1147.02C283.00,1141.11 285.12,1128.00 286.08,1128.00C286.44,1128.00 287.04,1126.31 287.41,1124.25C287.77,1122.19 288.92,1118.92 289.97,1117.00C291.02,1115.08 292.59,1111.92 293.45,1110.00C294.32,1108.08 296.13,1104.47 297.47,1102.00C298.82,1099.53 300.78,1095.67 301.84,1093.44C302.90,1091.20 304.39,1088.73 305.16,1087.94C306.73,1086.31 314.63,1073.43 317.54,1067.75C318.59,1065.69 319.80,1064.00 320.23,1064.00C320.65,1064.00 321.00,1063.49 321.00,1062.86C321.00,1062.24 323.07,1058.59 325.59,1054.76C328.11,1050.93 330.99,1045.48 331.99,1042.65C332.98,1039.82 334.64,1035.54 335.68,1033.15C340.48,1022.07 333.11,995.38 313.89,954.31C312.30,950.91 311.00,947.84 311.00,947.50C311.00,945.29 300.82,926.41 296.80,921.15C292.08,914.98 284.76,909.03 279.22,906.86C273.81,904.74 257.61,900.14 253.50,899.56C252.40,899.40 250.38,899.01 249.00,898.67C247.62,898.34 244.93,897.88 243.00,897.65C241.07,897.41 238.38,896.78 237.00,896.24C235.62,895.71 231.87,894.94 228.65,894.55C225.42,894.15 220.70,893.22 218.15,892.48C215.59,891.74 212.15,890.94 210.49,890.69C205.60,889.97 189.58,885.84 188.50,885.02C187.95,884.61 185.03,883.48 182.00,882.52C178.97,881.55 174.47,879.51 172.00,877.97C169.53,876.42 165.81,874.37 163.75,873.40C161.69,872.42 160.00,871.26 160.00,870.81C160.00,870.37 159.32,870.00 158.50,870.00C157.68,870.00 157.00,869.52 157.00,868.94C157.00,868.36 156.61,868.13 156.12,868.42C155.64,868.72 154.96,867.15 154.61,864.94C154.25,862.73 153.30,860.67 152.49,860.36C151.68,860.05 150.34,857.53 149.52,854.77C148.70,852.00 147.65,849.24 147.19,848.62C145.71,846.65 143.10,838.68 142.08,833.00C141.54,829.98 140.39,823.90 139.53,819.50C137.72,810.16 137.36,777.64 138.98,769.10C139.54,766.14 140.03,761.88 140.06,759.61C140.11,756.16 141.74,748.93 144.60,739.50C144.93,738.40 145.45,736.18 145.74,734.56C146.04,732.94 147.02,730.82 147.92,729.86C148.81,728.89 150.43,725.49 151.50,722.30C153.85,715.30 159.40,708.97 165.86,705.94C168.41,704.75 171.62,703.01 173.00,702.09C175.80,700.22 185.17,696.46 189.00,695.67C191.82,695.09 201.29,692.60 211.00,689.90C217.76,688.01 230.52,685.39 240.00,683.94C247.92,682.72 257.32,680.62 258.61,679.77C259.23,679.38 262.38,678.76 265.61,678.41C268.85,678.05 272.40,677.21 273.50,676.54C274.60,675.87 276.85,674.99 278.50,674.59C282.12,673.72 292.88,666.88 295.57,663.75C302.54,655.65 310.49,640.29 316.14,624.03C317.19,621.02 319.83,614.86 322.02,610.34C324.21,605.82 326.00,601.84 326.00,601.50C326.00,600.95 327.75,596.81 331.50,588.50C332.24,586.85 333.40,583.25 334.06,580.50C334.73,577.75 335.66,575.07 336.14,574.55C336.61,574.03 337.00,572.38 337.00,570.88C337.00,569.39 337.49,568.00 338.09,567.80C339.79,567.24 341.86,553.08 340.80,549.25C340.31,547.45 340.18,545.52 340.52,544.97C341.22,543.83 338.49,533.76 336.46,530.00C335.71,528.62 334.19,525.48 333.08,523.00C330.19,516.58 322.62,503.30 320.36,500.70C317.09,496.94 304.13,473.97 297.96,461.00C295.73,456.32 293.26,451.31 292.46,449.85C291.65,448.39 291.00,446.46 291.00,445.56C291.00,444.67 289.87,441.70 288.49,438.97C285.06,432.21 284.33,424.15 286.42,416.00C288.01,409.79 293.44,397.04 294.94,396.00C295.33,395.73 296.90,393.19 298.42,390.37C300.99,385.61 308.54,376.61 321.49,362.88C324.40,359.79 331.06,353.63 336.29,349.18C341.51,344.74 347.07,339.90 348.64,338.43C350.22,336.96 352.90,334.80 354.62,333.63C369.98,323.14 376.09,319.98 386.99,316.86C393.94,314.87 400.00,314.43 400.00,315.90C400.00,316.39 401.91,317.02 404.25,317.30C411.66,318.17 426.40,323.03 428.00,325.14C428.27,325.50 432.07,327.67 436.43,329.97C440.80,332.26 445.47,335.01 446.82,336.07C448.17,337.13 449.81,338.00 450.48,338.00C451.15,338.00 452.50,338.90 453.50,340.00C454.50,341.10 455.92,342.00 456.65,342.00C457.39,342.00 458.00,342.38 458.00,342.84C458.00,343.30 459.01,344.16 460.25,344.75C461.49,345.34 463.62,346.74 465.00,347.86C470.99,352.75 486.90,363.24 491.25,365.16C493.86,366.32 496.00,367.62 496.00,368.06C496.00,368.49 497.69,369.39 499.75,370.05C501.81,370.72 504.07,371.71 504.77,372.27C506.42,373.58 509.69,373.99 519.50,374.14C528.99,374.28 539.28,371.90 546.79,367.84C549.71,366.26 552.86,364.82 553.80,364.63C554.73,364.45 557.17,363.55 559.22,362.65C561.26,361.74 563.48,361.00 564.14,361.00C565.40,361.00 576.15,357.02 581.75,354.47C585.56,352.75 590.48,350.63 594.00,349.19C608.22,343.41 623.93,334.53 623.97,332.25C623.99,331.56 624.39,331.00 624.86,331.00C626.47,331.00 631.27,325.52 632.74,322.00C633.55,320.07 635.22,316.25 636.47,313.50C637.72,310.75 639.07,306.93 639.49,305.00C639.90,303.07 640.52,301.05 640.86,300.50C642.00,298.67 643.97,292.52 643.98,290.74C643.99,289.77 645.09,284.37 646.43,278.74C647.77,273.11 649.12,266.93 649.43,265.00C650.05,261.14 653.96,244.86 656.51,235.50C657.41,232.20 659.07,227.93 660.20,226.00C661.32,224.07 662.86,220.44 663.61,217.93C664.36,215.41 666.78,210.56 668.99,207.14C671.19,203.73 673.00,200.59 673.00,200.16C673.00,198.31 683.00,190.06 688.23,187.58C691.38,186.09 694.24,184.43 694.58,183.88C694.91,183.33 696.50,183.17 698.10,183.52C699.69,183.87 701.00,183.77 701.00,183.29C701.00,182.82 701.79,182.38 702.75,182.33C703.71,182.28 706.75,181.72 709.50,181.09C733.47,175.58 777.95,176.04 803.75,182.06C811.25,183.81 815.66,185.49 817.00,187.11C817.27,187.44 819.08,188.00 821.00,188.35C826.30,189.33 836.41,198.09 839.44,204.34C840.82,207.18 842.34,210.18 842.83,211.00C843.31,211.82 844.40,214.07 845.26,216.00C846.11,217.93 847.75,221.55 848.90,224.07C850.06,226.58 851.00,229.17 851.00,229.83C851.00,230.49 851.45,231.81 851.99,232.76C852.54,233.72 853.68,237.43 854.52,241.00C855.36,244.57 857.17,252.22 858.54,258.00C859.91,263.77 861.20,269.40 861.41,270.50C861.61,271.60 862.73,275.37 863.88,278.89C865.04,282.40 866.25,287.35 866.58,289.89C867.34,295.68 873.92,315.49 876.92,321.00C878.59,324.06 888.49,334.00 889.86,334.00C890.41,334.00 891.46,334.56 892.21,335.25C894.75,337.61 899.92,341.00 900.97,341.00C901.55,341.00 902.81,341.44 903.76,341.98C906.63,343.60 922.99,351.00 923.70,351.00C924.07,351.00 926.20,351.84 928.43,352.86C937.14,356.84 944.62,359.89 947.26,360.54C948.78,360.92 950.27,361.62 950.57,362.11C950.87,362.60 951.90,363.00 952.85,363.00C953.80,363.00 956.34,363.90 958.50,365.00C960.66,366.10 962.78,367.00 963.22,367.00C963.65,367.00 966.34,368.12 969.19,369.50C972.04,370.87 975.53,372.00 976.94,372.00C978.36,372.00 981.09,372.49 983.01,373.08C990.69,375.46 1005.07,373.53 1010.68,369.36C1012.43,368.06 1014.15,367.00 1014.49,367.00C1016.14,367.00 1024.26,362.69 1028.14,359.75C1030.54,357.93 1034.61,355.22 1037.18,353.72C1039.75,352.22 1042.59,350.27 1043.48,349.38C1045.16,347.70 1060.92,337.00 1061.71,337.00C1061.96,337.00 1064.04,335.49 1066.33,333.65C1068.62,331.82 1076.18,327.34 1083.13,323.70C1102.62,313.50 1118.45,311.15 1130.85,316.61C1136.63,319.15 1144.18,323.18 1147.88,325.69C1149.75,326.96 1151.69,328.00 1152.18,328.00C1153.23,328.00 1153.96,328.54 1160.00,333.78C1162.47,335.93 1165.22,338.10 1166.11,338.60C1168.51,339.94 1179.35,349.74 1185.29,355.93C1188.16,358.92 1192.76,363.64 1195.52,366.43C1201.37,372.35 1208.00,380.36 1208.00,381.51C1208.00,381.95 1209.24,383.92 1210.75,385.89C1214.63,390.94 1221.05,401.94 1222.19,405.50C1223.99,411.12 1224.81,421.92 1223.76,426.28C1223.21,428.60 1222.64,431.18 1222.51,432.00C1222.38,432.82 1222.04,434.18 1221.75,435.00C1221.46,435.82 1220.72,438.39 1220.09,440.70C1219.46,443.01 1216.49,449.88 1213.48,455.96C1210.46,462.05 1208.00,467.27 1208.00,467.58C1208.00,467.88 1206.82,469.68 1205.38,471.57C1203.94,473.46 1203.05,475.00 1203.40,475.00C1203.75,475.00 1202.45,477.30 1200.52,480.11C1198.58,482.92 1196.99,485.74 1196.97,486.36C1196.96,486.99 1195.61,488.81 1193.97,490.42C1192.34,492.02 1190.99,494.05 1190.98,494.92C1190.97,495.79 1190.08,497.62 1189.00,499.00C1187.92,500.38 1187.03,502.01 1187.02,502.63C1187.01,503.25 1186.33,504.31 1185.51,504.99C1184.69,505.67 1184.25,506.59 1184.53,507.04C1184.81,507.49 1184.57,508.15 1183.99,508.50C1181.88,509.81 1172.01,530.83 1172.00,534.05C1172.00,534.90 1171.49,536.11 1170.86,536.74C1169.18,538.42 1168.56,555.56 1169.94,562.24C1170.60,565.39 1171.07,568.09 1171.00,568.24C1170.92,568.38 1172.22,571.54 1173.89,575.26C1175.56,578.98 1177.82,584.83 1178.90,588.26C1181.34,595.95 1183.34,601.34 1184.00,602.00C1185.06,603.06 1188.00,610.14 1188.00,611.63C1188.00,612.49 1188.62,614.39 1189.38,615.85C1191.16,619.27 1192.15,621.58 1196.57,632.50C1198.57,637.45 1200.78,642.17 1201.47,643.00C1202.16,643.83 1203.00,645.65 1203.34,647.07C1203.67,648.48 1204.86,650.68 1205.97,651.97C1207.09,653.25 1208.00,654.71 1208.00,655.20C1208.00,655.68 1208.47,656.63 1209.04,657.29C1209.61,657.96 1211.38,660.33 1212.98,662.56C1215.90,666.63 1228.39,675.00 1231.54,675.00C1232.43,675.00 1236.38,676.08 1240.32,677.40C1244.27,678.72 1251.78,680.58 1257.00,681.53C1262.22,682.48 1269.20,683.89 1272.50,684.66C1275.80,685.42 1280.53,686.31 1283.00,686.62C1285.47,686.93 1287.95,687.52 1288.50,687.93C1289.45,688.64 1293.95,690.03 1306.75,693.60C1319.68,697.21 1330.57,701.88 1335.50,705.94C1336.60,706.84 1339.19,708.35 1341.25,709.28C1343.31,710.21 1345.00,711.45 1345.00,712.05C1345.00,712.65 1346.07,714.57 1347.38,716.32C1348.70,718.07 1350.10,720.62 1350.51,722.00C1350.91,723.38 1351.60,724.95 1352.04,725.50C1352.48,726.05 1353.78,728.98 1354.94,732.00C1356.11,735.03 1357.46,738.40 1357.97,739.50C1359.55,742.97 1361.75,752.21 1362.97,760.50C1364.91,773.70 1364.58,813.03 1362.41,825.65C1361.21,832.65 1357.67,843.80 1354.48,850.62C1352.56,854.70 1351.00,858.31 1351.00,858.64C1351.00,860.54 1345.09,868.07 1342.85,869.03C1341.39,869.65 1339.97,871.02 1339.69,872.08C1339.42,873.13 1338.36,874.29 1337.34,874.66C1336.33,875.02 1334.31,876.15 1332.85,877.16C1331.39,878.17 1329.47,879.00 1328.60,879.00C1327.72,879.00 1327.00,879.39 1327.00,879.86C1327.00,881.53 1297.74,889.96 1291.84,889.99C1290.37,889.99 1284.52,891.16 1278.84,892.57C1268.57,895.12 1263.08,896.29 1253.50,897.98C1243.04,899.83 1235.06,902.00 1231.59,903.95C1229.62,905.06 1228.00,905.76 1228.00,905.51C1228.00,905.26 1226.04,906.10 1223.64,907.37C1217.82,910.47 1209.90,918.58 1204.55,926.92C1200.03,933.97 1192.00,950.03 1192.00,952.01C1192.00,952.63 1190.03,957.27 1187.61,962.32C1184.04,969.79 1181.37,976.41 1180.46,980.00C1180.39,980.27 1179.81,981.77 1179.17,983.32C1178.52,984.86 1178.00,986.75 1178.00,987.51C1178.00,988.26 1177.59,989.14 1177.09,989.45C1176.06,990.08 1171.57,1004.08 1170.17,1011.00C1167.92,1022.07 1169.15,1031.74 1174.02,1041.54C1175.66,1044.82 1176.99,1048.21 1177.00,1049.08C1177.00,1049.94 1178.12,1051.71 1179.50,1053.00C1180.88,1054.29 1182.00,1056.25 1182.00,1057.35C1182.00,1058.44 1182.61,1060.05 1183.35,1060.92C1184.09,1061.79 1185.77,1064.53 1187.06,1067.00C1188.36,1069.47 1191.35,1074.49 1193.71,1078.13C1196.07,1081.78 1198.00,1085.12 1198.00,1085.56C1198.00,1085.99 1198.59,1087.05 1199.32,1087.92C1200.05,1088.79 1201.90,1092.42 1203.44,1096.00C1208.24,1107.14 1209.39,1109.45 1211.01,1111.21C1211.87,1112.15 1213.39,1115.30 1214.38,1118.21C1215.37,1121.12 1216.43,1124.17 1216.74,1125.00C1217.05,1125.83 1217.47,1127.38 1217.68,1128.46C1217.88,1129.53 1218.43,1130.66 1218.89,1130.96C1220.78,1132.19 1220.59,1155.74 1218.67,1157.66C1218.30,1158.03 1218.00,1159.14 1218.00,1160.13C1218.00,1161.84 1215.77,1167.74 1213.89,1171.00C1213.42,1171.83 1212.34,1174.04 1211.49,1175.92C1210.65,1177.80 1209.07,1179.96 1207.98,1180.73C1206.89,1181.49 1206.00,1182.99 1206.00,1184.06C1206.00,1185.13 1205.66,1186.01 1205.25,1186.02C1204.84,1186.03 1203.15,1188.27 1201.50,1191.01C1199.85,1193.74 1197.71,1196.24 1196.75,1196.56C1195.79,1196.87 1195.00,1197.51 1195.00,1197.98C1195.00,1198.44 1191.85,1202.08 1188.00,1206.07C1184.15,1210.06 1181.00,1213.44 1181.00,1213.58C1181.00,1214.19 1167.72,1226.54 1166.67,1226.91C1165.21,1227.41 1156.62,1234.23 1156.17,1235.25C1155.98,1235.66 1155.27,1236.00 1154.57,1236.00C1153.88,1236.00 1152.45,1236.96 1151.40,1238.14C1150.36,1239.31 1148.15,1240.92 1146.50,1241.70C1142.07,1243.80 1138.97,1245.63 1137.72,1246.88C1137.10,1247.50 1135.55,1248.00 1134.26,1248.00C1132.98,1248.00 1130.89,1248.68 1129.61,1249.52C1128.31,1250.37 1123.83,1251.30 1119.39,1251.62C1112.32,1252.15 1110.46,1251.87 1101.50,1248.98C1092.05,1245.93 1078.89,1239.64 1078.17,1237.83C1077.98,1237.37 1077.31,1237.00 1076.67,1237.00C1076.03,1237.00 1072.42,1234.97 1068.66,1232.50C1064.89,1230.02 1061.55,1228.00 1061.24,1228.00C1060.92,1228.00 1059.95,1227.38 1059.08,1226.61C1058.21,1225.85 1055.14,1224.00 1052.25,1222.51C1049.36,1221.01 1047.00,1219.49 1047.00,1219.13C1047.00,1218.77 1046.16,1218.03 1045.14,1217.49C1042.53,1216.10 1034.60,1210.83 1034.00,1210.08C1032.85,1208.65 1026.72,1205.17 1014.00,1198.76L1000.50,1191.95L989.29,1192.32C982.81,1192.54 977.48,1193.18 976.68,1193.85C975.91,1194.49 973.48,1195.19 971.27,1195.40C969.06,1195.61 966.19,1196.47 964.88,1197.30C963.57,1198.14 959.38,1199.77 955.58,1200.93C951.77,1202.09 947.99,1203.59 947.17,1204.27C946.36,1204.95 945.65,1205.36 945.60,1205.18C945.54,1205.00 944.23,1205.34 942.68,1205.93C941.14,1206.52 939.50,1207.00 939.05,1207.00C938.60,1207.00 933.79,1209.05 928.36,1211.56C922.94,1214.07 917.15,1216.74 915.50,1217.49C902.79,1223.26 892.05,1228.63 889.66,1230.40C882.44,1235.74 871.09,1248.30 868.54,1253.78C867.07,1256.92 865.45,1260.28 864.94,1261.24C864.42,1262.19 864.00,1263.79 864.00,1264.79C864.00,1265.78 863.61,1267.03 863.13,1267.55C861.82,1268.97 858.21,1282.39 856.01,1294.00C854.80,1300.40 851.12,1312.93 849.73,1315.40C849.08,1316.56 848.02,1319.75 847.38,1322.50C844.86,1333.25 836.51,1354.83 834.03,1357.00C833.71,1357.28 832.61,1358.85 831.57,1360.50C830.53,1362.15 827.93,1365.02 825.79,1366.87C823.65,1368.72 822.15,1370.48 822.44,1370.78C823.47,1371.81 820.74,1374.00 818.44,1374.00C817.16,1374.00 815.87,1374.40 815.56,1374.90C814.70,1376.29 807.14,1380.00 805.16,1380.00C804.18,1380.00 800.03,1380.86 795.94,1381.91C780.96,1385.76 761.17,1387.05 735.50,1385.84ZM780.00,1042.59C788.84,1041.92 812.03,1038.21 813.32,1037.26C813.97,1036.79 816.08,1036.29 818.00,1036.15C819.92,1036.02 822.62,1035.50 824.00,1035.01C825.38,1034.51 829.65,1033.19 833.50,1032.08C837.35,1030.96 844.33,1028.41 849.00,1026.40C853.67,1024.40 860.20,1021.76 863.50,1020.53C869.48,1018.31 880.43,1012.65 891.61,1006.00C894.85,1004.08 897.95,1002.33 898.50,1002.12C899.05,1001.91 901.30,1000.32 903.50,998.59C905.70,996.87 909.41,994.17 911.75,992.59C914.09,991.02 916.00,989.37 916.00,988.93C916.00,988.49 916.88,987.85 917.96,987.51C919.92,986.89 925.39,981.95 940.50,967.15C948.67,959.15 951.02,956.60 959.10,946.98C974.98,928.07 992.44,899.99 999.08,882.65C1000.17,879.82 1001.49,876.60 1002.01,875.50C1002.54,874.40 1003.63,871.02 1004.44,868.00C1005.24,864.98 1007.30,858.45 1009.00,853.50C1012.18,844.28 1015.14,832.04 1014.47,830.95C1014.26,830.62 1014.77,828.13 1015.59,825.42C1017.39,819.49 1017.73,815.52 1018.34,793.50C1018.98,770.14 1016.49,734.68 1013.97,731.50C1013.54,730.95 1012.95,728.48 1012.67,726.00C1012.38,723.52 1011.25,718.80 1010.16,715.50C1009.06,712.20 1007.38,706.80 1006.42,703.50C1003.69,694.13 995.54,674.12 991.97,668.00C991.48,667.17 989.44,663.58 987.43,660.00C985.42,656.42 982.18,651.02 980.23,648.00C971.66,634.67 971.12,633.87 968.49,630.72C967.93,630.05 965.90,627.48 963.99,625.00C956.38,615.17 934.50,592.93 925.14,585.50C912.83,575.75 903.45,568.99 900.00,567.39C898.08,566.50 896.27,565.46 896.00,565.07C894.31,562.70 868.35,548.06 865.74,548.01C865.32,548.01 860.82,546.00 855.74,543.56C850.66,541.12 845.15,538.81 843.50,538.42C841.85,538.04 840.05,537.39 839.50,536.98C838.20,536.01 831.86,534.55 830.25,534.86C829.56,534.98 829.00,534.62 829.00,534.04C829.00,533.47 828.14,533.00 827.08,533.00C826.02,533.00 820.29,531.82 814.33,530.39C808.37,528.95 801.92,527.64 800.00,527.49C798.08,527.33 792.45,526.39 787.50,525.39C780.23,523.93 773.69,523.59 753.50,523.61C728.34,523.63 718.17,524.63 703.50,528.54C700.75,529.28 696.25,530.15 693.50,530.48C688.92,531.04 679.40,533.82 674.50,536.04C673.40,536.53 669.58,537.90 666.00,539.07C662.42,540.24 656.58,542.54 653.00,544.17C643.42,548.56 629.57,555.41 629.00,556.05C628.73,556.36 624.51,558.76 619.64,561.37C614.76,563.99 610.26,566.56 609.64,567.09C609.01,567.62 605.58,570.30 602.00,573.06C598.42,575.82 593.52,579.75 591.11,581.79C588.69,583.83 585.32,586.48 583.61,587.68C579.98,590.22 559.11,611.60 554.00,618.01C552.08,620.43 548.79,624.29 546.69,626.59C544.60,628.90 540.41,634.72 537.39,639.54C534.37,644.35 530.54,650.26 528.88,652.67C525.20,658.02 512.00,684.25 512.00,686.21C512.00,686.98 511.34,688.49 510.53,689.56C509.72,690.63 509.05,692.42 509.03,693.55C509.01,694.68 508.60,696.03 508.11,696.55C507.12,697.60 502.66,710.67 501.55,715.75C501.16,717.54 500.50,719.00 500.09,719.00C499.67,719.00 499.29,719.56 499.24,720.25C499.19,720.94 498.66,723.98 498.07,727.00C492.75,754.25 491.00,771.12 491.54,790.17C492.03,807.83 493.46,823.71 494.97,828.50C495.50,830.15 496.14,833.30 496.40,835.50C497.11,841.55 500.39,854.28 504.26,866.00C508.36,878.40 507.34,876.10 526.25,915.73C526.84,916.96 528.05,918.76 528.95,919.73C529.85,920.70 532.11,923.75 533.97,926.50C538.54,933.25 549.03,946.31 550.67,947.30C551.40,947.74 552.00,948.82 552.00,949.70C552.00,951.44 585.68,985.00 587.44,985.00C588.02,985.01 589.85,986.26 591.50,987.79C593.15,989.31 596.08,991.65 598.00,992.98C599.92,994.31 601.73,995.67 602.00,995.99C602.62,996.71 618.38,1006.87 622.50,1009.20C628.16,1012.39 641.50,1018.85 648.00,1021.53C651.58,1023.00 654.95,1024.55 655.50,1024.97C656.05,1025.39 658.30,1026.28 660.50,1026.94C662.70,1027.60 665.40,1028.53 666.50,1029.00C672.24,1031.48 687.07,1035.97 691.00,1036.42C693.48,1036.71 698.01,1037.60 701.08,1038.41C704.14,1039.22 708.87,1040.15 711.58,1040.47C714.28,1040.78 717.39,1041.32 718.47,1041.66C723.98,1043.38 762.18,1043.96 780.00,1042.59Z";
let SETTINGS_ICON_PATH2D = null;
const INFO_ICON_VIEWBOX = 1536;
const INFO_ICON_PATH =
  "M712.50,1351.02C710.80,1350.39 699.61,1349.30 686.00,1348.46C678.35,1347.98 640.73,1341.81 636.74,1340.38C634.41,1339.54 629.35,1338.26 625.50,1337.52C612.61,1335.06 604.55,1333.02 597.50,1330.41C593.65,1328.99 588.92,1327.46 587.00,1327.01C585.08,1326.56 581.02,1325.20 578.00,1323.99C574.98,1322.78 569.80,1321.01 566.50,1320.04C563.20,1319.08 558.02,1317.28 555.00,1316.04C551.98,1314.81 547.70,1313.14 545.50,1312.34C537.40,1309.39 528.37,1305.75 523.50,1303.47C520.75,1302.18 513.55,1298.81 507.50,1295.98C501.45,1293.16 494.93,1289.96 493.00,1288.87C491.07,1287.78 486.58,1285.53 483.01,1283.88C479.43,1282.22 475.08,1279.77 473.32,1278.43C471.57,1277.09 469.84,1276.00 469.47,1276.00C469.11,1276.00 463.57,1272.78 457.16,1268.83C450.75,1264.89 444.23,1260.96 442.67,1260.08C441.11,1259.21 439.00,1258.02 437.98,1257.44C433.60,1254.93 395.81,1226.93 394.00,1224.84C393.18,1223.90 389.12,1220.34 385.00,1216.95C357.48,1194.33 311.78,1146.55 297.99,1125.98C295.59,1122.42 291.78,1117.25 289.51,1114.50C287.25,1111.75 284.10,1107.25 282.53,1104.50C280.96,1101.75 279.39,1099.28 279.05,1099.00C277.83,1098.01 271.24,1088.35 266.44,1080.50C263.75,1076.10 261.20,1072.35 260.77,1072.17C260.35,1071.98 260.00,1071.30 260.00,1070.64C260.00,1069.99 258.53,1067.21 256.73,1064.48C254.93,1061.74 252.24,1057.03 250.76,1054.00C249.27,1050.97 246.23,1045.35 244.00,1041.50C238.42,1031.88 234.44,1023.85 230.84,1015.00C229.17,1010.88 226.79,1005.25 225.55,1002.50C224.31,999.75 221.81,993.45 219.99,988.50C218.17,983.55 216.30,979.07 215.84,978.55C215.38,978.03 215.00,976.75 215.00,975.72C215.00,973.90 209.95,958.54 208.01,954.50C206.94,952.25 203.09,937.75 199.40,922.00C198.04,916.23 196.52,909.92 196.01,908.00C192.98,896.51 187.62,860.01 186.38,842.50C185.39,828.54 185.16,766.04 186.07,761.00C186.52,758.52 187.13,753.12 187.42,749.00C188.01,740.77 190.25,722.91 191.89,713.50C192.46,710.20 193.13,705.92 193.38,704.00C193.63,702.08 195.01,695.10 196.46,688.50C197.91,681.90 199.28,675.21 199.51,673.63C199.96,670.62 202.95,660.33 206.12,650.93C207.15,647.87 208.00,644.52 208.00,643.49C208.00,640.33 213.33,623.38 218.06,611.50C218.50,610.40 219.39,607.70 220.04,605.50C220.69,603.30 223.13,597.45 225.46,592.50C231.44,579.80 236.00,569.47 236.00,568.61C236.00,567.87 240.30,558.81 241.98,556.00C242.47,555.17 246.13,547.85 250.09,539.71C254.06,531.58 257.69,524.69 258.16,524.40C258.62,524.12 259.00,523.24 259.00,522.45C259.00,521.66 260.60,518.92 262.57,516.35C264.53,513.78 267.29,509.39 268.70,506.59C270.11,503.79 272.22,500.32 273.38,498.88C274.55,497.43 276.27,494.96 277.22,493.38C280.02,488.70 281.46,486.53 282.12,486.00C282.47,485.73 284.53,482.74 286.70,479.36C288.88,475.98 292.08,471.42 293.83,469.22C295.57,467.01 297.00,464.80 297.00,464.30C297.00,463.80 298.57,461.67 300.50,459.57C302.42,457.47 304.00,455.36 304.00,454.87C304.00,454.39 304.43,454.00 304.96,454.00C305.49,454.00 307.00,452.42 308.32,450.48C309.63,448.55 312.48,445.06 314.64,442.73C316.80,440.40 319.89,436.70 321.50,434.50C327.29,426.58 351.50,401.95 368.10,387.09C373.27,382.46 378.25,377.85 379.16,376.84C380.07,375.83 381.20,374.99 381.66,374.98C382.12,374.98 385.20,372.46 388.50,369.39C391.80,366.32 395.85,362.85 397.50,361.68C400.88,359.29 401.48,358.82 405.00,355.86C406.38,354.71 409.30,352.62 411.50,351.23C413.70,349.84 415.73,348.39 416.00,348.00C416.27,347.61 417.62,346.72 419.00,346.01C420.38,345.30 422.18,344.10 423.00,343.33C426.79,339.81 430.67,336.96 433.94,335.31C435.90,334.31 437.65,333.16 437.83,332.75C438.02,332.34 441.17,330.34 444.83,328.31C451.03,324.87 457.25,320.96 467.78,313.88C470.13,312.29 472.33,311.00 472.66,311.00C474.85,311.00 491.06,301.49 491.83,299.75C492.02,299.34 492.77,299.00 493.52,299.00C495.17,299.00 504.50,295.12 516.50,289.45C521.45,287.12 527.75,284.45 530.50,283.53C533.25,282.61 536.85,281.24 538.50,280.50C540.15,279.75 544.65,277.95 548.50,276.50C552.35,275.04 556.40,273.50 557.50,273.06C566.78,269.35 585.43,263.66 595.88,261.35C599.39,260.57 603.08,259.49 604.09,258.95C605.09,258.41 609.59,257.28 614.08,256.43C618.56,255.57 624.38,254.03 627.01,253.00C629.63,251.96 632.01,251.34 632.28,251.61C632.56,251.89 639.69,250.76 648.14,249.11C656.59,247.46 665.98,245.83 669.00,245.47C672.02,245.12 678.10,244.23 682.50,243.49C696.32,241.17 754.14,239.92 775.00,241.48C779.12,241.79 785.20,242.22 788.50,242.43C791.80,242.64 795.85,243.05 797.50,243.34C799.15,243.62 804.33,244.13 809.00,244.47C813.67,244.80 820.42,245.72 824.00,246.51C827.58,247.30 834.77,248.60 840.00,249.41C856.84,252.01 872.46,254.97 874.03,255.87C874.88,256.35 877.13,257.06 879.03,257.46C882.54,258.17 892.25,260.81 895.00,261.79C895.83,262.09 896.73,262.38 897.00,262.45C904.36,264.23 911.89,266.38 913.24,267.09C914.19,267.59 915.79,268.00 916.79,268.00C917.78,268.00 919.03,268.38 919.55,268.83C920.07,269.29 922.75,270.45 925.50,271.41C930.34,273.10 931.66,273.59 937.00,275.73C938.38,276.28 941.30,277.20 943.50,277.78C948.46,279.07 958.66,283.04 962.00,284.98C963.38,285.78 966.52,287.18 969.00,288.10C974.98,290.33 979.46,292.48 985.50,296.00C988.25,297.60 991.37,299.23 992.43,299.62C993.49,300.01 998.44,302.43 1003.43,305.00C1008.42,307.57 1014.60,310.47 1017.18,311.44C1019.75,312.42 1022.87,314.29 1024.10,315.61C1025.34,316.92 1026.75,318.00 1027.24,318.00C1027.74,318.00 1030.02,319.25 1032.32,320.78C1034.62,322.31 1038.08,324.33 1040.00,325.28C1041.92,326.23 1046.20,329.00 1049.50,331.45C1052.80,333.90 1055.99,335.92 1056.60,335.95C1057.20,335.98 1058.65,336.79 1059.81,337.75C1060.98,338.71 1064.22,341.07 1067.02,343.00C1069.81,344.93 1073.77,347.73 1075.80,349.24C1077.84,350.74 1079.97,352.32 1080.53,352.74C1081.10,353.16 1083.80,355.32 1086.53,357.55C1089.27,359.77 1093.08,362.67 1095.00,363.98C1096.92,365.29 1099.17,366.95 1100.00,367.66C1100.83,368.38 1102.81,370.10 1104.41,371.50C1106.01,372.89 1109.61,375.93 1112.41,378.25C1119.20,383.88 1136.06,400.08 1147.75,412.20C1148.44,412.92 1151.14,415.70 1153.75,418.39C1164.62,429.59 1166.00,431.12 1166.00,431.98C1166.00,432.48 1168.25,435.10 1171.00,437.81C1173.75,440.52 1176.00,442.96 1176.00,443.23C1176.00,443.51 1178.36,446.25 1181.25,449.32C1187.63,456.09 1191.00,460.45 1191.00,461.91C1191.00,462.51 1191.42,463.00 1191.93,463.00C1192.45,463.00 1193.13,463.82 1193.44,464.82C1193.76,465.82 1195.28,467.96 1196.81,469.57C1198.34,471.18 1201.79,475.88 1204.47,480.00C1207.15,484.12 1211.67,490.43 1214.50,494.00C1217.34,497.57 1220.20,501.85 1220.85,503.51C1221.51,505.16 1223.28,507.86 1224.78,509.51C1226.29,511.15 1228.08,513.62 1228.77,515.00C1229.46,516.38 1230.91,518.85 1232.00,520.50C1233.08,522.15 1234.45,524.62 1235.04,526.00C1236.77,530.05 1250.00,555.59 1253.77,562.17C1254.93,564.19 1256.85,568.24 1258.05,571.17C1264.73,587.54 1266.29,591.47 1270.07,601.50C1272.36,607.55 1275.13,614.73 1276.23,617.46C1277.34,620.19 1278.32,622.89 1278.42,623.46C1278.66,624.77 1282.35,637.19 1285.43,647.00C1289.73,660.73 1289.48,659.67 1296.04,690.50C1297.68,698.20 1299.69,709.90 1300.52,716.50C1301.34,723.10 1302.25,730.08 1302.55,732.00C1302.85,733.92 1303.30,738.20 1303.55,741.50C1303.80,744.80 1304.47,752.00 1305.03,757.50C1306.24,769.27 1305.51,831.11 1304.04,841.50C1299.92,870.72 1298.01,883.00 1296.89,887.50C1296.35,889.70 1295.51,893.08 1295.03,895.00C1294.55,896.92 1293.20,902.77 1292.03,908.00C1289.38,919.86 1288.35,923.71 1285.46,932.50C1284.19,936.35 1282.20,943.30 1281.02,947.95C1279.84,952.60 1278.06,958.45 1277.05,960.95C1276.05,963.45 1273.75,969.55 1271.95,974.50C1270.14,979.45 1267.79,985.50 1266.72,987.94C1265.65,990.38 1264.14,994.18 1263.36,996.39C1261.85,1000.67 1260.75,1003.07 1250.96,1023.50C1247.53,1030.65 1244.45,1036.72 1244.11,1037.00C1243.78,1037.28 1242.32,1039.75 1240.89,1042.50C1235.89,1052.06 1229.00,1064.35 1227.74,1065.92C1227.05,1066.79 1225.60,1069.30 1224.51,1071.50C1221.83,1076.94 1213.68,1089.74 1210.28,1093.87C1208.75,1095.72 1207.06,1098.19 1206.53,1099.37C1206.00,1100.54 1204.60,1102.40 1203.43,1103.50C1202.26,1104.60 1201.01,1106.17 1200.65,1107.00C1200.29,1107.83 1198.54,1110.40 1196.75,1112.72C1194.96,1115.03 1190.67,1120.66 1187.21,1125.22C1176.50,1139.32 1166.77,1151.10 1160.17,1157.94C1156.69,1161.55 1151.06,1167.65 1147.67,1171.49C1137.34,1183.21 1104.06,1214.80 1096.61,1219.96C1095.45,1220.77 1093.42,1222.42 1092.09,1223.64C1088.40,1227.03 1076.73,1235.49 1062.65,1244.99C1059.43,1247.16 1055.70,1250.03 1054.36,1251.37C1053.01,1252.71 1050.32,1254.57 1048.37,1255.50C1046.42,1256.42 1044.03,1257.93 1043.07,1258.84C1042.11,1259.75 1040.46,1261.04 1039.41,1261.69C1038.36,1262.34 1033.68,1265.27 1029.00,1268.19C1024.33,1271.11 1019.38,1274.09 1018.00,1274.82C1016.63,1275.54 1014.83,1276.72 1014.00,1277.44C1013.18,1278.15 1004.85,1282.69 995.50,1287.51C986.15,1292.34 977.43,1297.12 976.12,1298.14C974.80,1299.16 973.33,1300.00 972.84,1300.00C972.35,1300.00 968.76,1301.58 964.86,1303.50C960.97,1305.42 957.02,1307.00 956.08,1307.00C955.15,1307.00 953.51,1307.66 952.44,1308.47C951.37,1309.28 949.95,1309.95 949.28,1309.97C948.61,1309.99 945.60,1311.12 942.59,1312.50C939.59,1313.88 936.51,1315.00 935.76,1315.00C935.01,1315.00 933.97,1315.38 933.45,1315.86C932.93,1316.33 930.02,1317.49 927.00,1318.45C923.98,1319.40 917.45,1321.65 912.50,1323.44C907.55,1325.24 900.35,1327.64 896.50,1328.79C878.06,1334.29 871.93,1335.99 865.00,1337.49C860.88,1338.39 853.90,1339.97 849.50,1341.00C845.10,1342.03 839.70,1343.08 837.50,1343.32C835.30,1343.57 832.83,1344.03 832.00,1344.36C829.61,1345.30 803.65,1348.81 790.18,1350.01C775.64,1351.32 715.39,1352.09 712.50,1351.02ZM776.50,1233.59C783.46,1232.61 793.75,1231.73 797.00,1231.84C798.92,1231.90 802.08,1231.56 804.00,1231.07C809.38,1229.71 817.12,1228.09 821.00,1227.52C822.92,1227.23 826.41,1226.55 828.75,1226.00C831.09,1225.45 835.14,1224.52 837.75,1223.94C844.57,1222.41 848.69,1221.38 855.50,1219.51C874.40,1214.32 879.59,1212.70 881.41,1211.42C882.53,1210.64 884.38,1210.00 885.52,1210.00C886.67,1210.00 888.03,1209.60 888.55,1209.11C889.07,1208.62 893.02,1207.05 897.32,1205.62C901.62,1204.20 906.35,1202.40 907.82,1201.64C912.38,1199.28 918.01,1197.00 919.28,1197.00C920.74,1196.99 932.14,1191.23 954.50,1179.19C957.25,1177.71 960.85,1175.54 962.50,1174.38C964.15,1173.21 966.40,1171.97 967.50,1171.62C968.60,1171.26 971.27,1169.43 973.42,1167.54C975.58,1165.66 977.60,1164.14 977.92,1164.18C979.59,1164.35 980.99,1163.87 982.18,1162.71C982.91,1162.00 985.08,1160.46 987.00,1159.28C988.92,1158.10 991.41,1156.32 992.52,1155.32C993.63,1154.32 997.11,1151.76 1000.27,1149.63C1003.42,1147.50 1006.00,1145.46 1006.00,1145.09C1006.00,1144.73 1007.46,1143.57 1009.25,1142.52C1011.04,1141.46 1013.40,1139.75 1014.50,1138.72C1015.60,1137.68 1017.74,1136.18 1019.25,1135.39C1020.76,1134.60 1022.00,1133.52 1022.00,1133.01C1022.00,1132.49 1023.12,1131.48 1024.49,1130.76C1029.70,1128.03 1053.40,1105.21 1067.84,1089.03C1071.50,1084.92 1076.13,1079.94 1078.11,1077.96C1080.10,1075.97 1082.56,1073.03 1083.59,1071.42C1084.61,1069.82 1086.03,1068.14 1086.73,1067.70C1087.43,1067.26 1088.00,1066.51 1088.00,1066.03C1088.00,1065.55 1089.24,1063.86 1090.75,1062.29C1095.72,1057.10 1100.09,1051.72 1101.47,1049.09C1102.22,1047.66 1103.68,1045.60 1104.72,1044.50C1106.84,1042.26 1115.49,1029.28 1118.27,1024.18C1119.26,1022.36 1122.58,1017.02 1125.64,1012.32C1128.70,1007.63 1132.31,1001.47 1133.66,998.64C1135.01,995.81 1137.22,991.70 1138.58,989.50C1139.93,987.30 1141.32,984.83 1141.66,984.00C1142.00,983.17 1144.05,978.67 1146.22,974.00C1154.25,956.70 1154.14,956.95 1158.50,946.00C1159.92,942.42 1161.49,938.60 1161.98,937.50C1162.47,936.40 1163.15,934.38 1163.49,933.00C1163.84,931.62 1166.60,922.62 1169.64,913.00C1177.13,889.27 1177.60,887.47 1180.40,872.00C1183.50,854.92 1184.79,844.98 1185.50,833.00C1185.80,827.77 1186.28,821.70 1186.55,819.50C1187.09,815.14 1188.28,780.43 1187.97,778.00C1187.87,777.17 1187.64,773.35 1187.46,769.50C1186.90,757.61 1184.93,739.84 1183.34,732.50C1182.51,728.65 1181.47,722.12 1181.04,718.00C1179.99,708.13 1175.81,690.11 1171.48,676.82C1169.57,670.95 1168.00,665.43 1168.00,664.56C1168.00,663.69 1167.57,662.19 1167.05,661.24C1166.54,660.28 1163.80,652.40 1160.97,643.73C1158.14,635.06 1155.19,627.33 1154.41,626.55C1153.64,625.78 1153.00,624.53 1153.00,623.77C1153.00,623.02 1152.62,621.97 1152.16,621.45C1151.70,620.93 1150.29,618.02 1149.03,615.00C1145.48,606.50 1142.05,598.75 1140.60,596.00C1131.16,578.06 1126.86,570.37 1123.00,564.50C1120.47,560.65 1116.84,554.85 1114.95,551.62C1113.05,548.39 1109.67,543.66 1107.44,541.12C1105.21,538.58 1102.36,534.81 1101.10,532.74C1099.85,530.67 1097.40,527.19 1095.66,525.01C1093.92,522.84 1090.03,517.85 1087.00,513.93C1083.97,510.02 1079.32,504.49 1076.66,501.66C1074.00,498.82 1069.73,494.05 1067.16,491.05C1064.60,488.06 1061.47,484.68 1060.22,483.55C1058.97,482.42 1055.09,478.80 1051.61,475.50C1036.84,461.52 1028.46,454.25 1022.64,450.37C1019.23,448.09 1015.83,445.50 1015.10,444.62C1014.36,443.73 1013.14,443.00 1012.39,443.00C1011.63,443.00 1010.45,442.10 1009.77,441.00C1009.08,439.90 1008.15,439.00 1007.71,439.00C1006.81,439.00 988.84,426.95 987.94,425.75C987.18,424.73 975.95,418.00 975.01,418.00C974.60,418.00 971.27,415.99 967.60,413.53C963.94,411.08 959.27,408.29 957.22,407.34C955.17,406.38 953.27,405.27 952.98,404.87C952.69,404.46 950.44,403.24 947.98,402.16C945.52,401.08 941.95,399.03 940.06,397.60C938.16,396.17 936.07,395.00 935.41,395.00C933.64,395.00 913.75,386.90 912.00,385.47C911.17,384.79 909.38,383.91 908.00,383.51C906.62,383.11 904.15,382.21 902.50,381.51C900.85,380.81 897.92,379.68 896.00,379.00C894.08,378.32 891.02,377.11 889.21,376.32C887.40,375.52 884.93,374.68 883.71,374.44C882.50,374.20 880.04,373.73 878.25,373.39C876.46,373.05 875.00,372.47 875.00,372.09C875.00,371.72 872.19,370.84 868.75,370.14C865.31,369.44 861.81,368.50 860.96,368.06C860.12,367.61 857.53,366.93 855.21,366.54C852.90,366.14 851.00,365.49 851.00,365.07C851.00,364.66 847.74,363.78 843.75,363.11C839.76,362.45 831.77,361.02 826.00,359.95C815.29,357.96 806.42,356.58 797.50,355.53C794.75,355.21 788.90,354.47 784.50,353.89C768.00,351.73 730.89,350.88 715.00,352.31C709.23,352.83 702.92,353.39 701.00,353.54C699.08,353.70 696.15,354.05 694.50,354.33C691.07,354.89 681.18,356.09 676.00,356.57C665.42,357.55 650.54,360.51 638.50,364.04C634.65,365.17 629.02,366.76 626.00,367.59C615.87,370.35 614.56,370.77 599.50,376.00C591.25,378.86 582.25,382.23 579.50,383.47C570.07,387.74 566.93,389.00 565.72,389.00C564.45,389.01 556.51,392.95 542.00,400.77C537.33,403.29 532.15,406.02 530.50,406.85C528.85,407.67 527.27,408.61 527.00,408.93C526.73,409.25 524.81,410.40 522.75,411.49C520.69,412.57 519.00,413.77 519.00,414.16C519.00,414.55 518.07,415.16 516.94,415.52C513.54,416.60 501.70,423.74 498.79,426.46C497.31,427.86 495.87,429.00 495.59,429.00C494.60,429.00 486.42,434.88 484.58,436.91C483.54,438.06 482.20,439.00 481.60,439.01C480.99,439.01 478.84,440.59 476.82,442.51C474.79,444.43 472.86,446.00 472.52,446.00C472.18,446.00 468.10,449.38 463.47,453.50C458.83,457.62 454.61,461.00 454.09,461.00C453.56,461.00 452.88,461.80 452.57,462.78C452.26,463.76 450.72,465.32 449.16,466.25C445.91,468.16 436.97,476.83 422.50,492.09C412.96,502.14 410.26,505.20 404.18,512.89C402.71,514.75 398.57,519.94 395.00,524.41C391.43,528.88 386.35,535.68 383.73,539.52C381.10,543.36 377.66,548.30 376.09,550.50C370.59,558.19 362.68,570.53 361.35,573.50C360.61,575.15 358.89,578.30 357.54,580.50C356.18,582.70 352.75,589.23 349.91,595.00C347.08,600.77 344.28,606.40 343.69,607.50C340.69,613.12 337.77,619.62 336.36,623.82C335.50,626.39 333.50,631.34 331.90,634.81C330.31,638.28 328.72,642.33 328.37,643.81C328.01,645.29 327.35,646.98 326.89,647.57C326.43,648.16 325.31,651.54 324.41,655.07C323.51,658.61 322.35,662.31 321.82,663.31C321.30,664.30 319.80,669.03 318.49,673.81C317.18,678.59 314.74,687.23 313.06,693.00C311.38,698.77 310.01,704.91 310.01,706.62C310.00,708.34 309.39,711.49 308.63,713.62C307.88,715.76 307.01,719.60 306.70,722.18C306.38,724.75 305.68,728.57 305.13,730.68C303.92,735.35 302.18,749.97 300.29,771.50C298.64,790.23 300.01,828.49 303.10,850.00C303.69,854.12 304.36,859.98 304.59,863.00C305.17,870.71 306.74,880.18 307.96,883.41C308.53,884.90 309.00,887.83 309.00,889.90C309.00,891.97 309.31,893.98 309.70,894.36C310.08,894.74 310.50,895.61 310.62,896.28C312.27,904.90 316.79,922.64 317.88,924.73C318.38,925.70 319.80,930.10 321.03,934.50C323.52,943.38 326.97,952.99 328.20,954.45C328.64,954.97 329.00,955.98 329.00,956.70C329.00,957.41 330.84,962.16 333.10,967.25C335.35,972.34 338.08,978.52 339.17,981.00C342.33,988.25 344.74,993.05 348.95,1000.50C351.12,1004.35 354.33,1010.20 356.09,1013.50C357.84,1016.80 360.81,1021.52 362.67,1024.00C364.54,1026.47 369.19,1033.22 373.00,1039.00C382.67,1053.66 385.58,1057.70 390.97,1064.00C393.56,1067.03 396.09,1070.23 396.59,1071.13C400.27,1077.75 436.30,1114.97 454.12,1130.58C457.90,1133.88 474.00,1146.00 474.62,1146.00C474.93,1146.00 477.43,1147.97 480.19,1150.39C482.95,1152.80 486.40,1155.37 487.85,1156.11C489.31,1156.84 493.23,1159.35 496.56,1161.67C499.89,1164.00 506.64,1167.97 511.55,1170.50C516.47,1173.03 521.62,1176.13 523.00,1177.39C525.59,1179.76 531.93,1183.00 533.97,1183.00C534.61,1183.00 537.08,1184.33 539.44,1185.96C541.81,1187.59 543.98,1188.69 544.26,1188.41C544.54,1188.13 546.46,1189.05 548.52,1190.45C550.59,1191.85 552.85,1193.00 553.55,1193.00C554.94,1193.00 563.19,1197.09 564.02,1198.19C564.31,1198.58 566.34,1199.33 568.52,1199.86C570.71,1200.40 575.88,1202.26 580.00,1203.99C586.78,1206.85 607.65,1213.86 620.50,1217.60C623.25,1218.40 626.85,1219.46 628.50,1219.95C630.15,1220.44 634.20,1221.40 637.50,1222.09C640.80,1222.77 643.95,1223.66 644.50,1224.05C645.05,1224.45 651.35,1225.54 658.50,1226.48C665.65,1227.41 672.40,1228.56 673.50,1229.03C675.54,1229.90 688.71,1231.42 704.00,1232.56C708.67,1232.91 715.20,1233.49 718.50,1233.85C724.76,1234.53 771.28,1234.32 776.50,1233.59ZM709.54,1099.33C705.17,1098.57 701.34,1097.60 701.04,1097.18C700.74,1096.75 697.71,1095.64 694.29,1094.71C690.88,1093.78 685.46,1091.22 682.26,1089.02C676.25,1084.90 668.00,1077.65 668.00,1076.51C668.00,1076.15 666.29,1073.75 664.20,1071.18C658.74,1064.47 654.15,1054.31 652.13,1044.50C650.04,1034.36 648.86,1022.19 649.40,1016.43C649.70,1013.17 650.21,1006.00 650.54,1000.50C651.09,991.03 656.21,960.80 657.99,956.50C659.14,953.72 662.10,940.81 662.17,938.27C662.19,937.84 662.67,936.61 663.26,935.52C665.28,931.73 669.00,914.46 669.00,908.81C669.00,906.78 669.45,904.84 670.00,904.50C670.55,904.16 671.00,902.84 671.00,901.56C671.00,900.29 671.64,897.72 672.42,895.85C673.20,893.99 674.12,890.44 674.46,887.98C675.22,882.61 676.91,876.86 678.12,875.55C678.60,875.03 679.00,873.48 679.00,872.12C679.00,870.76 679.43,868.26 679.95,866.57C682.48,858.35 684.05,851.70 685.45,843.29C686.29,838.23 688.05,830.81 689.35,826.79C691.57,819.97 692.26,817.00 694.93,803.00C699.14,780.89 699.53,774.49 697.46,761.90C696.52,756.18 695.36,751.01 694.88,750.41C694.41,749.81 694.26,749.07 694.56,748.78C695.49,747.84 686.90,741.14 683.93,740.48C679.55,739.52 676.00,736.24 676.02,733.18C676.05,726.71 681.33,724.53 704.00,721.58C710.88,720.68 718.30,719.34 720.50,718.60C726.90,716.43 735.71,714.67 737.24,715.26C738.02,715.56 740.87,715.37 743.58,714.83C749.86,713.58 799.29,713.73 804.04,715.01C807.65,715.98 810.89,718.78 812.74,722.50C815.07,727.18 815.00,732.21 812.38,748.17C810.91,757.15 809.66,766.82 809.60,769.67C809.55,772.51 809.18,775.15 808.80,775.53C808.41,775.92 808.31,777.42 808.58,778.87C809.32,782.91 805.42,806.38 800.91,825.00C800.31,827.48 799.62,831.30 799.38,833.50C798.69,839.83 798.25,842.16 796.72,847.50C794.59,854.90 791.50,868.67 790.54,875.00C790.33,876.38 790.07,877.50 789.97,877.50C789.86,877.50 789.62,878.83 789.43,880.47C789.24,882.10 787.75,888.85 786.12,895.47C779.86,920.79 774.05,950.06 771.91,967.00C770.43,978.66 769.61,999.11 770.44,1003.52C771.83,1010.94 781.42,1016.95 791.00,1016.39C809.85,1015.31 812.23,1014.74 819.90,1009.50C823.90,1006.77 829.42,1002.61 832.16,1000.27C837.91,995.36 842.10,994.71 846.37,998.07C849.82,1000.79 849.81,1004.87 846.34,1011.73C841.88,1020.54 825.17,1041.89 814.03,1053.01C802.44,1064.59 785.69,1079.98 783.13,1081.41C782.23,1081.92 781.27,1082.59 781.00,1082.91C779.49,1084.68 761.03,1093.94 758.95,1093.97C758.10,1093.99 756.92,1094.48 756.32,1095.08C755.17,1096.23 749.69,1097.79 744.00,1098.59C742.08,1098.85 739.38,1099.32 738.00,1099.62C732.60,1100.80 717.10,1100.64 709.54,1099.33ZM763.38,648.42C748.50,645.94 738.41,640.80 727.66,630.24C716.74,619.52 710.85,606.64 709.12,589.71C708.22,580.89 708.34,579.27 710.41,571.76C712.65,563.63 717.80,552.02 720.49,549.03C727.00,541.80 736.89,532.99 740.77,530.97C743.37,529.61 745.78,528.12 746.12,527.65C747.45,525.83 760.11,523.72 772.26,523.29C790.25,522.66 802.25,525.90 813.56,534.46C818.98,538.56 827.94,547.91 827.98,549.51C827.99,550.07 829.03,551.64 830.29,553.01C831.56,554.38 833.76,559.10 835.18,563.50C844.11,590.98 835.53,619.50 813.36,636.06C799.25,646.60 780.41,651.26 763.38,648.42Z";

const COLORS = {
  I: "rgb(85,214,255)",
  J: "rgb(86,105,255)",
  L: "rgb(255,167,71)",
  O: "rgb(255,231,87)",
  S: "rgb(122,235,132)",
  T: "rgb(187,128,255)",
  Z: "rgb(255,118,118)",
  X: "rgb(50,52,62)",
  Text: "rgb(235,235,235)",
  Overlay: "rgba(0,0,0,0.55)",
};

const THEME_PRESETS = {
  glass: {
    panel_bg: "rgba(20,24,32,0.55)",
    panel_border: "rgba(255,255,255,0.18)",
    panel_shadow: "rgba(0,0,0,0.35)",
    button: "rgba(255,255,255,0.9)",
    accent: "rgba(120,200,255,0.9)",
    text: "#F2F5F8",
    button_bg: "rgba(255,255,255,0.08)",
    button_hover: "rgba(255,255,255,0.18)",
  },
  flat: {
    panel_bg: "rgba(30,30,34,0.92)",
    panel_border: "rgba(255,255,255,0.12)",
    panel_shadow: "rgba(0,0,0,0.25)",
    button: "#F2F2F2",
    accent: "#5BD7FF",
    text: "#F2F2F2",
    button_bg: "rgba(255,255,255,0.06)",
    button_hover: "rgba(255,255,255,0.16)",
  },
  neon: {
    panel_bg: "rgba(12,12,18,0.82)",
    panel_border: "rgba(120,255,200,0.35)",
    panel_shadow: "rgba(0,0,0,0.35)",
    button: "#E9FFF4",
    accent: "#7CFFB0",
    text: "#E9FFF4",
    button_bg: "rgba(124,255,176,0.08)",
    button_hover: "rgba(124,255,176,0.2)",
  },
  minimal: {
    panel_bg: "rgba(24,26,28,0.9)",
    panel_border: "rgba(255,255,255,0.08)",
    panel_shadow: "rgba(0,0,0,0.2)",
    button: "#F4F4F4",
    accent: "#A6B0FF",
    text: "#F4F4F4",
    button_bg: "rgba(255,255,255,0.05)",
    button_hover: "rgba(255,255,255,0.12)",
  },
};

const BLOCK_STYLE_TEXTURES = new Map();

const DEFAULT_CONFIG = {
  theme: "glass",
  theme_colors: JSON.parse(JSON.stringify(THEME_PRESETS)),
  theme_settings: {
    glass_radius: 6,
    neon_glow: 8,
    neon_radius: 6,
  },
  block_style: {
    border: 1,
    border_blur: 0,
    gradient: 0.35,
    gradient_angle: 45,
    fill_blur: 0,
    alpha: 1,
    clearcoat: 0,
    clearcoat_size: 0.3,
    rim_light: 0,
    roughness: 0,
    metallic: 0,
    scanlines: 0,
    shadow: 0,
    shadow_angle: 135,
    corner_radius: 0,
    bevel: 0,
    specular_size: 0,
    specular_strength: 0,
    inner_shadow: 0,
    inner_shadow_strength: 0,
    outline_opacity: 1,
    gradient_contrast: 1,
    saturation_shift: 0,
    brightness_shift: 0,
    noise: 0,
    glow: 0,
    glow_opacity: 0.5,
    pixel_snap: 0,
    texture_id: "",
    texture_opacity: 0,
    texture_scale: 1,
    texture_angle: 0,
  },
  bindings: {
    move_left: ["arrowleft", "numpad4"],
    move_right: ["arrowright", "numpad6"],
    rotate_cw: ["arrowup", "numpad5", "x", "numpad1", "numpad9"],
    rotate_ccw: ["control", "numpad3", "z", "numpad7"],
    soft_drop: ["arrowdown", "numpad2"],
    hard_drop: [" ", "numpad8"],
    hold: ["shift", "numpad0", "c"],
    reset: ["r"],
    pause: ["escape", "f1"],
    settings: ["f10"],
  },
  colors: {
    color_i: "#55D6FF",
    color_j: "#5669FF",
    color_l: "#FFA74F",
    color_o: "#FFE757",
    color_s: "#7AEB84",
    color_t: "#BB80FF",
    color_z: "#FF7676",
    background_color: "#32343E",
  },
  ghost_piece: true,
  next_piece: true,
  hold_queue: true,
  show_controls: true,
  lock_down_mode: "extended",
  start_level: 1,
  level_progression: "fixed",
  queue_size: 6,
  grid_enabled: true,
  grid_color: "rgba(255,255,255,0.2)",
  anim_hard_drop_trail: true,
  anim_lock_flash: true,
  anim_line_clear: true,
  anim_score_toasts: true,
};

const CONTROL_ACTIONS = [
  { id: "move_left", label: "Move Left" },
  { id: "move_right", label: "Move Right" },
  { id: "rotate_cw", label: "Rotate CW" },
  { id: "rotate_ccw", label: "Rotate CCW" },
  { id: "soft_drop", label: "Soft Drop" },
  { id: "hard_drop", label: "Hard Drop" },
  { id: "hold", label: "Hold" },
  { id: "reset", label: "Reset" },
  { id: "pause", label: "Pause" },
  { id: "settings", label: "Settings" },
];
const CONTROL_ACTION_LABELS = Object.fromEntries(
  CONTROL_ACTIONS.map((action) => [action.id, action.label]),
);

const ALLOWED_KEYS = new Set([
  "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p",
  "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
  "arrowleft", "arrowright", "arrowup", "arrowdown",
  " ", "enter", "tab", "escape", "backspace", "delete", "insert",
  "home", "end", "pageup", "pagedown",
  "control", "shift",
  "numpad0", "numpad1", "numpad2", "numpad3", "numpad4",
  "numpad5", "numpad6", "numpad7", "numpad8", "numpad9",
  "numpadadd", "numpadsubtract", "numpadmultiply", "numpaddivide", "numpaddecimal", "numpadenter",
  "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12",
  "-", "=", "[", "]", "\\", ";", "'", ",", ".", "/", "`",
]);

const SHAPES = {
  I: [
    [[0, 1], [1, 1], [2, 1], [3, 1]],
    [[2, 0], [2, 1], [2, 2], [2, 3]],
    [[0, 2], [1, 2], [2, 2], [3, 2]],
    [[1, 0], [1, 1], [1, 2], [1, 3]],
  ],
  J: [
    [[0, 0], [0, 1], [1, 1], [2, 1]],
    [[1, 0], [2, 0], [1, 1], [1, 2]],
    [[0, 1], [1, 1], [2, 1], [2, 2]],
    [[1, 0], [1, 1], [0, 2], [1, 2]],
  ],
  L: [
    [[2, 0], [0, 1], [1, 1], [2, 1]],
    [[1, 0], [1, 1], [1, 2], [2, 2]],
    [[0, 1], [1, 1], [2, 1], [0, 2]],
    [[0, 0], [1, 0], [1, 1], [1, 2]],
  ],
  O: [
    [[1, 0], [2, 0], [1, 1], [2, 1]],
    [[1, 0], [2, 0], [1, 1], [2, 1]],
    [[1, 0], [2, 0], [1, 1], [2, 1]],
    [[1, 0], [2, 0], [1, 1], [2, 1]],
  ],
  S: [
    [[1, 0], [2, 0], [0, 1], [1, 1]],
    [[1, 0], [1, 1], [2, 1], [2, 2]],
    [[1, 1], [2, 1], [0, 2], [1, 2]],
    [[0, 0], [0, 1], [1, 1], [1, 2]],
  ],
  T: [
    [[1, 0], [0, 1], [1, 1], [2, 1]],
    [[1, 0], [1, 1], [2, 1], [1, 2]],
    [[0, 1], [1, 1], [2, 1], [1, 2]],
    [[1, 0], [0, 1], [1, 1], [1, 2]],
  ],
  Z: [
    [[0, 0], [1, 0], [1, 1], [2, 1]],
    [[2, 0], [1, 1], [2, 1], [1, 2]],
    [[0, 1], [1, 1], [1, 2], [2, 2]],
    [[1, 0], [0, 1], [1, 1], [0, 2]],
  ],
};

function createRng(seed, stateOverride = null) {
  let state = stateOverride != null ? stateOverride : seed % 2147483647;
  if (state <= 0) state += 2147483646;
  return {
    next: () => {
      state = (state * 16807) % 2147483647;
      return (state - 1) / 2147483646;
    },
    getState: () => state,
    setState: (value) => {
      state = value;
    },
  };
}

const PIXELATED_TEXTURE_SAMPLE_RATIO = 0.25;
const PIXELATED_TEXTURE_ROTATIONS = [0, 90, 180, 270];
const TEXTURE_SAMPLE_PX = 200;
const RANDOM_TEXTURE_IDS = new Set(["pixelated", "wooden", "concrete", "brushed_metal", "toxic_slime"]);

function createPixelatedTransform() {
  const size = PIXELATED_TEXTURE_SAMPLE_RATIO;
  const max = Math.max(0, 1 - size);
  return {
    u: Math.random() * max,
    v: Math.random() * max,
    size,
    rotation: PIXELATED_TEXTURE_ROTATIONS[Math.floor(Math.random() * PIXELATED_TEXTURE_ROTATIONS.length)],
    flipX: Math.random() < 0.5,
    flipY: Math.random() < 0.5,
  };
}

function ensurePieceTextureTransforms(piece) {
  if (!piece || !piece.shape) return [];
  const expected = SHAPES[piece.shape]?.[0]?.length ?? 0;
  if (!Array.isArray(piece.textureTransforms) || piece.textureTransforms.length !== expected) {
    piece.textureTransforms = Array.from({ length: expected }, () => createPixelatedTransform());
  }
  return piece.textureTransforms;
}

function getPreviewTextureTransforms(state, shape, key) {
  if (!state || !shape || !SHAPES[shape]) return [];
  if (!state.previewTextureCache) state.previewTextureCache = {};
  const expected = SHAPES[shape]?.[0]?.length ?? 0;
  const entry = state.previewTextureCache[key];
  if (!entry || entry.shape !== shape || entry.transforms.length !== expected) {
    const transforms = Array.from({ length: expected }, () => createPixelatedTransform());
    state.previewTextureCache[key] = { shape, transforms };
  }
  return state.previewTextureCache[key].transforms;
}

function getUiPreviewTextureTransforms(ui, shape) {
  if (!ui || !shape || !SHAPES[shape]) return [];
  if (!ui.blockStylePreviewTextureCache) ui.blockStylePreviewTextureCache = {};
  const expected = SHAPES[shape]?.[0]?.length ?? 0;
  const entry = ui.blockStylePreviewTextureCache[shape];
  if (!entry || entry.transforms.length !== expected) {
    ui.blockStylePreviewTextureCache[shape] = {
      transforms: Array.from({ length: expected }, () => createPixelatedTransform()),
    };
  }
  return ui.blockStylePreviewTextureCache[shape].transforms;
}

function shuffledBag(rng) {
  const bag = Object.keys(SHAPES);
  for (let i = bag.length - 1; i > 0; i -= 1) {
    const j = Math.floor(rng.next() * (i + 1));
    const tmp = bag[i];
    bag[i] = bag[j];
    bag[j] = tmp;
  }
  return bag;
}

function newPiece(shape) {
  return { shape, rot: 0, x: 3, y: SPAWN_Y };
}

function pieceBottomY(piece) {
  return Math.max(...pieceCells(piece).map(([, y]) => y));
}

function emptyBoard() {
  const board = [];
  for (let y = 0; y < GRID_H_TOTAL; y += 1) {
    const row = new Array(GRID_W).fill(0);
    board.push(row);
  }
  return board;
}

function emptyTextureBoard() {
  const board = [];
  for (let y = 0; y < GRID_H_TOTAL; y += 1) {
    const row = new Array(GRID_W).fill(null);
    board.push(row);
  }
  return board;
}

function pieceCells(piece) {
  const shape = SHAPES[piece.shape][piece.rot % 4];
  return shape.map(([dx, dy]) => [piece.x + dx, piece.y + dy]);
}

function collides(board, piece) {
  for (const [x, y] of pieceCells(piece)) {
    if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H_TOTAL) return true;
    if (board[y][x]) return true;
  }
  return false;
}

function lockPiece(board, piece, textureBoard = null, textureTransforms = null) {
  const cells = pieceCells(piece);
  cells.forEach(([x, y], index) => {
    if (y >= 0 && y < GRID_H_TOTAL && x >= 0 && x < GRID_W) {
      board[y][x] = piece.shape;
      if (textureBoard) {
        textureBoard[y][x] = textureTransforms?.[index] ?? createPixelatedTransform();
      }
    }
  });
}

function clearLines(board, textureBoard = null) {
  const remaining = [];
  const remainingTextures = textureBoard ? [] : null;
  for (let y = 0; y < GRID_H_TOTAL; y += 1) {
    if (board[y].some((cell) => cell === 0)) {
      remaining.push(board[y]);
      if (remainingTextures) remainingTextures.push(textureBoard[y]);
    }
  }
  const cleared = GRID_H_TOTAL - remaining.length;
  while (remaining.length < GRID_H_TOTAL) {
    remaining.unshift(new Array(GRID_W).fill(0));
    if (remainingTextures) remainingTextures.unshift(new Array(GRID_W).fill(null));
  }
  return { board: remaining, textures: remainingTextures, cleared };
}

function fullLineRows(board) {
  const rows = [];
  for (let y = 0; y < board.length; y += 1) {
    if (board[y].every((cell) => cell !== 0)) {
      rows.push(y);
    }
  }
  return rows;
}

function createState(seed, startLevel = 1, levelProgression = "fixed") {
  const rng = createRng(seed);
  const bag = shuffledBag(rng);
  const piece = newPiece(bag.shift());
  ensurePieceTextureTransforms(piece);
  const nextShape = bag.shift();
  const start = clampLevel(startLevel);
  const level = start;
  const progression = levelProgression === "variable" ? "variable" : "fixed";
  const baseDropMs = Math.max(1, Math.round(fallSpeedSeconds(level) * 1000));
  return {
    seed,
    rng,
    bag,
    bagCount: 0,
    piece,
    nextShape,
    holdShape: null,
    holdTextureTransforms: null,
    holdUsed: false,
    board: emptyBoard(),
    boardTextures: emptyTextureBoard(),
    previewTextureCache: {},
    score: 0,
    timeMs: 0,
    lines: 0,
    tetrises: 0,
    tspins: 0,
    comboStreak: 0,
    comboTotal: 0,
    startLevel: start,
    level,
    levelProgression: progression,
    goalLinesTotal: 0,
    goalRemaining: progression === "fixed" ? 10 : 5 * start,
    b2bActive: false,
    running: false,
    started: false,
    gameOver: false,
    baseDropMs,
    dropMs: baseDropMs,
    elapsed: 0,
    lockDelayMs: 500,
    lockElapsed: 0,
    locking: false,
    softDrop: false,
    lastAction: null,
    lastRotateKick: null,
    lastLockedPiece: null,
    lockFlash: null,
    lineClear: null,
    clearing: false,
    pendingClear: null,
    hardDropTrail: null,
    actionToast: null,
    b2bStreak: 0,
    rotateSinceLock: false,
    tspin: "none",
    lockMoves: 0,
    lowestY: pieceBottomY(piece),
    moveDir: null,
    moveHeldLeft: false,
    moveHeldRight: false,
    moveDasElapsed: 0,
    moveArrElapsed: 0,
    boardDirty: true,
    timer: null,
  };
}

function hydrateState(serialized, fallbackSeed, startLevel = 1) {
  if (!serialized || typeof serialized !== "string") return null;
  let data = null;
  try {
    data = JSON.parse(serialized);
  } catch {
    return null;
  }
  if (!data || typeof data !== "object") return null;
  const seed = Number.isInteger(data.seed) ? data.seed : fallbackSeed ?? 0;
  const progression = data.level_progression === "variable" ? "variable" : "fixed";
  const base = createState(seed, data.start_level || startLevel, progression);
  if (Array.isArray(data.board)) {
    base.board = data.board;
  }
  base.boardTextures = emptyTextureBoard();
  for (let y = 0; y < GRID_H_TOTAL; y += 1) {
    for (let x = 0; x < GRID_W; x += 1) {
      if (base.board[y]?.[x]) {
        base.boardTextures[y][x] = createPixelatedTransform();
      }
    }
  }
  if (Array.isArray(data.bag)) {
    base.bag = data.bag.slice();
  }
  base.previewTextureCache = {};
  if (Number.isInteger(data.bag_count)) base.bagCount = data.bag_count;
  if (data.piece && typeof data.piece === "object") {
    base.piece = {
      shape: data.piece.shape,
      rot: data.piece.rot,
      x: data.piece.x,
      y: data.piece.y,
    };
  }
  ensurePieceTextureTransforms(base.piece);
  if (data.next_piece_shape) base.nextShape = data.next_piece_shape;
  if (data.hold_piece_shape !== undefined) base.holdShape = data.hold_piece_shape;
  if (base.holdShape) {
    const count = SHAPES[base.holdShape]?.[0]?.length ?? 0;
    base.holdTextureTransforms = Array.from({ length: count }, () => createPixelatedTransform());
  } else {
    base.holdTextureTransforms = null;
  }
  if (typeof data.hold_used === "boolean") base.holdUsed = data.hold_used;
  if (Number.isInteger(data.score)) base.score = data.score;
  if (Number.isFinite(data.time_ms)) base.timeMs = data.time_ms;
  if (Number.isInteger(data.lines_cleared_total)) base.lines = data.lines_cleared_total;
  if (Number.isFinite(data.goal_lines_total)) base.goalLinesTotal = data.goal_lines_total;
  if (Number.isInteger(data.level)) base.level = data.level;
  if (Number.isInteger(data.start_level)) base.startLevel = data.start_level;
  base.levelProgression = progression;
  if (typeof data.b2b_active === "boolean") base.b2bActive = data.b2b_active;
  if (typeof data.game_over === "boolean") base.gameOver = data.game_over;
  if (data.tspin) base.tspin = data.tspin;
  if (Number.isInteger(data.tetrises)) base.tetrises = data.tetrises;
  if (Number.isInteger(data.tspins)) base.tspins = data.tspins;
  if (Number.isInteger(data.combo_total)) base.comboTotal = data.combo_total;
  if (Number.isInteger(data.combo_streak)) base.comboStreak = data.combo_streak;
  updateLevel(base);
  base.running = false;
  base.started = false;
  return base;
}

function fallSpeedSeconds(level) {
  const lvl = Math.max(1, Math.min(15, Math.floor(level || 1)));
  const base = 0.8 - (lvl - 1) * 0.007;
  return Math.pow(base, lvl - 1);
}

function clampLevel(value) {
  const parsed = Number.parseInt(`${value}`, 10);
  if (!Number.isFinite(parsed)) return 1;
  return Math.max(1, Math.min(15, parsed));
}

function updateLevel(state) {
  let target = state.startLevel;
  const progression = state.levelProgression === "variable" ? "variable" : "fixed";
  if (progression === "fixed") {
    state.goalLinesTotal = state.lines;
    target = clampLevel(state.startLevel + Math.floor(state.lines / 10));
  } else {
    let remaining = state.goalLinesTotal;
    let lvl = state.startLevel;
    while (lvl < 15) {
      const goal = 5 * lvl;
      if (remaining < goal) break;
      remaining -= goal;
      lvl += 1;
    }
    target = clampLevel(lvl);
  }
  if (state.level !== target) {
    state.level = target;
  }
  if (progression === "fixed") {
    if (state.level >= 15) {
      state.goalRemaining = 0;
    } else {
      const linesIntoLevel = state.lines - (state.level - state.startLevel) * 10;
      state.goalRemaining = Math.max(0, 10 - linesIntoLevel);
    }
  } else {
    let remaining = state.goalLinesTotal;
    let lvl = state.startLevel;
    while (lvl < 15 && remaining >= 5 * lvl) {
      remaining -= 5 * lvl;
      lvl += 1;
    }
    state.goalRemaining = lvl >= 15 ? 0 : Math.max(0, 5 * lvl - remaining);
  }
  state.baseDropMs = Math.max(1, Math.round(fallSpeedSeconds(state.level) * 1000));
  state.dropMs = state.softDrop
    ? Math.max(1, Math.floor(state.baseDropMs / 20))
    : state.baseDropMs;
}

function awardedGoalLines(lines, tspinType, b2bActive) {
  let base = 0;
  let qualifies = false;
  if (tspinType === "tspin") {
    if (lines === 0) base = 4;
    else if (lines === 1) {
      base = 8;
      qualifies = true;
    } else if (lines === 2) {
      base = 12;
      qualifies = true;
    } else if (lines === 3) {
      base = 16;
      qualifies = true;
    }
  } else if (tspinType === "mini") {
    if (lines === 0) base = 1;
    else {
      base = 2;
      qualifies = true;
    }
  } else {
    if (lines === 1) base = 1;
    else if (lines === 2) base = 3;
    else if (lines === 3) base = 5;
    else if (lines === 4) {
      base = 8;
      qualifies = true;
    }
  }
  if (qualifies && b2bActive && base > 0) {
    base += base * 0.5;
  }
  return base;
}

function scoreForClear(level, lines, tspinType, b2bActive) {
  let base = 0;
  let qualifies = false;
  if (tspinType === "tspin") {
    if (lines === 0) {
      base = 400 * level;
    } else if (lines === 1) {
      base = 800 * level;
      qualifies = true;
    } else if (lines === 2) {
      base = 1200 * level;
      qualifies = true;
    } else if (lines === 3) {
      base = 1600 * level;
      qualifies = true;
    }
  } else if (tspinType === "mini") {
    if (lines === 0) {
      base = 100 * level;
    } else {
      base = 200 * level;
      qualifies = true;
    }
  } else {
    if (lines === 1) {
      base = 100 * level;
    } else if (lines === 2) {
      base = 300 * level;
    } else if (lines === 3) {
      base = 500 * level;
    } else if (lines === 4) {
      base = 800 * level;
      qualifies = true;
    }
  }

  let bonus = 0;
  let nextB2b = b2bActive;
  if (qualifies) {
    if (b2bActive) {
      bonus = Math.floor(base * 0.5);
    }
    nextB2b = true;
  } else if (lines >= 1 && lines <= 3) {
    nextB2b = false;
  }

  return { points: base + bonus, b2bActive: nextB2b };
}

function actionToastText(scoredPoints, colorKey) {
  if (!scoredPoints || scoredPoints <= 0) return null;
  return { text: `+${scoredPoints}`, colorKey };
}

function toastScaleForChain(comboStreak, b2bStreak) {
  const chain = Math.max(comboStreak || 0, b2bStreak || 0);
  return Math.min(1.6, 1 + 0.2 * Math.max(0, chain - 1));
}

function setActionToast(state, info, anchor, scale = 1, duration = 1200) {
  if (state.options?.anim_score_toasts === false) return;
  if (!info || !info.text) return;
  const now = typeof performance !== "undefined" ? performance.now() : Date.now();
  state.actionToast = {
    text: info.text,
    colorKey: info.colorKey,
    anchorX: anchor?.x ?? null,
    anchorY: anchor?.y ?? null,
    scale,
    until: now + duration,
    start: now,
    duration,
  };
}

function ensureBag(state) {
  if (state.bag.length === 0) {
    state.bag = shuffledBag(state.rng);
    state.bagCount += 1;
  }
}

function getUpcomingShapes(state, count) {
  if (count <= 0) return [];
  const upcoming = [state.nextShape, ...state.bag];
  if (upcoming.length >= count) return upcoming.slice(0, count);
  const rngClone = createRng(state.seed, state.rng.getState());
  while (upcoming.length < count) {
    const bag = shuffledBag(rngClone);
    for (const shape of bag) {
      upcoming.push(shape);
      if (upcoming.length >= count) break;
    }
  }
  return upcoming.slice(0, count);
}

function spawnNext(state) {
  state.piece = newPiece(state.nextShape);
  ensurePieceTextureTransforms(state.piece);
  ensureBag(state);
  state.nextShape = state.bag.shift();
  state.holdUsed = false;
  state.lockMoves = 0;
  state.lowestY = pieceBottomY(state.piece);
  state.locking = false;
  state.lockElapsed = 0;
  state.rotateSinceLock = false;
  updateLevel(state);
  if (collides(state.board, state.piece)) {
    state.gameOver = true;
    state.running = false;
  }
}

function updateLowestY(state) {
  const bottom = pieceBottomY(state.piece);
  if (state.lowestY == null || bottom > state.lowestY) {
    state.lowestY = bottom;
    state.lockMoves = 0;
    if (state.locking) {
      state.lockElapsed = 0;
    }
    return true;
  }
  return false;
}

function stepDown(state) {
  const moved = { ...state.piece, y: state.piece.y + 1 };
  if (!collides(state.board, moved)) {
    state.piece = moved;
    state.locking = false;
    state.lockElapsed = 0;
    updateLowestY(state);
    if (state.softDrop) {
      state.lastAction = "move";
      state.lastRotateKick = null;
      state.rotateSinceLock = false;
    }
    if (state.softDrop) {
      state.score += 1;
    }
    return;
  }
  if (!state.locking) {
    state.locking = true;
    state.lockElapsed = 0;
  }
}

function cornerOccupied(board, x, y) {
  if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H_TOTAL) return true;
  return board[y][x] !== 0;
}

function tspinType(state) {
  const piece = state.piece;
  if (piece.shape !== "T" || state.lastAction !== "rotate") return "none";
  const type = tspinTypeForPiece(state.board, piece);
  if (type === "none") return "none";
  if (state.lastRotateKick === 4) return "tspin";
  return type;
}

function tspinTypeForPiece(board, piece) {
  const cx = piece.x + 1;
  const cy = piece.y + 1;
  const corners = {
    A: [cx - 1, cy - 1],
    B: [cx + 1, cy - 1],
    C: [cx - 1, cy + 1],
    D: [cx + 1, cy + 1],
  };
  const rot = piece.rot % 4;
  let front = ["A", "B"];
  let back = ["C", "D"];
  if (rot === 1) {
    front = ["B", "D"];
    back = ["A", "C"];
  } else if (rot === 2) {
    front = ["C", "D"];
    back = ["A", "B"];
  } else if (rot === 3) {
    front = ["A", "C"];
    back = ["B", "D"];
  }
  const frontHits = front.reduce((acc, k) => acc + (cornerOccupied(board, ...corners[k]) ? 1 : 0), 0);
  const backHits = back.reduce((acc, k) => acc + (cornerOccupied(board, ...corners[k]) ? 1 : 0), 0);
  if (frontHits + backHits < 3) return "none";
  if (frontHits === 2 && backHits === 2) return "tspin";
  if (frontHits === 2 && backHits >= 1) return "tspin";
  if (backHits === 2 && frontHits >= 1) return "mini";
  return "none";
}

function settlePiece(state) {
  const now = typeof performance !== "undefined" ? performance.now() : 0;
  const flashCells = new Set(pieceCells(state.piece).map(([x, y]) => `${x},${y}`));
  if (state.options?.anim_lock_flash !== false) {
    state.lockFlash = { until: now + 220, duration: 220, elapsed: 0, start: now, cells: flashCells };
  } else {
    state.lockFlash = null;
  }
  state.lastLockedPiece = {
    shape: state.piece.shape,
    x: state.piece.x,
    y: state.piece.y,
    rot: state.piece.rot,
  };
  lockPiece(state.board, state.piece, state.boardTextures, ensurePieceTextureTransforms(state.piece));
  state.tspin = tspinType(state);
  const fullRows = fullLineRows(state.board);
  const levelBefore = state.level;
  const prevB2b = state.b2bActive;
  const center = pieceCells(state.piece).reduce(
    (acc, [x, y]) => {
      acc.x += x + 0.5;
      acc.y += y + 0.5;
      return acc;
    },
    { x: 0, y: 0 },
  );
  const cellCount = Math.max(1, pieceCells(state.piece).length);
  const anchorX = center.x / cellCount;
  const anchorY = center.y / cellCount;
  if (fullRows.length) {
    const result = clearLines(state.board, state.boardTextures);
    const scored = scoreForClear(levelBefore, result.cleared, state.tspin, state.b2bActive);
    const qualifies = scored.b2bActive;
    const nextCombo = (state.comboStreak || 0) + 1;
    const nextB2bStreak = qualifies ? ((prevB2b ? (state.b2bStreak || 0) + 1 : 1)) : 0;
    const pendingClear = {
      result,
      cleared: result.cleared,
      tspin: state.tspin,
      rows: fullRows,
      levelBefore,
      prevB2b,
      scored,
    };
    if (state.options?.anim_line_clear === false) {
      applyPendingClear(state, pendingClear);
      state.locking = false;
      state.lockElapsed = 0;
      state.boardDirty = true;
      return;
    }
    state.pendingClear = pendingClear;
    state.clearing = true;
    state.lineClear = {
      rows: fullRows,
      elapsed: 0,
      flashMs: 80,
      wipeMs: 180 + fullRows.length * 40,
      duration: 80 + 180 + fullRows.length * 40,
    };
    const topRow = Math.min(...fullRows);
    setActionToast(
      state,
      actionToastText(scored.points, state.lastLockedPiece?.shape),
      { x: anchorX, y: Math.max(HIDDEN_ROWS, topRow - 1) },
      toastScaleForChain(nextCombo, nextB2bStreak),
    );
    state.locking = false;
    state.lockElapsed = 0;
    state.boardDirty = true;
    return;
  }
  const result = { cleared: 0 };
  const hadTspin = state.tspin !== "none";
  state.comboStreak = 0;
  if (hadTspin) {
    state.tspins = (state.tspins || 0) + 1;
  }
  const scored = scoreForClear(levelBefore, result.cleared, state.tspin, state.b2bActive);
  state.score += scored.points;
  state.b2bActive = scored.b2bActive;
  const qualifies = scored.b2bActive;
  state.b2bStreak = qualifies ? ((state.b2bStreak || 0) + (prevB2b ? 1 : 1)) : 0;
  setActionToast(
    state,
    actionToastText(scored.points, state.lastLockedPiece?.shape),
    { x: anchorX, y: anchorY - 1 },
    toastScaleForChain(state.comboStreak || 0, state.b2bStreak || 0),
  );
  if (state.levelProgression === "variable") {
    state.goalLinesTotal += awardedGoalLines(result.cleared, state.tspin, prevB2b);
  }
  updateLevel(state);
  state.locking = false;
  state.lockElapsed = 0;
  state.boardDirty = true;
  spawnNext(state);
}

function applyPendingClear(state, pending) {
  if (!pending) return;
  state.board = pending.result.board;
  if (pending.result.textures) {
    state.boardTextures = pending.result.textures;
  }
  const hadTspin = pending.tspin !== "none";
  if (pending.cleared > 0) {
    state.lines += pending.cleared;
    state.comboStreak = (state.comboStreak || 0) + 1;
    if (state.comboStreak === 2) {
      state.comboTotal = (state.comboTotal || 0) + 1;
    }
    if (pending.cleared === 4) {
      state.tetrises = (state.tetrises || 0) + 1;
    }
    if (hadTspin) {
      state.tspins = (state.tspins || 0) + 1;
    }
  } else {
    state.comboStreak = 0;
    if (hadTspin) {
      state.tspins = (state.tspins || 0) + 1;
    }
  }
  const scored = pending.scored || scoreForClear(pending.levelBefore, pending.cleared, pending.tspin, state.b2bActive);
  state.score += scored.points;
  state.b2bActive = scored.b2bActive;
  const qualifies = scored.b2bActive;
  state.b2bStreak = qualifies
    ? (pending.prevB2b ? (state.b2bStreak || 0) + 1 : 1)
    : 0;
  if (state.levelProgression === "variable") {
    state.goalLinesTotal += awardedGoalLines(pending.cleared, pending.tspin, pending.prevB2b);
  }
  updateLevel(state);
  spawnNext(state);
}

function serializeState(state) {
  return JSON.stringify({
    version: 1,
    board: state.board,
    bag: state.bag.slice(),
    bag_count: state.bagCount,
    seed: state.seed,
    start_level: state.startLevel,
    level: state.level,
    level_progression: state.levelProgression,
    b2b_active: state.b2bActive,
    goal_lines_total: state.goalLinesTotal,
    piece: { ...state.piece },
    next_piece_shape: state.nextShape,
    hold_piece_shape: state.holdShape,
    hold_used: state.holdUsed,
    score: state.score,
    time_ms: state.timeMs,
    lines_cleared_total: state.lines,
    tetrises: state.tetrises,
    tspins: state.tspins,
    combo_streak: state.comboStreak,
    combo_total: state.comboTotal,
    game_over: state.gameOver,
    tspin: state.tspin,
    options: state.options || {},
  });
}

function updateBackendState(node) {
  if (!node?.widgets) return;
  const stateWidget = node.widgets.find((w) => w.name === "state");
  const actionWidget = node.widgets.find((w) => w.name === "action");
  const stateIndex = node.widgets.indexOf(stateWidget);
  const actionIndex = node.widgets.indexOf(actionWidget);
  if (!node.widgets_values) {
    node.widgets_values = [];
  }
  if (stateWidget) {
    const options = getOptionsForState(node);
    const capture = captureMatrixImage(node);
    if (capture) {
      options.matrix_capture = capture;
    }
    node.__tetrisLive.state.options = options;
    const stateValue = serializeState(node.__tetrisLive.state);
    stateWidget.value = stateValue;
    if (stateIndex >= 0) node.widgets_values[stateIndex] = stateValue;
  }
  if (actionWidget) {
    actionWidget.value = "sync";
    if (actionIndex >= 0) node.widgets_values[actionIndex] = "sync";
  }
  if (node.widgets?.length) {
    node.widgets_values = node.widgets.map((w) => w.value);
  }
}

function move(state, dx, dy, opts = {}) {
  const moved = { ...state.piece, x: state.piece.x + dx, y: state.piece.y + dy };
  if (!collides(state.board, moved)) {
    state.piece = moved;
    if (!opts.skipLastAction) {
      state.lastAction = "move";
      state.lastRotateKick = null;
      state.rotateSinceLock = false;
    }
    updateLowestY(state);
    return true;
  }
  return false;
}

function rotate(state, delta) {
  const rotated = rotateWithKick(state.board, state.piece, delta);
  if (rotated) {
    state.piece = rotated.piece;
    state.lastAction = "rotate";
    state.lastRotateKick = rotated.kick;
    state.rotateSinceLock = true;
    updateLowestY(state);
    return true;
  }
  return false;
}

function kickTable(shape, fromRot, toRot) {
  if (shape === "O") return [[0, 0]];
  if (shape === "I") {
    const table = {
      "0>1": [[0, 0], [-2, 0], [1, 0], [-2, 1], [1, -2]],
      "1>0": [[0, 0], [2, 0], [-1, 0], [2, -1], [-1, 2]],
      "1>2": [[0, 0], [-1, 0], [2, 0], [-1, -2], [2, 1]],
      "2>1": [[0, 0], [1, 0], [-2, 0], [1, 2], [-2, -1]],
      "2>3": [[0, 0], [2, 0], [-1, 0], [2, -1], [-1, 2]],
      "3>2": [[0, 0], [-2, 0], [1, 0], [-2, 1], [1, -2]],
      "3>0": [[0, 0], [1, 0], [-2, 0], [1, 2], [-2, -1]],
      "0>3": [[0, 0], [-1, 0], [2, 0], [-1, -2], [2, 1]],
    };
    return table[`${fromRot}>${toRot}`] || [[0, 0]];
  }
  const table = {
    "0>1": [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
    "1>0": [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
    "1>2": [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
    "2>1": [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
    "2>3": [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],
    "3>2": [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
    "3>0": [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
    "0>3": [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],
  };
  return table[`${fromRot}>${toRot}`] || [[0, 0]];
}

function rotateWithKick(board, piece, delta) {
  const fromRot = piece.rot % 4;
  const toRot = (fromRot + delta + 4) % 4;
  const kicks = kickTable(piece.shape, fromRot, toRot);
  const debug = typeof window !== "undefined" && window.__tspinDebug?.enabled && piece.shape === "T";
  for (let i = 0; i < kicks.length; i += 1) {
    const [dx, dy] = kicks[i];
    const candidate = { ...piece, rot: toRot, x: piece.x + dx, y: piece.y + dy };
    const blocked = collides(board, candidate);
    if (debug) {
      console.log(
        `[tspin-debug] kick=${i} delta=${delta} from=(${piece.x},${piece.y},${fromRot}) to=(${candidate.x},${candidate.y},${toRot}) blocked=${blocked}`
      );
      if (i === 4) {
        const cells = SHAPES[piece.shape]?.[toRot] || [];
        const occupied = cells.map(([cx, cy]) => {
          const x = candidate.x + cx;
          const y = candidate.y + cy;
          let status = "empty";
          if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H_TOTAL) {
            status = "oob";
          } else if (board[y]?.[x]) {
            status = "blocked";
          }
          return { x, y, status };
        });
        console.log(`[tspin-debug] kick=4 cells=${JSON.stringify(occupied)}`);
      }
    }
    if (!blocked) {
      return { piece: candidate, kick: i };
    }
  }
  return null;
}

function hardDrop(state) {
  const startY = state.piece.y;
  let moved = 0;
  while (move(state, 0, 1, { skipLastAction: true })) {
    moved += 1;
    // keep dropping
  }
  if (moved > 0) {
    state.score += moved * 2;
    if (state.options?.anim_hard_drop_trail !== false) {
      const now = typeof performance !== "undefined" ? performance.now() : Date.now();
      state.hardDropTrail = {
        shape: state.piece.shape,
        rot: state.piece.rot,
        x: state.piece.x,
        startY,
        endY: state.piece.y,
        start: now,
        duration: 200,
      };
    } else {
      state.hardDropTrail = null;
    }
  }
  settlePiece(state);
}

function holdPiece(state) {
  if (state.holdUsed || state.gameOver) return false;
  const currentShape = state.piece.shape;
  const currentTextures = ensurePieceTextureTransforms(state.piece);
  if (state.holdShape) {
    const swapShape = state.holdShape;
    const swapTextures = state.holdTextureTransforms;
    state.holdShape = currentShape;
    state.holdTextureTransforms = currentTextures;
    state.piece = newPiece(swapShape);
    state.piece.textureTransforms = swapTextures ?? ensurePieceTextureTransforms(state.piece);
  } else {
    state.holdShape = currentShape;
    state.holdTextureTransforms = currentTextures;
    ensureBag(state);
    state.piece = newPiece(state.nextShape);
    ensurePieceTextureTransforms(state.piece);
    state.nextShape = state.bag.shift();
  }
  state.holdUsed = true;
  state.lockMoves = 0;
  state.lowestY = pieceBottomY(state.piece);
  state.locking = false;
  state.lockElapsed = 0;
  state.lastAction = "hold";
  state.lastRotateKick = null;
  state.tspin = "none";
  updateLevel(state);
  if (collides(state.board, state.piece)) {
    state.gameOver = true;
    state.running = false;
  }
  return true;
}

function getLayout(node) {
  const pauseBottom = null;
  const minTop = HEADER_H + PADDING + TOOLBAR_H + CONTROL_GAP;
  const widgetsBottom = getWidgetsBottom(node);
  const widgetTop =
    widgetsBottom != null ? widgetsBottom + CONTROL_WIDGET_PADDING : minTop + CONTROL_MIN;
  const topY = Math.max(minTop, widgetTop);
  const bottomY = Math.max(topY, node.size[1] - PADDING);
  const innerH = Math.max(0, bottomY - topY);
  const innerW = Math.max(0, node.size[0] - PADDING * 2);

  const showHold = getHoldEnabled(node);
  const showNext = getNextPieceEnabled(node);
  const sideSlots = 2;

  let sideW = 120;
  let blockSize = BLOCK;
  const effectiveRows = GRID_H_VISIBLE + EXTRA_VISIBLE_ROWS;
  for (let i = 0; i < 2; i += 1) {
    const boardW = Math.max(0, innerW - sideW * sideSlots - PADDING * sideSlots);
    blockSize = Math.floor(Math.min(boardW / GRID_W, innerH / effectiveRows));
    blockSize = Math.max(6, blockSize);
    sideW = Math.max(PREVIEW_GRID * blockSize + PADDING * 2, 120);
  }

  const boardW = blockSize * GRID_W;
  const extraPx = Math.round(blockSize * EXTRA_VISIBLE_ROWS);
  const boardH = blockSize * GRID_H_VISIBLE + extraPx;
  const boardX = Math.max(PADDING, Math.round((node.size[0] - boardW) / 2));
  const boardY = Math.round(topY);
  const sideY = boardY;

  node.__tetrisLastLayout = {
    boardY,
    pauseBottom,
  };

  return {
    boardX,
    boardY,
    boardW,
    boardH,
    sideY,
    blockSize,
    extraPx,
    showHold,
    showNext,
  };
}

function getWidgetsBottom(node) {
  if (!node?.widgets?.length) return null;
  const controlWidget = node.widgets.find((widget) => widget?.name === "control_after_generate");
  if (controlWidget && node.__tetrisWidgetBottom == null) {
    const index = node.widgets.indexOf(controlWidget);
    const startY =
      (Number.isFinite(node.widgets_start_y) && node.widgets_start_y) ||
      (Number.isFinite(LiteGraph?.NODE_TITLE_HEIGHT) ? LiteGraph.NODE_TITLE_HEIGHT : HEADER_H);
    const paddingTop = Number.isFinite(LiteGraph?.NODE_WIDGET_PADDING)
      ? LiteGraph.NODE_WIDGET_PADDING
      : 4;
    const rowHeight = Number.isFinite(LiteGraph?.NODE_WIDGET_HEIGHT)
      ? LiteGraph.NODE_WIDGET_HEIGHT
      : 20;
    const margin = Number.isFinite(LiteGraph?.NODE_WIDGET_MARGIN)
      ? LiteGraph.NODE_WIDGET_MARGIN
      : 4;
    return startY + paddingTop + (index + 1) * (rowHeight + margin);
  }
  if (Number.isFinite(node.__tetrisWidgetBottom)) {
    return node.__tetrisWidgetBottom;
  }
  const startY =
    (Number.isFinite(node.widgets_start_y) && node.widgets_start_y) ||
    (Number.isFinite(LiteGraph?.NODE_TITLE_HEIGHT) ? LiteGraph.NODE_TITLE_HEIGHT : HEADER_H);
  const paddingTop = Number.isFinite(LiteGraph?.NODE_WIDGET_PADDING)
    ? LiteGraph.NODE_WIDGET_PADDING
    : 4;
  const rowHeight = Number.isFinite(LiteGraph?.NODE_WIDGET_HEIGHT)
    ? LiteGraph.NODE_WIDGET_HEIGHT
    : 20;
  const margin = Number.isFinite(LiteGraph?.NODE_WIDGET_MARGIN)
    ? LiteGraph.NODE_WIDGET_MARGIN
    : 4;
  return startY + paddingTop + node.widgets.length * (rowHeight + margin);
}

function ensureWidgetDrawCapture(node) {
  if (!node?.widgets?.length) return;
  const width = node.size?.[0] || 0;
  const fallbackHeight = Number.isFinite(LiteGraph?.NODE_WIDGET_HEIGHT)
    ? LiteGraph.NODE_WIDGET_HEIGHT
    : 20;
  node.widgets.forEach((widget) => {
    if (!widget || widget.__tnDrawWrapped !== undefined) return;
    if (typeof widget.draw !== "function") {
      widget.__tnDrawWrapped = false;
      return;
    }
    const original = widget.draw;
    widget.__tnDrawWrapped = true;
    widget.__tnDrawOriginal = original;
    widget.draw = function () {
      const result = original.apply(this, arguments);
      const y = arguments[3];
      const heightArg = arguments[4];
      const size = typeof widget.computeSize === "function" ? widget.computeSize(width) : widget.size;
      const computed = Array.isArray(size) ? size[1] : widget.height;
      const rowHeight = Number.isFinite(heightArg)
        ? heightArg
        : Number.isFinite(computed)
          ? computed
          : fallbackHeight;
      if (Number.isFinite(y)) {
        const bottom = y + rowHeight;
        const current = node.__tetrisWidgetBottom;
        node.__tetrisWidgetBottom =
          current == null ? bottom : Math.max(current, bottom);
      }
      return result;
    };
  });
}

function getLockMode(node) {
  const defaultMode = "extended";
  const raw = `${getConfig(node).lock_down_mode || ""}`.trim().toLowerCase();
  if (["extended", "infinite", "classic"].includes(raw)) return raw;
  return defaultMode;
}

function applyLockModeAfterAction(state, mode) {
  const onSurface = collides(state.board, { ...state.piece, y: state.piece.y + 1 });
  if (!onSurface) {
    state.locking = false;
    state.lockElapsed = 0;
    return;
  }
  state.locking = true;
  if (mode === "classic") {
    return;
  }
  if (mode === "infinite") {
    state.lockElapsed = 0;
    return;
  }
  if (state.lockMoves < 15) {
    state.lockMoves += 1;
    state.lockElapsed = 0;
  } else {
    state.lockElapsed = state.lockDelayMs;
  }
}

function setMoveDirection(state, dir) {
  if (state.moveDir === dir) return;
  state.moveDir = dir;
  state.moveDasElapsed = 0;
  state.moveArrElapsed = 0;
}

function clearMoveDirection(state) {
  state.moveDir = null;
  state.moveDasElapsed = 0;
  state.moveArrElapsed = 0;
}

function updateAutoRepeat(state, node, deltaMs) {
  if (!state.moveDir) return;
  state.moveDasElapsed += deltaMs;
  if (state.moveDasElapsed < DAS_MS) return;
  state.moveArrElapsed += deltaMs;
  while (state.moveArrElapsed >= ARR_MS) {
    state.moveArrElapsed -= ARR_MS;
    const dx = state.moveDir === "left" ? -1 : 1;
    if (move(state, dx, 0)) {
      applyLockModeAfterAction(state, getLockMode(node));
    }
  }
}

function adjustColorByFactor(color, factor) {
  const parsed = parseColorComponents(color || "");
  const clamp = (value) => Math.min(255, Math.max(0, Math.round(value)));
  const mix = (channel) => {
    if (factor >= 0) {
      return clamp(channel + (255 - channel) * factor);
    }
    return clamp(channel * (1 + factor));
  };
  return rgbaString(
    {
      r: mix(parsed.r),
      g: mix(parsed.g),
      b: mix(parsed.b),
      a: parsed.a ?? 1,
    },
    true,
  );
}

function colorWithAlpha(color, alpha) {
  const parsed = parseColorComponents(color || "");
  if (!parsed) return color;
  return rgbaString({ r: parsed.r, g: parsed.g, b: parsed.b, a: alpha }, true);
}

function adjustColorHsl(color, saturationShift, brightnessShift) {
  const parsed = parseColorComponents(color || "");
  const hsl = rgbToHsl(parsed.r, parsed.g, parsed.b);
  const nextS = Math.min(100, Math.max(0, hsl.s + saturationShift * 100));
  const nextL = Math.min(100, Math.max(0, hsl.l + brightnessShift * 100));
  const rgb = hslToRgb(hsl.h, nextS, nextL);
  return rgbaString({ r: rgb.r, g: rgb.g, b: rgb.b, a: parsed.a ?? 1 }, true);
}

function mixColors(colorA, colorB, t) {
  const a = parseColorComponents(colorA || "");
  const b = parseColorComponents(colorB || "");
  const lerp = (v1, v2) => v1 + (v2 - v1) * t;
  return rgbaString(
    {
      r: Math.round(lerp(a.r, b.r)),
      g: Math.round(lerp(a.g, b.g)),
      b: Math.round(lerp(a.b, b.b)),
      a: (a.a ?? 1) + ((b.a ?? 1) - (a.a ?? 1)) * t,
    },
    true,
  );
}

function ensureBoardCache(node, state, layout, palette) {
  const live = node.__tetrisLive;
  if (!live || !state) return null;
  const { boardW, boardH, blockSize, extraPx } = layout;
  if (!live.boardCanvas) {
    live.boardCanvas = document.createElement("canvas");
    live.boardCtx = live.boardCanvas.getContext("2d");
    live.boardDirty = true;
  }
  const canvas = live.boardCanvas;
  const ctx = live.boardCtx;
  const style = getBlockStyle(node);
  const animConfig = getConfig(node);
  const clearPhase = state.clearing && state.lineClear
    ? {
      elapsed: state.lineClear.elapsed,
      duration: state.lineClear.duration,
      flashMs: state.lineClear.flashMs ?? 0,
      wipeMs: state.lineClear.wipeMs ?? 0,
    }
    : null;
  const cacheKey = JSON.stringify({
    boardW,
    boardH,
    blockSize,
    extraPx,
    palette,
    style,
    clearPhase,
  });
  if (canvas.width !== boardW || canvas.height !== boardH) {
    canvas.width = boardW;
    canvas.height = boardH;
    live.boardDirty = true;
  }
  const now = typeof performance !== "undefined" ? performance.now() : 0;
  const flashActive = state.lockFlash && now < state.lockFlash.until;
  const lockFlash = state.lockFlash;
  const lockProgress = lockFlash && lockFlash.duration
    ? Math.min(1, Math.max(0, (lockFlash.elapsed ?? 0) / lockFlash.duration))
    : 0;
  const dirty = live.boardDirty || state.boardDirty || flashActive;
  if (!dirty && live.boardCacheKey === cacheKey) {
    return canvas;
  }
  live.boardCacheKey = cacheKey;
  live.boardDirty = false;
  state.boardDirty = false;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (HIDDEN_ROWS > 0) {
    const hiddenRow = HIDDEN_ROWS - 1;
    for (let x = 0; x < GRID_W; x += 1) {
      const cell = state.board[hiddenRow][x];
      if (cell) {
        const textureTransform = state.boardTextures?.[hiddenRow]?.[x] ?? null;
        const flashKey = `${x},${hiddenRow}`;
        const flashColor = flashActive && state.lockFlash?.cells?.has(flashKey)
          ? adjustColorByFactor(palette[cell], 0.3)
          : palette[cell];
        drawBlockSized(
          ctx,
          x * blockSize,
          -blockSize + extraPx,
          blockSize,
          flashColor,
          node,
          textureTransform,
        );
      }
    }
  }
  const clearRows = animConfig.anim_line_clear !== false && state.clearing && state.lineClear?.rows?.length
    ? new Set(state.lineClear.rows)
    : null;
  const clearElapsed = state.lineClear?.elapsed ?? 0;
  const clearFlashMs = state.lineClear?.flashMs ?? 0;
  const clearWipeMs = state.lineClear?.wipeMs ?? 0;
  const clearProgress = clearWipeMs > 0
    ? Math.min(1, Math.max(0, (clearElapsed - clearFlashMs) / clearWipeMs))
    : 0;
  const clearCenter = GRID_W / 2;
  const clearMaxDist = clearCenter - 0.5;
  let beamMin = 0;
  let beamMax = GRID_W + GRID_H_TOTAL;
  if (flashActive && lockFlash?.cells?.size) {
    let min = Infinity;
    let max = -Infinity;
    for (const key of lockFlash.cells) {
      const [sx, sy] = key.split(",").map(Number);
      if (!Number.isFinite(sx) || !Number.isFinite(sy)) continue;
      const diag = sx + sy;
      min = Math.min(min, diag);
      max = Math.max(max, diag);
    }
    if (Number.isFinite(min) && Number.isFinite(max)) {
      beamMin = min;
      beamMax = max;
    }
  }
  const span = Math.max(1, beamMax - beamMin);
  const beamCenter = beamMin + span * lockProgress;
  const beamWidth = 0.65;

  if (clearRows && state.lineClear && getConfig(node).anim_line_clear !== false) {
    drawTetrisGlow(ctx, 0, extraPx, blockSize, state.lineClear.rows, clearElapsed, state.lineClear.duration);
  }

  for (let y = 0; y < GRID_H_VISIBLE; y += 1) {
    const boardYIndex = y + HIDDEN_ROWS;
    for (let x = 0; x < GRID_W; x += 1) {
      const cell = state.board[boardYIndex][x];
      if (cell) {
        if (clearRows && clearRows.has(boardYIndex)) {
          const dist = Math.abs((x + 0.5) - clearCenter);
          if (clearProgress >= (dist / clearMaxDist)) {
            continue;
          }
        }
        const textureTransform = state.boardTextures?.[boardYIndex]?.[x] ?? null;
        const flashKey = `${x},${boardYIndex}`;
        const flashColor = palette[cell];
        drawBlockSized(
          ctx,
          x * blockSize,
          y * blockSize + extraPx,
          blockSize,
          flashColor,
          node,
          textureTransform,
        );
      }
    }
  }
  if (flashActive && lockFlash?.cells?.size) {
    for (const key of lockFlash.cells) {
      const [sx, sy] = key.split(",").map(Number);
      if (!Number.isFinite(sx) || !Number.isFinite(sy)) continue;
      if (sy < HIDDEN_ROWS || sy >= HIDDEN_ROWS + GRID_H_VISIBLE) continue;
      const drawX = sx * blockSize;
      const drawY = (sy - HIDDEN_ROWS) * blockSize + extraPx;
      const diag = sx + sy;
      const distance = Math.abs(diag - beamCenter);
      if (distance > beamWidth) continue;
      const t = 1 - (distance / beamWidth);
      const alpha = Math.min(1, t * t);
      ctx.save();
      ctx.beginPath();
      ctx.rect(drawX, drawY, blockSize, blockSize);
      ctx.clip();
      const grad = ctx.createLinearGradient(drawX, drawY, drawX + blockSize, drawY + blockSize);
      grad.addColorStop(0, `rgba(255,255,255,${0.05 * alpha})`);
      grad.addColorStop(0.5, `rgba(255,255,255,${0.9 * alpha})`);
      grad.addColorStop(1, `rgba(255,255,255,${0.05 * alpha})`);
      ctx.fillStyle = grad;
      ctx.fillRect(drawX, drawY, blockSize, blockSize);
      ctx.restore();
    }
  }
  return canvas;
}

function captureMatrixImage(node) {
  const live = node.__tetrisLive;
  if (!live) return null;
  const { state } = live;
  if (!state) return null;
  const {
    boardW,
    boardH,
    blockSize,
    extraPx,
  } = getLayout(node);
  if (!live.captureCanvas) {
    live.captureCanvas = document.createElement("canvas");
    live.captureCtx = live.captureCanvas.getContext("2d");
  }
  const canvas = live.captureCanvas;
  const ctx = live.captureCtx;
  if (canvas.width !== boardW || canvas.height !== boardH) {
    canvas.width = boardW;
    canvas.height = boardH;
  }
  const palette = getColorPalette(node);
  const animConfig = getConfig(node);
  const gridEnabled = getGridEnabled(node);
  const gridColor = getGridColor(node);
  const bgSource = getBackgroundSource(node);
  const ghostEnabled = isGhostEnabled(node);
  const hideBoard = !state.gameOver && state.started && !state.running && !state.showBoardWhilePaused;
  const showPreviews = state.started && state.running && !hideBoard;
  const showBoardContents = (showPreviews || state.gameOver) && !hideBoard;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBoardBackground(ctx, bgSource, 0, 0, boardW, boardH, palette.X);
  if (gridEnabled && gridColor) {
    drawBoardGrid(ctx, 0, 0, boardW, boardH, blockSize, gridColor, extraPx);
  }
  if (hideBoard) {
    return canvas.toDataURL("image/png");
  }
  ctx.save();
  ctx.beginPath();
  ctx.rect(0, 0, boardW, boardH);
  ctx.clip();
  if (showBoardContents) {
    const cache = ensureBoardCache(node, state, { boardW, boardH, blockSize, extraPx }, palette);
    if (cache) {
      ctx.drawImage(cache, 0, 0);
    }
  }
  if (showBoardContents && !state.clearing && animConfig.anim_hard_drop_trail !== false) {
    drawHardDropTrail(ctx, state, 0, extraPx, blockSize, palette);
  }
  if (!state.gameOver && ghostEnabled && showPreviews && !state.clearing) {
    drawGhostPiece(ctx, state, 0, extraPx, blockSize, palette[state.piece.shape], COLORS.Text);
  }
  if (showBoardContents && !state.clearing) {
    const pieceTransforms = ensurePieceTextureTransforms(state.piece);
    pieceCells(state.piece).forEach(([x, y], index) => {
      if (y >= HIDDEN_ROWS - 1 && y < GRID_H_TOTAL) {
        drawBlockSized(
          ctx,
          x * blockSize,
          (y - HIDDEN_ROWS) * blockSize + extraPx,
          blockSize,
          palette[state.piece.shape],
          node,
          pieceTransforms[index] ?? null,
        );
      }
    });
  }
  if (showBoardContents && state.lineClear?.rows?.length && animConfig.anim_line_clear !== false) {
    const flashMs = state.lineClear.flashMs ?? 0;
    const elapsed = state.lineClear.elapsed ?? 0;
    const wipeMs = state.lineClear.wipeMs ?? 0;
    const wipeProgress = wipeMs > 0 ? Math.min(1, Math.max(0, (elapsed - flashMs) / wipeMs)) : 0;
    const clearCenter = GRID_W / 2;
    const clearMaxDist = clearCenter - 0.5;
    if (wipeProgress > 0) {
      const ghostAlpha = 0.5 * (1 - wipeProgress);
      if (ghostAlpha > 0.01) {
        ctx.save();
        state.lineClear.rows.forEach((row) => {
          if (row < HIDDEN_ROWS) return;
          const y = (row - HIDDEN_ROWS) * blockSize + extraPx;
          for (let x = 0; x < GRID_W; x += 1) {
            const cell = state.board[row]?.[x];
            if (!cell) continue;
            const dist = Math.abs((x + 0.5) - clearCenter);
            if (wipeProgress >= (dist / clearMaxDist)) {
              const color = palette[cell];
              ctx.fillStyle = colorWithAlpha(color, ghostAlpha);
              ctx.fillRect(x * blockSize, y, blockSize, blockSize);
            }
          }
        });
        ctx.restore();
      }
    }
    if (elapsed < flashMs) {
      const intensity = 0.35 * Math.max(0, 1 - (elapsed / flashMs));
      ctx.save();
      ctx.fillStyle = `rgba(255,255,255,${intensity})`;
      state.lineClear.rows.forEach((row) => {
        if (row < HIDDEN_ROWS) return;
        const y = (row - HIDDEN_ROWS) * blockSize + extraPx;
        ctx.fillRect(0, y, boardW, blockSize);
      });
      ctx.restore();
    }
    drawTetrisGlow(ctx, boardX, boardY + extraPx, blockSize, state.lineClear.rows, elapsed, state.lineClear.duration);
  }
  if (animConfig.anim_score_toasts !== false) {
    drawActionToast(
      ctx,
      state,
      { boardX: 0, boardY: 0, boardW, boardH, blockSize },
      getThemeColors(node),
      palette,
    );
  }
  ctx.restore();
  return canvas.toDataURL("image/png");
}

function getBlockStyle(node) {
  const config = getConfig(node);
  const style = config.block_style || DEFAULT_CONFIG.block_style;
  return {
    border: Math.max(0, Math.min(4, Number(style.border) || 0)),
    border_blur: Math.max(0, Math.min(6, Number(style.border_blur) || 0)),
    gradient: Math.max(0, Math.min(2, Number(style.gradient) || 0)),
    gradient_angle: Number.isFinite(Number(style.gradient_angle)) ? Number(style.gradient_angle) : 0,
    fill_blur: Math.max(0, Math.min(6, Number(style.fill_blur ?? style.blur) || 0)),
    alpha: Math.max(0, Math.min(1, Number(style.alpha ?? 1))),
    clearcoat: Math.max(0, Math.min(1, Number(style.clearcoat) || 0)),
    clearcoat_size: Math.max(0, Math.min(1, Number(style.clearcoat_size) || 0)),
    rim_light: Math.max(0, Math.min(1, Number(style.rim_light) || 0)),
    roughness: Math.max(0, Math.min(1, Number(style.roughness) || 0)),
    metallic: Math.max(0, Math.min(2, Number(style.metallic) || 0)),
    scanlines: Math.max(0, Math.min(1, Number(style.scanlines) || 0)),
    shadow: Math.max(0, Math.min(3, Number(style.shadow) || 0)),
    shadow_angle: Number.isFinite(Number(style.shadow_angle)) ? Number(style.shadow_angle) : 0,
    corner_radius: Math.max(0, Math.min(10, Number(style.corner_radius) || 0)),
    bevel: Math.max(0, Math.min(1, Number(style.bevel) || 0)),
    specular_size: Math.max(0, Math.min(1, Number(style.specular_size) || 0)),
    specular_strength: Math.max(0, Math.min(1, Number(style.specular_strength) || 0)),
    inner_shadow: Math.max(0, Math.min(8, Number(style.inner_shadow) || 0)),
    inner_shadow_strength: Math.max(0, Math.min(1, Number(style.inner_shadow_strength) || 0)),
    outline_opacity: Math.max(0, Math.min(1, Number(style.outline_opacity) || 0)),
    gradient_contrast: Math.max(0, Math.min(1, Number(style.gradient_contrast) || 0)),
    saturation_shift: Math.max(-1, Math.min(1, Number(style.saturation_shift) || 0)),
    brightness_shift: Math.max(-0.3, Math.min(0.3, Number(style.brightness_shift) || 0)),
    noise: Math.max(0, Math.min(1, Number(style.noise) || 0)),
    glow: Math.max(0, Math.min(10, Number(style.glow) || 0)),
    glow_opacity: Math.max(0, Math.min(1, Number(style.glow_opacity) || 0)),
    pixel_snap: Math.max(0, Math.min(1, Number(style.pixel_snap) || 0)),
    texture_id: typeof style.texture_id === "string" ? style.texture_id : "",
    texture_opacity: Math.max(0, Math.min(1, Number(style.texture_opacity) || 0)),
    texture_scale: Math.max(0.1, Math.min(4, Number(style.texture_scale) || 1)),
    texture_angle: Number.isFinite(Number(style.texture_angle)) ? Number(style.texture_angle) : 0,
  };
}

function getBlockStyleTexturePattern(ctx, textureId, node) {
  if (!textureId) return null;
  if (!BLOCK_STYLE_TEXTURES.has(textureId)) {
    const image = new Image();
    image.crossOrigin = "anonymous";
    if (textureId === "brushed_metal") {
      image.src = BRUSHED_METAL_TEXTURE_DATA;
    } else if (textureId === "wooden") {
      image.src = WOODEN_TEXTURE_DATA;
    } else if (textureId === "concrete") {
      image.src = CONCRETE_TEXTURE_DATA;
    } else if (textureId === "pixelated") {
      image.src = PIXELATED_TEXTURE_DATA;
    } else if (textureId === "toxic_slime") {
      image.src = TOXIC_SLIME_TEXTURE_DATA;
    }
    const entry = { image, ready: false, patterns: new WeakMap() };
    image.onload = () => {
      entry.ready = true;
      if (node?.__tetrisLive) {
        node.__tetrisLive.boardDirty = true;
        node.__tetrisLive.boardCacheKey = null;
      }
      if (node?.__tetrisUi?.blockStylePreviewDraw) {
        node.__tetrisUi.blockStylePreviewDraw();
      }
      if (window.app?.canvas?.setDirty) {
        window.app.canvas.setDirty(true);
      } else if (node?.setDirtyCanvas) {
        node.setDirtyCanvas(true, true);
      }
    };
    BLOCK_STYLE_TEXTURES.set(textureId, entry);
  }
  const entry = BLOCK_STYLE_TEXTURES.get(textureId);
  if (!entry || !entry.ready) return null;
  if (entry.patterns.has(ctx)) {
    return { pattern: entry.patterns.get(ctx), image: entry.image };
  }
  const pattern = ctx.createPattern(entry.image, "repeat");
  entry.patterns.set(ctx, pattern);
  return { pattern, image: entry.image };
}

function drawBlockSized(ctx, x, y, size, color, node, textureTransform = null) {
  const style = node ? getBlockStyle(node) : DEFAULT_CONFIG.block_style;
  const borderSize = style.border;
  const gradientStrength = style.gradient;
  const angle = ((style.gradient_angle % 360) + 360) % 360;
  const fillBlur = style.fill_blur;
  const alpha = style.alpha ?? 1;
  const clearcoat = style.clearcoat;
  const clearcoatSize = style.clearcoat_size;
  const rimLight = style.rim_light;
  const roughness = style.roughness;
  const metallic = style.metallic;
  const scanlines = style.scanlines;
  const shadowStrength = style.shadow;
  const shadowAngle = ((style.shadow_angle % 360) + 360) % 360;
  const cornerRadius = style.corner_radius;
  const bevel = style.bevel;
  const specularSize = style.specular_size;
  const specularStrength = style.specular_strength;
  const innerShadow = style.inner_shadow;
  const innerShadowStrength = style.inner_shadow_strength;
  const outlineOpacity = style.outline_opacity;
  const gradientContrast = style.gradient_contrast;
  const saturationShift = style.saturation_shift;
  const brightnessShift = style.brightness_shift;
  const noise = style.noise;
  const glow = style.glow;
  const glowOpacity = style.glow_opacity;
  const pixelSnap = style.pixel_snap;
  const textureId = style.texture_id;
  const textureOpacity = style.texture_opacity;
  const textureScale = style.texture_scale;
  const textureAngle = ((style.texture_angle % 360) + 360) % 360;
  const shrink = pixelSnap >= 0.5 ? 1 : 0;
  const innerSize = size - 1 - shrink;
  const drawX = x + shrink / 2;
  const drawY = y + shrink / 2;
  let baseColor = adjustColorHsl(color, saturationShift, brightnessShift);
  const metallicStrength = Math.min(1, metallic);
  const metallicBoost = Math.max(0, metallic - 1);
  const specularColor = mixColors(baseColor, "rgba(255,255,255,1)", 1 - metallicStrength);
  if (metallic > 0) {
    baseColor = adjustColorByFactor(baseColor, -0.2 * metallicStrength - 0.2 * metallicBoost);
  }
  const baseParsed = parseColorComponents(baseColor);
  baseColor = rgbaString(
    {
      r: baseParsed.r,
      g: baseParsed.g,
      b: baseParsed.b,
      a: (baseParsed.a ?? 1) * alpha,
    },
    true,
  );
  const borderBase = rgbaString(
    {
      r: baseParsed.r,
      g: baseParsed.g,
      b: baseParsed.b,
      a: 1,
    },
    true,
  );
  const darkerEdge = adjustColorByFactor(borderBase, -0.4);
  const effectiveSpecStrength = specularStrength * (1 - roughness);
  const effectiveSpecSize = Math.min(1, specularSize + roughness * 0.35);
  const effectiveGradient = gradientStrength * (1 - roughness * 0.35);
  ctx.save();
  if (glow > 0 && glowOpacity > 0) {
    const glowParsed = parseColorComponents(adjustColorByFactor(baseColor, 0.25));
    const glowAlpha = Math.min(1, Math.max(0, glowOpacity)) * (glowParsed.a ?? 1);
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.shadowColor = rgbaString(
      { r: glowParsed.r, g: glowParsed.g, b: glowParsed.b, a: glowAlpha },
      true,
    );
    ctx.shadowBlur = glow * 6;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.fillStyle = rgbaString(
      {
        r: glowParsed.r,
        g: glowParsed.g,
        b: glowParsed.b,
        a: Math.min(0.6, glowAlpha * 0.4),
      },
      true,
    );
    if (cornerRadius > 0 && typeof ctx.roundRect === "function") {
      ctx.beginPath();
      ctx.roundRect(drawX, drawY, innerSize, innerSize, Math.min(cornerRadius, innerSize / 2));
      ctx.fill();
    } else {
      ctx.fillRect(drawX, drawY, innerSize, innerSize);
    }
    ctx.restore();
  }
  if (shadowStrength > 0) {
    const rad = (shadowAngle * Math.PI) / 180;
    const offset = shadowStrength * 4;
    ctx.shadowColor = `rgba(0,0,0,${Math.min(0.6, 0.2 + shadowStrength * 0.6)})`;
    ctx.shadowBlur = shadowStrength * 8;
    ctx.shadowOffsetX = Math.cos(rad) * offset;
    ctx.shadowOffsetY = Math.sin(rad) * offset;
  } else {
    ctx.shadowColor = "transparent";
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
  }
  ctx.filter = fillBlur > 0 ? `blur(${fillBlur}px)` : "none";
  if (effectiveGradient > 0) {
    const rad = (angle * Math.PI) / 180;
    const half = innerSize / 2;
    const dx = Math.cos(rad) * half;
    const dy = Math.sin(rad) * half;
    const gradient = ctx.createLinearGradient(
      drawX + half - dx,
      drawY + half - dy,
      drawX + half + dx,
      drawY + half + dy,
    );
    const contrast = effectiveGradient * Math.max(0.2, gradientContrast);
    gradient.addColorStop(0, adjustColorByFactor(baseColor, contrast * 0.4));
    gradient.addColorStop(1, adjustColorByFactor(baseColor, -contrast * 0.4));
    ctx.fillStyle = gradient;
  } else {
    ctx.fillStyle = baseColor;
  }
  if (cornerRadius > 0 && typeof ctx.roundRect === "function") {
    ctx.beginPath();
    ctx.roundRect(drawX, drawY, innerSize, innerSize, Math.min(cornerRadius, innerSize / 2));
    ctx.fill();
  } else {
    ctx.fillRect(drawX, drawY, innerSize, innerSize);
  }
  if (bevel > 0) {
    const bevelGrad = ctx.createLinearGradient(drawX, drawY, drawX + innerSize, drawY + innerSize);
    bevelGrad.addColorStop(0, `rgba(255,255,255,${bevel * 0.35})`);
    bevelGrad.addColorStop(1, `rgba(0,0,0,${bevel * 0.3})`);
    ctx.fillStyle = bevelGrad;
    if (cornerRadius > 0 && typeof ctx.roundRect === "function") {
      ctx.beginPath();
      ctx.roundRect(drawX, drawY, innerSize, innerSize, Math.min(cornerRadius, innerSize / 2));
      ctx.fill();
    } else {
      ctx.fillRect(drawX, drawY, innerSize, innerSize);
    }
  }
  if (effectiveSpecStrength > 0 && effectiveSpecSize > 0) {
    const radius = Math.max(4, innerSize * effectiveSpecSize);
    const grad = ctx.createRadialGradient(drawX + radius * 0.6, drawY + radius * 0.6, 0, drawX + radius * 0.6, drawY + radius * 0.6, radius);
    const spec = parseColorComponents(specularColor);
    grad.addColorStop(0, `rgba(${spec.r},${spec.g},${spec.b},${effectiveSpecStrength * 0.6})`);
    grad.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = grad;
    if (cornerRadius > 0 && typeof ctx.roundRect === "function") {
      ctx.beginPath();
      ctx.roundRect(drawX, drawY, innerSize, innerSize, Math.min(cornerRadius, innerSize / 2));
      ctx.fill();
    } else {
      ctx.fillRect(drawX, drawY, innerSize, innerSize);
    }
  }
  if (clearcoat > 0 && clearcoatSize > 0) {
    const radius = Math.max(3, innerSize * clearcoatSize * 0.6);
    const grad = ctx.createRadialGradient(drawX + radius * 0.55, drawY + radius * 0.5, 0, drawX + radius * 0.55, drawY + radius * 0.5, radius);
    grad.addColorStop(0, `rgba(255,255,255,${clearcoat * 0.7})`);
    grad.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = grad;
    if (cornerRadius > 0 && typeof ctx.roundRect === "function") {
      ctx.beginPath();
      ctx.roundRect(drawX, drawY, innerSize, innerSize, Math.min(cornerRadius, innerSize / 2));
      ctx.fill();
    } else {
      ctx.fillRect(drawX, drawY, innerSize, innerSize);
    }
  }
  if (rimLight > 0) {
    const rad = ctx.createRadialGradient(
      drawX + innerSize / 2,
      drawY + innerSize / 2,
      innerSize * 0.2,
      drawX + innerSize / 2,
      drawY + innerSize / 2,
      innerSize * 0.65,
    );
    rad.addColorStop(0, "rgba(255,255,255,0)");
    rad.addColorStop(1, `rgba(255,255,255,${rimLight * 0.45})`);
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.fillStyle = rad;
    if (cornerRadius > 0 && typeof ctx.roundRect === "function") {
      ctx.beginPath();
      ctx.roundRect(drawX, drawY, innerSize, innerSize, Math.min(cornerRadius, innerSize / 2));
      ctx.fill();
    } else {
      ctx.fillRect(drawX, drawY, innerSize, innerSize);
    }
    ctx.restore();
  }
  if (innerShadow > 0 && innerShadowStrength > 0) {
    ctx.strokeStyle = `rgba(0,0,0,${innerShadowStrength * 0.6})`;
    ctx.lineWidth = innerShadow;
    const inset = innerShadow / 2;
    ctx.strokeRect(drawX + inset, drawY + inset, innerSize - innerShadow, innerSize - innerShadow);
  }
  if (scanlines > 0) {
    ctx.save();
    ctx.globalAlpha = Math.min(0.4, scanlines * 0.6);
    ctx.strokeStyle = "rgba(0,0,0,0.3)";
    ctx.lineWidth = 1;
    const step = Math.max(2, Math.floor(innerSize / 6));
    for (let yy = Math.floor(drawY) + step; yy < drawY + innerSize; yy += step) {
      ctx.beginPath();
      ctx.moveTo(drawX, yy);
      ctx.lineTo(drawX + innerSize, yy);
      ctx.stroke();
    }
    ctx.restore();
  }
  if (textureId && textureOpacity > 0) {
    if (!BLOCK_STYLE_TEXTURES.has(textureId)) {
      getBlockStyleTexturePattern(ctx, textureId, node);
    }
    const texture = getBlockStyleTexturePattern(ctx, textureId, node);
    if (texture?.image?.width) {
      const img = texture.image;
      let srcX = 0;
      let srcY = 0;
      let srcW = img.width;
      let srcH = img.height;
      let extraRotation = 0;
      let flipX = false;
      let flipY = false;
      if (textureTransform && RANDOM_TEXTURE_IDS.has(textureId)) {
        if (textureId === "pixelated") {
          const ratio = Math.max(0.01, Math.min(1, textureTransform.size ?? PIXELATED_TEXTURE_SAMPLE_RATIO));
          srcW = Math.max(1, Math.round(img.width * ratio));
          srcH = Math.max(1, Math.round(img.height * ratio));
        } else {
          srcW = Math.max(1, Math.min(TEXTURE_SAMPLE_PX, img.width));
          srcH = Math.max(1, Math.min(TEXTURE_SAMPLE_PX, img.height));
        }
        const maxX = Math.max(0, img.width - srcW);
        const maxY = Math.max(0, img.height - srcH);
        srcX = Math.floor(maxX * (textureTransform.u ?? 0));
        srcY = Math.floor(maxY * (textureTransform.v ?? 0));
        extraRotation = textureTransform.rotation ?? 0;
        flipX = !!textureTransform.flipX;
        flipY = !!textureTransform.flipY;
      }
      const scaleBase = Math.max(innerSize / srcW, innerSize / srcH);
      const drawW = srcW * scaleBase * textureScale;
      const drawH = srcH * scaleBase * textureScale;
      ctx.save();
      if (cornerRadius > 0 && typeof ctx.roundRect === "function") {
        ctx.beginPath();
        ctx.roundRect(drawX, drawY, innerSize, innerSize, Math.min(cornerRadius, innerSize / 2));
        ctx.clip();
      } else {
        ctx.beginPath();
        ctx.rect(drawX, drawY, innerSize, innerSize);
        ctx.clip();
      }
      ctx.globalAlpha = Math.min(1, textureOpacity);
      ctx.globalCompositeOperation = "multiply";
      ctx.translate(drawX + innerSize / 2, drawY + innerSize / 2);
      ctx.rotate(((textureAngle + extraRotation) * Math.PI) / 180);
      ctx.scale(flipX ? -1 : 1, flipY ? -1 : 1);
      ctx.drawImage(img, srcX, srcY, srcW, srcH, -drawW / 2, -drawH / 2, drawW, drawH);
      ctx.restore();
    }
  }
  ctx.restore();
  if (borderSize > 0) {
    const edgeParsed = parseColorComponents(darkerEdge);
    const borderColor = rgbaString(
      {
        r: edgeParsed.r,
        g: edgeParsed.g,
        b: edgeParsed.b,
        a: outlineOpacity,
      },
      true,
    );
    const inset = borderSize / 2;
    const strokeBorder = () => {
      if (cornerRadius > 0 && typeof ctx.roundRect === "function") {
        ctx.beginPath();
        ctx.roundRect(
          drawX + inset,
          drawY + inset,
          innerSize - borderSize,
          innerSize - borderSize,
          Math.max(0, Math.min(cornerRadius - inset, innerSize / 2)),
        );
        ctx.stroke();
      } else {
        ctx.strokeRect(drawX + inset, drawY + inset, innerSize - borderSize, innerSize - borderSize);
      }
    };
    ctx.save();
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = borderSize;
    if (glow > 0 && glowOpacity > 0) {
      const glowParsed = parseColorComponents(adjustColorByFactor(borderBase, 0.25));
      const glowAlpha = Math.min(1, Math.max(0, glowOpacity)) * (glowParsed.a ?? 1);
      ctx.shadowColor = rgbaString(
        { r: glowParsed.r, g: glowParsed.g, b: glowParsed.b, a: glowAlpha },
        true,
      );
      ctx.shadowBlur = glow * 6;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
      ctx.globalCompositeOperation = "lighter";
      strokeBorder();
    }
    if (style.border_blur > 0) {
      ctx.shadowColor = "transparent";
      ctx.shadowBlur = 0;
      ctx.globalCompositeOperation = "source-over";
      ctx.filter = `blur(${style.border_blur}px)`;
      strokeBorder();
    } else if (glow <= 0 || glowOpacity <= 0) {
      strokeBorder();
    }
    ctx.restore();
  }
  if (noise > 0) {
    ctx.save();
    const count = Math.max(4, Math.ceil(40 * noise));
    ctx.globalAlpha = Math.min(1, 0.3 + noise * 0.7);
    ctx.fillStyle = "rgba(255,255,255,0.5)";
    for (let i = 0; i < count; i += 1) {
      const nxSeed = Math.sin((drawX + drawY + i * 13) * 12.9898) * 43758.5453;
      const nySeed = Math.cos((drawX + drawY + i * 7) * 78.233) * 43758.5453;
      const nx = drawX + Math.abs(nxSeed % 1) * innerSize;
      const ny = drawY + Math.abs(nySeed % 1) * innerSize;
      ctx.fillRect(nx, ny, 1, 1);
    }
    ctx.globalAlpha = Math.min(1, noise * 0.5);
    ctx.fillStyle = "rgba(0,0,0,0.4)";
    for (let i = 0; i < Math.ceil(count / 2); i += 1) {
      const nxSeed = Math.sin((drawX + drawY + i * 17) * 33.333) * 12345.6789;
      const nySeed = Math.cos((drawX + drawY + i * 9) * 45.678) * 98765.4321;
      const nx = drawX + Math.abs(nxSeed % 1) * innerSize;
      const ny = drawY + Math.abs(nySeed % 1) * innerSize;
      ctx.fillRect(nx, ny, 1, 1);
    }
    ctx.restore();
  }
}

function ghostLandingY(state) {
  const ghost = { ...state.piece };
  while (!collides(state.board, { ...ghost, y: ghost.y + 1 })) {
    ghost.y += 1;
  }
  return ghost.y;
}

function drawGhostPiece(ctx, state, boardX, boardY, blockSize, color, outlineColor) {
  const ghostY = ghostLandingY(state);
  const ghost = { ...state.piece, y: ghostY };
  const cells = pieceCells(ghost);
  ctx.globalAlpha = 0.33;
  for (const [x, y] of cells) {
    if (y >= HIDDEN_ROWS - 1 && y < GRID_H_TOTAL) {
      ctx.fillStyle = color;
      ctx.fillRect(
        boardX + x * blockSize,
        boardY + (y - HIDDEN_ROWS) * blockSize,
        blockSize - 1,
        blockSize - 1
      );
    }
  }
  ctx.globalAlpha = 0.67;
  ctx.strokeStyle = outlineColor;
  ctx.lineWidth = 1;
  for (const [x, y] of cells) {
    if (y >= HIDDEN_ROWS - 1 && y < GRID_H_TOTAL) {
      ctx.strokeRect(
        boardX + x * blockSize + 0.5,
        boardY + (y - HIDDEN_ROWS) * blockSize + 0.5,
        blockSize - 2,
        blockSize - 2
      );
    }
  }
  ctx.globalAlpha = 1;
}

function drawTetrisGlow(ctx, boardX, boardY, blockSize, rows, elapsed, duration) {
  if (!rows || rows.length !== 4) return;
  if (!Number.isFinite(elapsed) || !Number.isFinite(duration) || duration <= 0) return;
  const progress = Math.min(1, Math.max(0, elapsed / duration));
  const baseAlpha = 0.95 * (1 - progress);
  if (baseAlpha <= 0.01) return;
  const minRow = Math.min(...rows);
  const maxRow = Math.max(...rows);
  if (!Number.isFinite(minRow) || !Number.isFinite(maxRow)) return;
  ctx.save();
  if (maxRow >= HIDDEN_ROWS) {
    const flicker = 0.7 + 0.3 * Math.sin(elapsed / 32);
    const alpha = Math.max(0, baseAlpha * flicker);
    const jitter = Math.sin(elapsed / 18) * 0.6;
    const y = boardY + (Math.max(minRow, HIDDEN_ROWS) - HIDDEN_ROWS) * blockSize;
    const h = (maxRow - Math.max(minRow, HIDDEN_ROWS) + 1) * blockSize;
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = "rgba(255, 210, 72, 1)";
    ctx.lineWidth = 6;
    ctx.shadowBlur = 26 + Math.abs(jitter) * 4;
    ctx.shadowColor = "rgba(255, 210, 72, 0.98)";
    ctx.strokeRect(boardX + 1 + jitter, y + 1, GRID_W * blockSize - 2, h - 2);
    ctx.globalAlpha = alpha * 0.6;
    ctx.strokeStyle = "rgba(255, 235, 150, 1)";
    ctx.lineWidth = 3;
    ctx.shadowBlur = 14;
    ctx.shadowColor = "rgba(255, 235, 150, 0.9)";
    ctx.strokeRect(boardX + 4 - jitter, y + 4, GRID_W * blockSize - 8, h - 8);
  }
  ctx.restore();
}

function drawHardDropTrail(ctx, state, boardX, boardY, blockSize, palette) {
  const trail = state.hardDropTrail;
  if (!trail) return;
  const now = typeof performance !== "undefined" ? performance.now() : Date.now();
  const progress = trail.duration > 0 ? (now - trail.start) / trail.duration : 1;
  if (progress >= 1) return;
  const alpha = Math.max(0, 0.28 * (1 - progress));
  if (alpha <= 0.01) return;
  const baseColor = palette[trail.shape] || palette.T;
  ctx.save();
  ctx.globalAlpha = 1;
  const span = Math.max(1, trail.endY - trail.startY);
  for (let y = trail.startY; y <= trail.endY; y += 1) {
    const piece = { shape: trail.shape, rot: trail.rot, x: trail.x, y };
    const cells = pieceCells(piece);
    const rowFade = Math.max(0, (y - trail.startY) / span);
    for (const [cx, cy] of cells) {
      if (cy >= HIDDEN_ROWS - 1 && cy < GRID_H_TOTAL) {
        ctx.fillStyle = colorWithAlpha(baseColor, alpha * rowFade);
        ctx.fillRect(
          boardX + cx * blockSize,
          boardY + (cy - HIDDEN_ROWS) * blockSize,
          blockSize - 1,
          blockSize - 1,
        );
      }
    }
  }
  ctx.restore();
}

function drawActionToast(ctx, state, layout, theme, palette) {
  const toast = state.actionToast;
  if (!toast) return;
  const now = typeof performance !== "undefined" ? performance.now() : Date.now();
  const duration = toast.duration ?? 1200;
  const elapsed = Math.min(duration, Math.max(0, now - toast.start));
  if (now >= toast.until) return;
  const progress = duration > 0 ? (elapsed / duration) : 1;
  const alpha = Math.max(0, 1 - progress);
  const { boardX, boardY, boardW, boardH, blockSize } = layout;
  const baseSize = Math.max(12, Math.round(blockSize * 0.55));
  const fontSize = Math.round(baseSize * (toast.scale || 1));
  ctx.save();
  ctx.font = `700 ${fontSize}px sans-serif`;
  const text = toast.text;
  const textWidth = ctx.measureText(text).width;
  const pad = 6;
  const anchorX = toast.anchorX ?? 4.5;
  const anchorY = toast.anchorY ?? HIDDEN_ROWS + 2;
  let x = boardX + anchorX * blockSize - textWidth / 2;
  let y = boardY + (anchorY - HIDDEN_ROWS) * blockSize - (progress * blockSize * 0.6);
  x = Math.max(boardX + pad, Math.min(boardX + boardW - textWidth - pad, x));
  y = Math.max(boardY + pad, Math.min(boardY + boardH - fontSize - pad, y));
  const colorKey = toast.colorKey || state.lastLockedPiece?.shape || "T";
  const baseColor = palette?.[colorKey] || theme?.text || "rgba(255,255,255,0.95)";
  const outlineColor = adjustColorByFactor(baseColor, -0.5);
  ctx.globalAlpha = alpha;
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.lineWidth = Math.max(2, Math.round(fontSize * 0.15));
  ctx.strokeStyle = outlineColor;
  ctx.strokeText(text, x, y);
  ctx.fillStyle = baseColor;
  ctx.fillText(text, x, y);
  ctx.restore();
}

function getInputDataByName(node, name) {
  const idx = node?.inputs?.findIndex((inp) => inp?.name === name);
  if (idx == null || idx < 0) return null;
  if (typeof node.getInputData !== "function") return null;
  return node.getInputData(idx);
}

function coerceImageSource(value) {
  if (!value) return null;
  if (
    value instanceof HTMLImageElement ||
    value instanceof HTMLCanvasElement ||
    value instanceof ImageBitmap ||
    value instanceof OffscreenCanvas ||
    value instanceof HTMLVideoElement
  ) {
    return value;
  }
  if (value.image) {
    const img = value.image;
    if (
      img instanceof HTMLImageElement ||
      img instanceof HTMLCanvasElement ||
      img instanceof ImageBitmap ||
      img instanceof OffscreenCanvas
    ) {
      return img;
    }
  }
  return null;
}

function toByteArray(data) {
  if (!data) return null;
  if (data instanceof Uint8ClampedArray) return data;
  let array = data;
  if (data instanceof Uint8Array) {
    return new Uint8ClampedArray(data.buffer, data.byteOffset, data.byteLength);
  }
  if (data instanceof Float32Array || data instanceof Float64Array) {
    array = Array.from(data);
  }
  if (Array.isArray(array)) {
    let max = 0;
    for (let i = 0; i < array.length; i += 1) {
      const v = array[i];
      if (Number.isFinite(v) && v > max) max = v;
    }
    const scale = max <= 1 ? 255 : 1;
    const out = new Uint8ClampedArray(array.length);
    for (let i = 0; i < array.length; i += 1) {
      const v = array[i];
      const value = Number.isFinite(v) ? v * scale : 0;
      out[i] = Math.max(0, Math.min(255, Math.round(value)));
    }
    return out;
  }
  return null;
}

function buildCanvasFromData(value) {
  if (!value || !value.data || !value.width || !value.height) return null;
  const width = Math.max(1, Math.floor(value.width));
  const height = Math.max(1, Math.floor(value.height));
  const bytes = toByteArray(value.data);
  if (!bytes) return null;
  const expected3 = width * height * 3;
  const expected4 = width * height * 4;
  let pixels = bytes;
  if (bytes.length === expected3) {
    pixels = new Uint8ClampedArray(expected4);
    for (let i = 0; i < width * height; i += 1) {
      const src = i * 3;
      const dst = i * 4;
      pixels[dst] = bytes[src];
      pixels[dst + 1] = bytes[src + 1];
      pixels[dst + 2] = bytes[src + 2];
      pixels[dst + 3] = 255;
    }
  } else if (bytes.length !== expected4) {
    return null;
  }
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  if (!ctx) return null;
  const imgData = new ImageData(pixels, width, height);
  ctx.putImageData(imgData, 0, 0);
  return canvas;
}

function buildCanvasFromTensor(value) {
  if (!value || !value.data || !value.shape) return null;
  const shape = Array.isArray(value.shape) ? value.shape : null;
  if (!shape || shape.length < 2) return null;
  let height = null;
  let width = null;
  let channels = null;
  if (shape.length >= 4) {
    channels = shape[shape.length - 1];
    width = shape[shape.length - 2];
    height = shape[shape.length - 3];
  } else if (shape.length === 3) {
    channels = shape[2];
    width = shape[1];
    height = shape[0];
  }
  if (!width || !height || !channels) return null;
  if (channels !== 3 && channels !== 4) return null;
  const frameSize = width * height * channels;
  let data = value.data;
  if (Array.isArray(data)) {
    data = data.slice(0, frameSize);
  } else if (data && typeof data.subarray === "function" && data.length > frameSize) {
    data = data.subarray(0, frameSize);
  }
  return buildCanvasFromData({ data, width, height });
}

function getImageInfo(value) {
  if (!value) return null;
  if (Array.isArray(value)) return value[0] || null;
  if (Array.isArray(value.tetrinode_background)) return value.tetrinode_background[0] || null;
  if (Array.isArray(value.ui?.tetrinode_background)) return value.ui.tetrinode_background[0] || null;
  if (Array.isArray(value.images)) return value.images[0] || null;
  if (Array.isArray(value.image)) return value.image[0] || null;
  if (Array.isArray(value.result)) return value.result[0] || null;
  return value;
}

function imageInfoUrl(info) {
  if (!info) return null;
  if (typeof info === "string") return info;
  if (info.url) return info.url;
  const filename = info.filename || info.name;
  if (!filename) return null;
  const type = info.type || "temp";
  const subfolder = info.subfolder || "";
  return `./view?filename=${encodeURIComponent(filename)}&type=${encodeURIComponent(type)}&subfolder=${encodeURIComponent(subfolder)}`;
}

function getImageFromInfo(node, info) {
  const url = imageInfoUrl(info);
  if (!url) return null;
  if (IMAGE_CACHE.has(url)) {
    return IMAGE_CACHE.get(url);
  }
  const img = new Image();
  img.src = url;
  img.addEventListener("load", () => {
    node?.setDirtyCanvas(true, true);
  });
  IMAGE_CACHE.set(url, img);
  return img;
}

function getLinkedImageInfo(node, name) {
  const resolved = getInputLink(node, name);
  if (!resolved) return null;
  const { origin, link } = resolved;
  if (!origin) return null;
  const slot = link?.origin_slot ?? 0;
  const outputKey = origin.outputs?.[slot]?.name;
  const outputs = app?.nodeOutputs?.[origin.id] || app?.nodeOutputs?.[`${origin.id}`];
  if (outputs) {
    const candidates = [
      outputKey ? outputs[outputKey] : null,
      outputs.tetrinode_background,
      outputs.ui?.tetrinode_background,
      outputs.images,
      outputs.image,
      outputs.result,
      outputs.output,
    ];
    for (const candidate of candidates) {
      const info = getImageInfo(candidate);
      if (info) return info;
    }
  }
  const linked = origin.outputs?.[slot]?.links || [];
  for (const linkId of linked) {
    const linkInfo = node?.graph?.links?.[linkId];
    if (!linkInfo) continue;
    const targetId = linkInfo.target_id;
    const targetOutputs = app?.nodeOutputs?.[targetId] || app?.nodeOutputs?.[`${targetId}`];
    if (!targetOutputs) continue;
    const previewCandidates = [
      targetOutputs.images,
      targetOutputs.image,
      targetOutputs.result,
      targetOutputs.output,
    ];
    for (const candidate of previewCandidates) {
      const info = getImageInfo(candidate);
      if (info) return info;
    }
  }
  return null;
}

function getLinkedImageSource(node, name) {
  const resolved = getInputLink(node, name);
  if (!resolved) return null;
  const { origin, link } = resolved;
  const slot = link?.origin_slot ?? 0;
  if (!origin) return null;
  if (Array.isArray(origin.imgs)) {
    const candidate = origin.imgs[slot] || origin.imgs[0];
    const source = coerceImageSource(candidate);
    if (source) return source;
  }
  if (Array.isArray(origin.images)) {
    const candidate = origin.images[slot] || origin.images[0];
    const source = coerceImageSource(candidate);
    if (source) return source;
  }
  const direct = coerceImageSource(origin.image || origin.img || origin._img || origin._image);
  if (direct) return direct;
  return null;
}

function getBackgroundSource(node) {
  const raw = getInputDataByName(node, "background_image");
  let value = Array.isArray(raw) ? raw[0] : raw;
  let source = null;
  let info = null;
  if (!value) {
    source = getLinkedImageSource(node, "background_image");
    value = source;
  }
  if (!value && !source) {
    info = getLinkedImageInfo(node, "background_image");
    if (!info) {
      const selfOutputs = app?.nodeOutputs?.[node?.id] || app?.nodeOutputs?.[`${node?.id}`];
      info = getImageInfo(
        selfOutputs?.tetrinode_background
        || selfOutputs?.ui?.tetrinode_background
        || selfOutputs?.images
        || selfOutputs?.image
        || selfOutputs?.result,
      );
    }
    if (!info) return null;
    value = info;
  }
  if (!node.__tetrisBg) node.__tetrisBg = {};
  if (node.__tetrisBg.value === value && node.__tetrisBg.source) {
    return node.__tetrisBg.source;
  }
  if (!source) {
    source = coerceImageSource(value);
  }
  if (!source) {
    info = info || getImageInfo(value) || getLinkedImageInfo(node, "background_image");
    if (info) value = info;
    source = getImageFromInfo(node, info);
  }
  if (!source) {
    source = buildCanvasFromData(value);
  }
  if (!source) {
    source = buildCanvasFromTensor(value);
  }
  node.__tetrisBg = { value, source };
  return source || null;
}

function drawBoardBackground(ctx, source, boardX, boardY, boardW, boardH, fallbackColor) {
  if (!source) {
    ctx.fillStyle = fallbackColor || COLORS.X;
    ctx.fillRect(boardX, boardY, boardW, boardH);
    return;
  }
  const srcW =
    source.videoWidth ||
    source.naturalWidth ||
    source.width ||
    source.displayWidth ||
    0;
  const srcH =
    source.videoHeight ||
    source.naturalHeight ||
    source.height ||
    source.displayHeight ||
    0;
  if (!srcW || !srcH) {
    ctx.fillStyle = fallbackColor || COLORS.X;
    ctx.fillRect(boardX, boardY, boardW, boardH);
    return;
  }
  const scale = Math.max(boardW / srcW, boardH / srcH);
  const cropW = boardW / scale;
  const cropH = boardH / scale;
  const sx = Math.max(0, (srcW - cropW) / 2);
  const sy = Math.max(0, (srcH - cropH) / 2);
  ctx.drawImage(source, sx, sy, cropW, cropH, boardX, boardY, boardW, boardH);
}

function drawBoardGrid(ctx, boardX, boardY, boardW, boardH, blockSize, color, extraPx) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let x = 1; x < GRID_W; x += 1) {
    const lineX = boardX + x * blockSize - 0.5;
    ctx.moveTo(lineX, boardY - 0.5);
    ctx.lineTo(lineX, boardY + boardH + 0.5);
  }
  const yOffset = extraPx || 0;
  for (let y = 0; y < GRID_H_VISIBLE; y += 1) {
    const lineY = boardY + yOffset + y * blockSize - 0.5;
    ctx.moveTo(boardX - 0.5, lineY);
    ctx.lineTo(boardX + boardW + 0.5, lineY);
  }
  ctx.stroke();
}

const THEME_USED_KEYS = new Set([
  "panel_bg",
  "panel_border",
  "panel_shadow",
  "button",
  "text",
  "button_bg",
  "button_hover",
]);

function drawNode(node, ctx) {
  const live = node.__tetrisLive;
  if (!live) return;
  if (!node.__tetrisWidgetsHidden) {
    applyWidgetHiding(node);
  }
  syncStartLevel(live.state, node);
  syncSeed(live.state, node);
  const { state } = live;
  const {
    boardX,
    boardY,
    boardW,
    boardH,
    sideY,
    blockSize,
    extraPx,
    showHold,
    showNext,
  } = getLayout(node);
  const theme = getThemeColors(node);
  const palette = getColorPalette(node);
  const ghostEnabled = isGhostEnabled(node);
  const showControls = getShowControls(node);
  const gridEnabled = getGridEnabled(node);
  const gridColor = getGridColor(node);
  const animConfig = getConfig(node);

  const bgSource = getBackgroundSource(node);
  drawBoardBackground(ctx, bgSource, boardX, boardY, boardW, boardH, palette.X);
  if (gridEnabled && gridColor) {
    drawBoardGrid(ctx, boardX, boardY, boardW, boardH, blockSize, gridColor, extraPx);
  }
  ctx.strokeStyle = theme.panel_border;
  ctx.lineWidth = 1;
  applyBorderGlow(ctx, node);
  ctx.strokeRect(boardX - 0.5, boardY - 0.5, boardW + 1, boardH + 1);
  clearBorderGlow(ctx);

  const hideBoard = !state.gameOver && state.started && !state.running && !state.showBoardWhilePaused;
  const showPreviews = state.started && state.running && !hideBoard;
  const showBoardContents = (showPreviews || state.gameOver) && !hideBoard;
  if (!hideBoard) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(boardX, boardY, boardW, boardH);
    ctx.clip();
    if (showBoardContents) {
      const cache = ensureBoardCache(node, state, { boardW, boardH, blockSize, extraPx }, palette);
      if (cache) {
        ctx.drawImage(cache, boardX, boardY);
      }
    }

  if (showBoardContents && !state.clearing && animConfig.anim_hard_drop_trail !== false) {
    drawHardDropTrail(ctx, state, boardX, boardY + extraPx, blockSize, palette);
  }
  if (!state.gameOver && ghostEnabled && showPreviews && !state.clearing) {
    drawGhostPiece(ctx, state, boardX, boardY + extraPx, blockSize, palette[state.piece.shape], COLORS.Text);
  }

  if (showBoardContents && !state.clearing) {
    const pieceTransforms = ensurePieceTextureTransforms(state.piece);
    pieceCells(state.piece).forEach(([x, y], index) => {
      if (y >= HIDDEN_ROWS - 1 && y < GRID_H_TOTAL) {
          drawBlockSized(
            ctx,
            boardX + x * blockSize,
            boardY + (y - HIDDEN_ROWS) * blockSize + extraPx,
            blockSize,
            palette[state.piece.shape],
            node,
            pieceTransforms[index] ?? null,
          );
      }
    });
  }
  if (showBoardContents && state.lineClear?.rows?.length && animConfig.anim_line_clear !== false) {
    const flashMs = state.lineClear.flashMs ?? 0;
    const elapsed = state.lineClear.elapsed ?? 0;
    const wipeMs = state.lineClear.wipeMs ?? 0;
    const wipeProgress = wipeMs > 0 ? Math.min(1, Math.max(0, (elapsed - flashMs) / wipeMs)) : 0;
    const clearCenter = GRID_W / 2;
    const clearMaxDist = clearCenter - 0.5;
    if (wipeProgress > 0) {
      const ghostAlpha = 0.5 * (1 - wipeProgress);
      if (ghostAlpha > 0.01) {
        ctx.save();
        state.lineClear.rows.forEach((row) => {
          if (row < HIDDEN_ROWS) return;
          const y = boardY + (row - HIDDEN_ROWS) * blockSize + extraPx;
          for (let x = 0; x < GRID_W; x += 1) {
            const cell = state.board[row]?.[x];
            if (!cell) continue;
            const dist = Math.abs((x + 0.5) - clearCenter);
            if (wipeProgress >= (dist / clearMaxDist)) {
              const color = palette[cell];
              ctx.fillStyle = colorWithAlpha(color, ghostAlpha);
              ctx.fillRect(boardX + x * blockSize, y, blockSize, blockSize);
            }
          }
        });
        ctx.restore();
      }
    }
    if (elapsed < flashMs) {
      const intensity = 0.35 * Math.max(0, 1 - (elapsed / flashMs));
      ctx.save();
      ctx.fillStyle = `rgba(255,255,255,${intensity})`;
      state.lineClear.rows.forEach((row) => {
        if (row < HIDDEN_ROWS) return;
        const y = boardY + (row - HIDDEN_ROWS) * blockSize + extraPx;
        ctx.fillRect(boardX, y, boardW, blockSize);
      });
      ctx.restore();
    }
  }
    ctx.restore();
  }

  if (animConfig.anim_score_toasts !== false) {
    drawActionToast(
      ctx,
      state,
      { boardX, boardY, boardW, boardH, blockSize },
      theme,
      palette,
    );
  }

  const previewBox = Math.max(4, Math.floor(PREVIEW_GRID * blockSize * PREVIEW_SCALE));
  const columnShift = Math.max(4, Math.floor(blockSize * 0.2));
  const leftBoxX = PADDING;
  const leftBoxW = Math.max(0, boardX - PADDING * 2);
  const leftX = leftBoxX + columnShift;
  const rightBoxX = boardX + boardW + PADDING;
  const rightBoxW = Math.max(0, node.size[0] - PADDING - rightBoxX);
  const maxWidthRight = Math.max(0, node.size[0] - rightBoxX - PADDING);
  const leftColumnW = leftBoxW;
  const maxWidthLeft = Math.max(0, leftColumnW);
  const measureFits = (size, lines, maxWidth) => {
    ctx.font = `bold ${size}px sans-serif`;
    let widest = ctx.measureText(lines[0]).width;
    ctx.font = `${size}px sans-serif`;
    for (let i = 1; i < lines.length; i += 1) {
      widest = Math.max(widest, ctx.measureText(lines[i]).width);
    }
    return widest <= maxWidth;
  };
  let hudFontSize = Math.max(8, Math.floor(blockSize * 0.5));
  while (hudFontSize > 8) {
    if (measureFits(hudFontSize, ["Lines:", "Score:", "Time:", "Level:", "Goal:", "Tetrises:", "T-Spins:", "Combos:", "TPM:", "LPM:"], maxWidthLeft)) break;
    hudFontSize -= 1;
  }
  const scoreFontSize = Math.max(7, hudFontSize - 1);
  const innerPad = Math.max(2, Math.floor(blockSize * 0.2));
  const titleFontSize = Math.max(6, scoreFontSize - 1);
  const titlePad = Math.max(6, Math.floor(titleFontSize * 0.6));
  const titleHeight = titleFontSize + titlePad;
  const nextBoxY = boardY;
  ctx.fillStyle = theme.text;
  const lineGap = Math.floor(scoreFontSize * 0.6);
  const leftHudTopY = showHold ? nextBoxY + previewBox + PADDING * 1.2 : sideY;
  const scoreLabelY = leftHudTopY + scoreFontSize + 1;
  const scoreValueY = scoreLabelY + scoreFontSize + 2;
  const timeLabelY = scoreValueY + lineGap + scoreFontSize;
  const timeValueY = timeLabelY + scoreFontSize + 2;
  const linesLabelY = timeValueY + lineGap + scoreFontSize + 6;
  const linesValueY = linesLabelY;
  const levelLabelY = linesLabelY + lineGap + scoreFontSize;
  const levelValueY = levelLabelY;
  const goalLabelY = levelLabelY + lineGap + scoreFontSize;
  const goalValueY = goalLabelY;
  const statsTopY = goalLabelY + lineGap + scoreFontSize + 6;
  const tetrisLabelY = statsTopY + scoreFontSize;
  const tetrisValueY = tetrisLabelY;
  const tspinLabelY = tetrisLabelY + lineGap + scoreFontSize;
  const tspinValueY = tspinLabelY;
  const comboLabelY = tspinLabelY + lineGap + scoreFontSize;
  const comboValueY = comboLabelY;
  const tpmLabelY = comboLabelY + lineGap + scoreFontSize;
  const tpmValueY = tpmLabelY;
  const lpmLabelY = tpmLabelY + lineGap + scoreFontSize;
  const lpmValueY = lpmLabelY;
  ctx.font = `bold ${scoreFontSize}px sans-serif`;
  ctx.textAlign = "left";
  ctx.fillText("Score:", leftX, scoreLabelY);
  ctx.fillText("Time:", leftX, timeLabelY);
  ctx.fillText("Lines:", leftX, linesLabelY);
  ctx.fillText("Level:", leftX, levelLabelY);
  ctx.fillText("Goal:", leftX, goalLabelY);
  ctx.fillText("Tetrises:", leftX, tetrisLabelY);
  ctx.fillText("T-Spins:", leftX, tspinLabelY);
  ctx.fillText("Combos:", leftX, comboLabelY);
  ctx.fillText("TPM:", leftX, tpmLabelY);
  ctx.fillText("LPM:", leftX, lpmLabelY);
  ctx.font = `${scoreFontSize}px sans-serif`;
  const linesValue = state.levelProgression === "variable" ? state.goalLinesTotal : state.lines;
  const linesText =
    Number.isFinite(linesValue) && Math.abs(linesValue % 1) > 0.001
      ? linesValue.toFixed(1)
      : `${Math.round(linesValue)}`;
  const remaining = state.goalRemaining ?? 0;
  const remainingText =
    Number.isFinite(remaining) && Math.abs(remaining % 1) > 0.001
      ? remaining.toFixed(1)
      : `${Math.round(remaining)}`;
  const minutes = state.timeMs > 0 ? state.timeMs / 60000 : 0;
  const tpm = minutes > 0 ? (state.tetrises || 0) / minutes : 0;
  const lpm = minutes > 0 ? (state.lines || 0) / minutes : 0;
  const tpmText = minutes > 0 ? tpm.toFixed(1) : "0";
  const lpmText = minutes > 0 ? lpm.toFixed(1) : "0";
  const valueX = leftBoxX + leftBoxW - 3;
  ctx.textAlign = "right";
  ctx.fillText(`${state.score}`, valueX, scoreValueY);
  ctx.fillText(formatTimeMs(state.timeMs), valueX, timeValueY);
  ctx.fillText(linesText, valueX, linesValueY);
  ctx.fillText(`${state.level}`, valueX, levelValueY);
  ctx.fillText(remainingText, valueX, goalValueY);
  ctx.fillText(`${state.tetrises || 0}`, valueX, tetrisValueY);
  ctx.fillText(`${state.tspins || 0}`, valueX, tspinValueY);
  ctx.fillText(`${state.comboTotal || 0}`, valueX, comboValueY);
  ctx.fillText(tpmText, valueX, tpmValueY);
  ctx.fillText(lpmText, valueX, lpmValueY);
  ctx.textAlign = "left";
  const bindings = getControlBindings(node);
  const controlEntries = showControls
    ? [
      { label: "Move Left:", value: formatKeyLabel(bindings.moveLeft?.[0]) },
      { label: "Move Right:", value: formatKeyLabel(bindings.moveRight?.[0]) },
      { label: "Rotate CW:", value: formatKeyLabel(bindings.rotateCw?.[0]) },
      { label: "Rotate CCW:", value: formatKeyLabel(bindings.rotateCcw?.[0]) },
      { label: "Soft Drop:", value: formatKeyLabel(bindings.softDrop?.[0]) },
      { label: "Hard Drop:", value: formatKeyLabel(bindings.hardDrop?.[0]) },
      { label: "Hold:", value: formatKeyLabel(bindings.hold?.[0]) },
      { label: "Reset:", value: formatKeyLabel(bindings.reset?.[0]) },
      { label: "Pause:", value: formatKeyLabel(bindings.pause?.[0]) },
      { label: "Settings:", value: formatKeyLabel(bindings.settings?.[0]) },
    ]
    : [];
  let fontSize = Math.max(4, Math.floor(blockSize * 0.3));
  if (controlEntries.length) {
    while (fontSize > 8) {
      const labels = controlEntries.map((entry) => entry.label);
      if (measureFits(fontSize, labels, maxWidthRight)) break;
      fontSize -= 1;
    }
  }
  const lineHeight = fontSize + 3;
  const tablePad = Math.max(6, Math.floor(fontSize * 0.6));
  const controlsPad = tablePad + 3;
  const tableGap = Math.max(6, Math.floor(fontSize * 0.6));
  const tableWForControls = Math.max(0, maxWidthLeft);
  let controlsHeight = 0;
  let leftColWidth = 0;
  let rightColWidth = 0;
  let controlRows = [];
  if (controlEntries.length) {
    ctx.font = `bold ${fontSize}px sans-serif`;
    leftColWidth = Math.max(...controlEntries.map((entry) => ctx.measureText(entry.label).width));
    leftColWidth = Math.min(leftColWidth, Math.max(40, Math.floor(tableWForControls * 0.45)));
    rightColWidth = Math.max(0, tableWForControls - controlsPad * 2 - leftColWidth - tableGap);
    ctx.font = `${fontSize}px sans-serif`;
    const wrapValue = (value) => {
      if (!value) return [""];
      const parts = value.split(", ");
      const lines = [];
      let current = "";
      for (const part of parts) {
        const chunk = current ? `${current} / ${part}` : part;
        if (ctx.measureText(chunk).width <= rightColWidth || !current) {
          current = chunk;
        } else {
          lines.push(current);
          current = part;
        }
      }
      if (current) lines.push(current);
      return lines;
    };
    controlRows = controlEntries.map((entry) => ({
      label: entry.label,
      lines: wrapValue(entry.value),
    }));
    controlsHeight = controlRows.reduce((sum, row) => sum + row.lines.length * lineHeight, 0);
  }
  const infoBlockHeight = controlEntries.length
    ? controlsHeight + tablePad * 2 + lineHeight
    : 0;

  const holdNextTitleY = nextBoxY + titleFontSize + 4;
  const titleInset = Math.max(4, Math.floor(titleFontSize * 0.5));
  ctx.font = `bold ${titleFontSize}px sans-serif`;
  const drawScaledBlock = (targetX, targetY, targetSize, color, transform = null) => {
    const live = node.__tetrisLive;
    if (!live) return;
    if (!live.previewBlockCanvas) {
      live.previewBlockCanvas = document.createElement("canvas");
      live.previewBlockCtx = live.previewBlockCanvas.getContext("2d");
    }
    const sourceCanvas = live.previewBlockCanvas;
    const sourceCtx = live.previewBlockCtx;
    if (sourceCanvas.width !== blockSize || sourceCanvas.height !== blockSize) {
      sourceCanvas.width = blockSize;
      sourceCanvas.height = blockSize;
    }
    sourceCtx.clearRect(0, 0, sourceCanvas.width, sourceCanvas.height);
    drawBlockSized(sourceCtx, 0, 0, blockSize, color, node, transform);
    ctx.drawImage(sourceCanvas, targetX, targetY, targetSize, targetSize);
  };
  const drawPreviewShape = (shape, originX, boxY, cellSize, areaH, boxW, transforms = null) => {
    if (!shape || !SHAPES[shape]) return;
    const preview = SHAPES[shape][0];
    let minX = 99;
    let minY = 99;
    let maxX = -99;
    let maxY = -99;
    for (const [px, py] of preview) {
      if (px < minX) minX = px;
      if (py < minY) minY = py;
      if (px > maxX) maxX = px;
      if (py > maxY) maxY = py;
    }
    const shapeW = maxX - minX + 1;
    const shapeH = maxY - minY + 1;
    const areaW = (boxW ?? previewBox) - innerPad * 2;
    const contentH = Math.max(0, areaH - innerPad * 2);
    const offX = Math.round((areaW - shapeW * cellSize) / 2);
    const offY = Math.round((contentH - shapeH * cellSize) / 2);
    preview.forEach(([px, py], index) => {
      const gx = px - minX;
      const gy = py - minY;
      drawScaledBlock(
        originX + innerPad + offX + gx * cellSize,
        boxY + innerPad + offY + gy * cellSize,
        cellSize,
        palette[shape],
        transforms?.[index] ?? null,
      );
    });
  };

  const previewContentH = Math.max(4, previewBox);
  const nextCellSize = Math.max(4, Math.floor((previewContentH - innerPad * 2) / PREVIEW_GRID));
  const showHoldPanel = showHold && !hideBoard;
  const showNextPanel = showNext && !hideBoard;
  if (showHoldPanel) {
    drawPanelBox(ctx, node, leftBoxX, nextBoxY, leftBoxW, previewBox, theme.panel_bg, theme.panel_border);
    if (showPreviews) {
      const holdTransforms = getPreviewTextureTransforms(state, state.holdShape, "hold");
      drawPreviewShape(
        state.holdShape,
        leftBoxX,
        nextBoxY,
        nextCellSize,
        previewContentH,
        leftBoxW,
        holdTransforms,
      );
    }
    ctx.fillStyle = theme.text;
    ctx.font = `bold ${titleFontSize}px sans-serif`;
    ctx.fillText("Hold", leftBoxX + titleInset, holdNextTitleY);
  }
  if (showNextPanel) {
    drawPanelBox(ctx, node, rightBoxX, nextBoxY, rightBoxW, previewBox, theme.panel_bg, theme.panel_border);
    if (showPreviews) {
      const nextTransforms = getPreviewTextureTransforms(state, state.nextShape, "next");
      drawPreviewShape(
        state.nextShape,
        rightBoxX,
        nextBoxY,
        nextCellSize,
        previewContentH,
        rightBoxW,
        nextTransforms,
      );
    }
    ctx.fillStyle = theme.text;
    ctx.font = `bold ${titleFontSize}px sans-serif`;
    ctx.fillText("Next", rightBoxX + titleInset, holdNextTitleY);
  }

  const queueCountTarget = showNextPanel ? getQueueSize(node) : 0;
  const showQueue = queueCountTarget > 0;
  const queueBoxY = nextBoxY + previewBox + PADDING * 1.2;
  const queueBoxW = rightBoxW;
  const queueBoxX = rightBoxX;
  const queueTitleY = queueBoxY + titleFontSize + 4;
  const upcoming = getUpcomingShapes(state, queueCountTarget + 1);
  const queue = upcoming.slice(1, queueCountTarget + 1);
  const queueGapCells = 1;
  const queueContentY = queueBoxY + titleHeight;
  const availableQueueHeight = Math.max(0, boardY + boardH - queueBoxY);
  const queueCount = Math.min(queue.length, queueCountTarget);
  const getShapeBounds = (shape) => {
    const cells = SHAPES[shape]?.[0] || [];
    if (!cells.length) return null;
    let minX = 99;
    let minY = 99;
    let maxX = -99;
    let maxY = -99;
    for (const [px, py] of cells) {
      if (px < minX) minX = px;
      if (py < minY) minY = py;
      if (px > maxX) maxX = px;
      if (py > maxY) maxY = py;
    }
    return {
      minX,
      minY,
      width: maxX - minX + 1,
      height: maxY - minY + 1,
    };
  };
  const boundsList = queue
    .slice(0, queueCount)
    .map((shape) => getShapeBounds(shape))
    .filter(Boolean);
  const shapeHeights = boundsList.map((bounds) => bounds.height);
  const shapeWidths = boundsList.map((bounds) => bounds.width);
  const totalCells =
    shapeHeights.reduce((sum, h) => sum + h, 0) + Math.max(0, queueCount - 1) * queueGapCells;
  const maxShapeWidth = shapeWidths.length ? Math.max(...shapeWidths) : PREVIEW_GRID;
  const availableInnerH = Math.max(0, availableQueueHeight - titleHeight - innerPad * 2);
  const maxCellByHeight = totalCells > 0 ? Math.floor(availableInnerH / totalCells) : 0;
  const maxCellByWidth = Math.floor((queueBoxW - innerPad * 2) / maxShapeWidth);
  let queueCellSize = Math.max(4, Math.min(maxCellByHeight, maxCellByWidth));
  let drawQueueCount = queueCellSize > 0 ? boundsList.length : 0;
  const previewBottom = nextBoxY + previewBox;
  let queueBottom =
    showQueue && drawQueueCount > 0
      ? queueBoxY + availableQueueHeight
      : previewBottom;
  const minInfoY = queueBottom + PADDING * 1.6 + 22;
  const maxInfoY = boardY + boardH - infoBlockHeight;
  const infoY = maxInfoY < minInfoY ? maxInfoY : Math.max(minInfoY, maxInfoY);
  const baseInfoY = infoY;
  if (showQueue && drawQueueCount > 0) {
    queueBottom = baseInfoY;
  }
  const outlineHeight = showQueue && drawQueueCount > 0
    ? Math.max(0, queueBottom - queueBoxY)
    : 0;
  if (showQueue && drawQueueCount > 0) {
    const availableInnerH2 = Math.max(0, outlineHeight - titleHeight - innerPad * 2);
    const maxCellByHeight2 = totalCells > 0 ? Math.floor(availableInnerH2 / totalCells) : 0;
    queueCellSize = Math.max(4, Math.min(maxCellByHeight2, maxCellByWidth));
    drawQueueCount = queueCellSize > 0 ? boundsList.length : 0;
  }
  if (showQueue && drawQueueCount > 0) {
    drawPanelBox(ctx, node, queueBoxX, queueBoxY, queueBoxW, outlineHeight, theme.panel_bg, theme.panel_border);
    ctx.fillStyle = theme.text;
    ctx.font = `bold ${titleFontSize}px sans-serif`;
    ctx.fillText("Queue", rightBoxX + titleInset, queueTitleY);
  }
  let cursorY = queueContentY + innerPad;
  boundsList.slice(0, drawQueueCount).forEach((bounds, idx) => {
    const shape = queue[idx];
    if (!shape || !SHAPES[shape]) return;
    if (!showPreviews) return;
    const queueTransforms = getPreviewTextureTransforms(state, shape, `queue-${idx}`);
    const shapeOffsetX = Math.max(
      0,
      Math.floor(
        (queueBoxW - innerPad * 2 - bounds.width * queueCellSize) / 2,
      ),
    );
    SHAPES[shape][0].forEach(([px, py], index) => {
      const gx = px - bounds.minX;
      const gy = py - bounds.minY;
      drawScaledBlock(
        queueBoxX + innerPad + shapeOffsetX + gx * queueCellSize,
        cursorY + gy * queueCellSize,
        queueCellSize,
        palette[shape],
        queueTransforms[index] ?? null,
      );
    });
    cursorY += bounds.height * queueCellSize;
    if (idx < drawQueueCount - 1) {
      cursorY += queueGapCells * queueCellSize;
    }
  });

  if (controlEntries.length) {
    ctx.fillStyle = theme.text;
    ctx.font = `bold ${titleFontSize}px sans-serif`;
    const tableY = baseInfoY;
    const tableX = leftBoxX;
    const tableW = leftBoxW;
    const tableH = Math.max(0, boardY + boardH - tableY);
    drawPanelBox(ctx, node, tableX, tableY, tableW, tableH, theme.panel_bg, theme.panel_border);
    ctx.fillStyle = theme.text;
    ctx.fillText("Controls", tableX + titleInset, tableY + titleFontSize + 4);
    ctx.font = `${fontSize}px sans-serif`;
    let rowY = tableY + titleHeight + tablePad + Math.floor(fontSize * 0.25);
    for (const row of controlRows) {
      const labelX = tableX + controlsPad + leftColWidth;
      ctx.textAlign = "right";
      ctx.fillText(row.label, labelX, rowY);
      ctx.textAlign = "left";
      const valueX = tableX + controlsPad + leftColWidth + tableGap;
      for (let i = 0; i < row.lines.length; i += 1) {
        const lineY = rowY + i * lineHeight;
        ctx.fillText(row.lines[i], valueX, lineY);
      }
      rowY += row.lines.length * lineHeight;
    }
    ctx.textAlign = "left";
  }

  if (state.gameOver) {
    drawPauseOverlay(ctx, node, boardX, boardY, boardW, boardH, blockSize, bindings, {
      label: "Game Over",
      sublabel: `Press Reset or ${formatPauseHint(bindings)} to play`,
      centerOffsetY: 0,
    });
  } else if (!state.running && state.showBoardWhilePaused) {
    drawPauseOverlay(ctx, node, boardX, boardY, boardW, boardH, blockSize, bindings, {
      label: "Paused",
      sublabel: `Press ${formatPauseHint(bindings)} to resume`,
      centerOffsetY: 0,
    });
  } else if (!state.running && !state.showBoardWhilePaused) {
    const label = state.started ? "Paused" : "Start a new game";
    const sublabel = state.started
      ? `Press ${formatPauseHint(bindings)} to resume`
      : "Press Reset or Pause to play";
    drawPauseOverlay(ctx, node, boardX, boardY, boardW, boardH, blockSize, bindings, {
      label,
      sublabel,
      centerOffsetY: 0,
    });
  }

  drawStatusMessage(node, ctx, { boardX, boardY, boardW, boardH, blockSize, bindings });
  drawToolbar(node, ctx, boardY);
}

function formatPauseHint(bindings) {
  const pauseLabel = formatKeyLabel(bindings.pause?.[0]) || "Pause";
  const pauseAlt = formatKeyLabel(bindings.pause?.[1]);
  return pauseAlt ? `${pauseLabel} (or ${pauseAlt})` : pauseLabel;
}

function drawPauseOverlay(ctx, node, boardX, boardY, boardW, boardH, blockSize, bindings, opts) {
  const { label, sublabel, centerOffsetY } = opts;
  ctx.fillStyle = COLORS.Overlay;
  ctx.fillRect(boardX, boardY, boardW, boardH);
  ctx.fillStyle = getThemeColors(node).text;
  const statusFont = Math.max(12, Math.floor(blockSize * 0.8));
  const subFont = Math.max(10, Math.floor(blockSize * 0.55));
  const centerY = boardY + boardH / 2 + (centerOffsetY || 0);
  ctx.font = `${statusFont}px sans-serif`;
  ctx.fillText(label, boardX + 28, centerY - Math.floor(subFont));
  ctx.font = `${subFont}px sans-serif`;
  ctx.fillText(sublabel, boardX + 28, centerY + subFont);
}

function formatThemeName(theme) {
  if (!theme) return "";
  return theme.charAt(0).toUpperCase() + theme.slice(1);
}

function formatThemeKeyLabel(key) {
  if (!key) return "";
  const renamed = key.replace("bg", "background");
  return renamed
    .split("_")
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
}

function hslToRgbaString(h, s, l, a) {
  const rgb = hslToRgb(h, s, l);
  return rgbaString({ r: rgb.r, g: rgb.g, b: rgb.b, a }, true);
}

function buildThemePaletteFromSwatch(hex, themeName) {
  const parsed = parseColorComponents(hex);
  const hsl = rgbToHsl(parsed.r, parsed.g, parsed.b);
  const hue = hsl.h;
  const sat = hsl.s;
  const baseLight = hsl.l;
  const isGlass = themeName === "glass";
  const isMinimal = themeName === "minimal";
  const isNeon = themeName === "neon";
  const panelBgAlpha = isGlass ? 0.82 : isMinimal ? 0.9 : 0.92;
  const panelBgLight = Math.max(10, Math.min(18, baseLight * 0.25));
  const panelBgSat = Math.max(8, Math.min(40, sat * 0.4));
  const panelBorderLight = Math.max(45, Math.min(80, baseLight + 5));
  const panelBorderSat = Math.max(25, Math.min(85, sat * 0.8 + 10));
  const panelShadowLight = Math.max(4, Math.min(12, baseLight * 0.2));
  return {
    panel_bg: hslToRgbaString(hue, panelBgSat, panelBgLight, panelBgAlpha),
    panel_border: hslToRgbaString(hue, panelBorderSat, panelBorderLight, isNeon ? 0.45 : 0.25),
    panel_shadow: hslToRgbaString(hue, Math.max(5, panelBgSat * 0.3), panelShadowLight, 0.35),
    button: hex,
    text: "#FFFFFF",
    button_bg: hslToRgbaString(hue, Math.min(80, sat), Math.max(20, Math.min(55, baseLight)), 0.12),
    button_hover: hslToRgbaString(
      hue,
      Math.min(85, sat),
      Math.max(30, Math.min(65, baseLight + 8)),
      0.24,
    ),
    accent: hex,
  };
}

function colorToHex(value, allowAlpha) {
  const parsed = parseColorComponents(value || "");
  if (!parsed) return "";
  return allowAlpha
    ? rgbToHex8(parsed.r, parsed.g, parsed.b, parsed.a)
    : rgbToHex6(parsed.r, parsed.g, parsed.b);
}

function getContrastTextColor(value) {
  const parsed = parseColorComponents(value || "");
  if (!parsed) return "#fff";
  const r = parsed.r / 255;
  const g = parsed.g / 255;
  const b = parsed.b / 255;
  const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
  return luminance > 0.6 ? "#000" : "#fff";
}

function toOpaqueColor(value) {
  const parsed = parseColorComponents(value || "");
  if (!parsed) return "#000";
  return rgbaString({ ...parsed, a: 1 }, true);
}

function applySwatchBackground(element, value, showCheckerboard) {
  const parsed = parseColorComponents(value || "");
  const alpha = parsed?.a ?? 1;
  const checkerboardBg =
    "linear-gradient(45deg, rgba(255,255,255,0.25) 25%, transparent 25%)," +
    "linear-gradient(-45deg, rgba(255,255,255,0.25) 25%, transparent 25%)," +
    "linear-gradient(45deg, transparent 75%, rgba(255,255,255,0.25) 75%)," +
    "linear-gradient(-45deg, transparent 75%, rgba(255,255,255,0.25) 75%)";
  element.style.backgroundSize = "10px 10px";
  element.style.backgroundPosition = "0 0, 0 5px, 5px -5px, -5px 0px";
  element.style.backgroundImage = showCheckerboard && alpha < 1 ? checkerboardBg : "none";
  element.style.backgroundColor = rgbaString(parsed, true);
}

function getThemeCornerRadius(node) {
  const config = getConfig(node);
  const settings = config.theme_settings || DEFAULT_CONFIG.theme_settings;
  if (config.theme === "glass") return settings.glass_radius ?? 6;
  if (config.theme === "neon") return settings.neon_radius ?? 6;
  if (config.theme === "flat" || config.theme === "minimal") return 0;
  return 6;
}

function drawPanelBox(ctx, node, x, y, w, h, fillColor, strokeColor) {
  const config = getConfig(node);
  const radius = getThemeCornerRadius(node);
  ctx.fillStyle = fillColor;
  const drawStroke = config.theme !== "flat";
  if (drawStroke) {
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 1;
    applyBorderGlow(ctx, node);
  }
  if (radius > 0 && typeof ctx.roundRect === "function") {
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, radius);
    ctx.fill();
    if (drawStroke) ctx.stroke();
  } else {
    ctx.fillRect(x, y, w, h);
    if (drawStroke) ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);
  }
  if (drawStroke) clearBorderGlow(ctx);
}

function applyModalThemeStyles(node, container) {
  if (!container) return;
  const config = getConfig(node);
  const theme = getThemeColors(node);
  const isFlat = config.theme === "flat";
  const isMinimal = config.theme === "minimal";
  const isNeon = config.theme === "neon";
  const themeSettings = config.theme_settings || DEFAULT_CONFIG.theme_settings;
  const radius = getThemeCornerRadius(node);
  const useBorders = !isFlat && !isMinimal;
  const applyButtonStyle = (btn, variant) => {
    const isGlass = config.theme === "glass";
    const isActive = btn.dataset.tnActive === "true";
    const isHover = variant === "hover";
    const isTab = btn.dataset.tnTab === "true";
    if (isTab) {
      const bg = isActive ? theme.button_hover : theme.button_bg;
      btn.style.setProperty("background", bg, "important");
      btn.style.setProperty(
        "border",
        useBorders ? `1px solid ${theme.panel_border}` : "none",
        "important",
      );
      if (useBorders) {
        btn.style.setProperty("border-bottom-color", theme.panel_bg, "important");
      }
      btn.style.setProperty(
        "box-shadow",
        isNeon ? `0 0 ${themeSettings.neon_glow ?? 8}px ${theme.panel_border}` : "none",
        "important",
      );
      btn.style.setProperty("color", theme.text, "important");
      btn.style.setProperty("webkit-text-fill-color", theme.text, "important");
      const radiusValue = `${radius}px ${radius}px 0 0`;
      btn.style.setProperty("border-radius", radiusValue, "important");
      btn.style.setProperty("display", "inline-flex", "important");
      btn.style.setProperty("align-items", "center", "important");
      btn.style.setProperty("justify-content", "center", "important");
      btn.style.setProperty("gap", "6px", "important");
      btn.style.setProperty("height", "26px", "important");
      btn.style.setProperty("padding", "0 12px", "important");
      btn.style.setProperty("font-size", "11px", "important");
      btn.style.setProperty("line-height", "1", "important");
      btn.style.setProperty("cursor", "pointer", "important");
      btn.style.setProperty("opacity", "1", "important");
      btn.style.setProperty("margin-bottom", isActive ? "-1px" : "0", "important");
      return;
    }
    if (isGlass) {
      const gradBase =
        "linear-gradient(180deg, rgba(255,255,255,0.45) 0%, rgba(255,255,255,0.22) 45%, rgba(255,255,255,0.08) 100%)";
      const gradHover =
        "linear-gradient(180deg, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0.3) 45%, rgba(255,255,255,0.12) 100%)";
      const gradActive =
        "linear-gradient(180deg, rgba(255,255,255,0.7) 0%, rgba(255,255,255,0.35) 45%, rgba(255,255,255,0.16) 100%)";
      const gradient = isActive ? gradActive : isHover ? gradHover : gradBase;
      const border = isActive ? "1px solid rgba(255,255,255,0.7)" : "1px solid rgba(255,255,255,0.45)";
      const glow = isActive ? "0 0 8px rgba(255,255,255,0.35)" : "0 2px 6px rgba(0,0,0,0.25)";
      btn.style.setProperty("background", gradient, "important");
      btn.style.setProperty("border", border, "important");
      btn.style.setProperty(
        "box-shadow",
        `inset 0 1px 0 rgba(255,255,255,0.65), ${glow}`,
        "important",
      );
      btn.style.setProperty("background-clip", "padding-box", "important");
    } else {
      const bg = isActive ? theme.button_hover : isHover ? theme.button_hover : theme.button_bg;
      btn.style.setProperty("background", bg, "important");
      btn.style.setProperty(
        "border",
        useBorders ? `1px solid ${theme.panel_border}` : "none",
        "important",
      );
      btn.style.setProperty(
        "box-shadow",
        isNeon ? `0 0 ${themeSettings.neon_glow ?? 8}px ${theme.panel_border}` : "none",
        "important",
      );
    }
    btn.style.setProperty("color", theme.text, "important");
    btn.style.setProperty("webkit-text-fill-color", theme.text, "important");
    btn.style.setProperty("border-radius", `${radius}px`, "important");
    btn.style.setProperty("display", "inline-flex", "important");
    btn.style.setProperty("align-items", "center", "important");
    btn.style.setProperty("justify-content", "center", "important");
    btn.style.setProperty("gap", "6px", "important");
    btn.style.setProperty("height", "24px", "important");
    btn.style.setProperty("padding", "0 10px", "important");
    btn.style.setProperty("font-size", "11px", "important");
    btn.style.setProperty("line-height", "1", "important");
    btn.style.setProperty("cursor", "pointer", "important");
    btn.style.setProperty("opacity", "1", "important");
  };
  container.querySelectorAll("button").forEach((btn) => {
    if (btn.dataset.tnSwatch === "true") return;
    applyButtonStyle(btn, "base");
    if (!btn.dataset.tnHoverBound) {
      btn.dataset.tnHoverBound = "true";
      btn.addEventListener("mouseenter", () => {
        if (btn.dataset.tnActive === "true") return;
        applyButtonStyle(btn, "hover");
      });
      btn.addEventListener("mouseleave", () => {
        applyButtonStyle(btn, "base");
      });
    }
  });
  container.querySelectorAll("input, select, textarea").forEach((input) => {
    input.style.background = theme.button_bg;
    input.style.color = theme.text;
    input.style.border = useBorders ? `1px solid ${theme.panel_border}` : "none";
    input.style.borderRadius = "6px";
    if (input.tagName === "SELECT") {
      input.style.background = toOpaqueColor(theme.panel_bg);
      input.querySelectorAll("option").forEach((option) => {
        option.style.background = toOpaqueColor(theme.panel_bg);
        option.style.color = theme.text;
      });
    }
  });
}

function getLoadIconPath() {
  if (LOAD_ICON_PATH2D) return LOAD_ICON_PATH2D;
  if (!window.Path2D) return null;
  try {
    LOAD_ICON_PATH2D = new Path2D(LOAD_ICON_PATH);
  } catch {
    LOAD_ICON_PATH2D = null;
  }
  return LOAD_ICON_PATH2D;
}

function drawLoadIcon(ctx, x, y, size, color) {
  const path = getLoadIconPath();
  if (!path) return false;
  ctx.save();
  ctx.translate(x, y);
  const scale = size / LOAD_ICON_VIEWBOX;
  ctx.scale(scale, scale);
  ctx.fillStyle = color;
  ctx.fill(path);
  ctx.restore();
  return true;
}

function drawSaveIcon(ctx, x, y, size, color) {
  const path = getLoadIconPath();
  if (!path) return false;
  ctx.save();
  const scale = size / LOAD_ICON_VIEWBOX;
  ctx.translate(x + size / 2, y + size / 2);
  ctx.scale(scale, scale);
  ctx.rotate(Math.PI);
  ctx.translate(-LOAD_ICON_VIEWBOX / 2, -LOAD_ICON_VIEWBOX / 2);
  ctx.fillStyle = color;
  ctx.fill(path);
  ctx.restore();
  return true;
}

function getResetIconPath() {
  if (RESET_ICON_PATH2D) return RESET_ICON_PATH2D;
  if (!window.Path2D) return null;
  try {
    RESET_ICON_PATH2D = new Path2D(RESET_ICON_PATH);
  } catch {
    RESET_ICON_PATH2D = null;
  }
  return RESET_ICON_PATH2D;
}

function drawResetIcon(ctx, x, y, size, color) {
  const path = getResetIconPath();
  if (!path) return false;
  ctx.save();
  ctx.translate(x, y);
  const scale = size / RESET_ICON_VIEWBOX;
  ctx.scale(scale, scale);
  ctx.fillStyle = color;
  ctx.fill(path);
  ctx.restore();
  return true;
}

function getPauseIconPath() {
  if (PAUSE_ICON_PATH2D) return PAUSE_ICON_PATH2D;
  if (!window.Path2D) return null;
  try {
    PAUSE_ICON_PATH2D = new Path2D(PAUSE_ICON_PATH);
  } catch {
    PAUSE_ICON_PATH2D = null;
  }
  return PAUSE_ICON_PATH2D;
}

function drawPauseIcon(ctx, x, y, size, color) {
  const path = getPauseIconPath();
  if (!path) return false;
  ctx.save();
  ctx.translate(x, y);
  const scale = size / PAUSE_ICON_VIEWBOX;
  ctx.scale(scale, scale);
  ctx.fillStyle = color;
  ctx.fill(path);
  ctx.restore();
  return true;
}

function getPlayIconPath() {
  if (PLAY_ICON_PATH2D) return PLAY_ICON_PATH2D;
  if (!window.Path2D) return null;
  try {
    PLAY_ICON_PATH2D = new Path2D(PLAY_ICON_PATH);
  } catch {
    PLAY_ICON_PATH2D = null;
  }
  return PLAY_ICON_PATH2D;
}

function drawPlayIcon(ctx, x, y, size, color) {
  const path = getPlayIconPath();
  if (!path) return false;
  ctx.save();
  ctx.translate(x, y);
  const scale = size / PLAY_ICON_VIEWBOX;
  ctx.scale(scale, scale);
  ctx.fillStyle = color;
  ctx.fill(path);
  ctx.restore();
  return true;
}

function getSettingsIconPath() {
  if (SETTINGS_ICON_PATH2D) return SETTINGS_ICON_PATH2D;
  if (!window.Path2D) return null;
  try {
    SETTINGS_ICON_PATH2D = new Path2D(SETTINGS_ICON_PATH);
  } catch {
    SETTINGS_ICON_PATH2D = null;
  }
  return SETTINGS_ICON_PATH2D;
}

function drawSettingsIcon(ctx, x, y, size, color) {
  const path = getSettingsIconPath();
  if (!path) return false;
  ctx.save();
  ctx.translate(x, y);
  const scale = size / SETTINGS_ICON_VIEWBOX;
  ctx.scale(scale, scale);
  ctx.fillStyle = color;
  ctx.fill(path);
  ctx.restore();
  return true;
}

function applyBorderGlow(ctx, node) {
  const config = getConfig(node);
  if (config.theme !== "neon") return;
  const theme = getThemeColors(node);
  const settings = config.theme_settings || DEFAULT_CONFIG.theme_settings;
  ctx.shadowColor = theme.panel_border;
  ctx.shadowBlur = settings.neon_glow || 8;
}

function clearBorderGlow(ctx) {
  ctx.shadowColor = "transparent";
  ctx.shadowBlur = 0;
}

function drawStatusMessage(node, ctx, layout) {
  const msg = node.__tetrisStatusMessage;
  if (!msg) return;
  if (performance.now() > msg.until) {
    node.__tetrisStatusMessage = null;
    return;
  }
  const { boardX, boardY, boardW, boardH, blockSize, bindings } = layout;
  const pauseHint = formatPauseHint(bindings);
  drawPauseOverlay(ctx, node, boardX, boardY, boardW, boardH, blockSize, bindings, {
    label: "Paused",
    sublabel: `Press ${pauseHint} to resume`,
    centerOffsetY: 0,
  });
  const text = msg.text || "";
  if (!text) return;
  ctx.save();
  ctx.font = "12px sans-serif";
  const paddingX = 10;
  const paddingY = 6;
  const width = ctx.measureText(text).width + paddingX * 2;
  const height = 20 + paddingY;
  const x = boardX + (boardW - width) / 2;
  const y = boardY + 100 - height / 2;
  ctx.fillStyle = msg.kind === "error" ? "rgba(180,60,60,0.85)" : "rgba(30,120,60,0.85)";
  ctx.fillRect(x, y, width, height);
  ctx.fillStyle = "#fff";
  ctx.fillText(text, x + paddingX, y + height - 8);
  ctx.restore();
}

function getThemeColors(node) {
  const config = getConfig(node);
  const theme = config.theme && config.theme_colors?.[config.theme] ? config.theme : "glass";
  return config.theme_colors?.[theme] || THEME_PRESETS[theme];
}

function ensureUiState(node) {
  if (!node.__tetrisUi) {
    node.__tetrisUi = {
      toolbarButtons: [],
      hoverButton: null,
      modal: null,
      captureAction: null,
      confirmPrompt: null,
      blockStylePreset: "Flat (default)",
      blockStylePresetBaseFull: "Flat (default)",
      blockStylePresetBaseLabel: "Flat",
    };
  }
  return node.__tetrisUi;
}

function buildToolbarButtons(node, toolbarY, barH) {
  const btnSize = 24;
  const gap = 8;
  const top = toolbarY + (barH - btnSize) / 2;
  const leftStart = PADDING + 6;
  const rightStart = node.size[0] - PADDING - 6;
  const leftButtons = [
    { id: "load", label: "L", tooltip: "Load State" },
    { id: "save", label: "S", tooltip: "Save State" },
    { id: "reset", label: "R", tooltip: "Reset" },
    { id: "pause", label: "P", tooltip: "Pause/Play" },
  ];
  const rightButtons = [
    { id: "settings", label: "S", tooltip: "Settings" },
  ];
  const buttons = [];
  let x = leftStart;
  for (const btn of leftButtons) {
    buttons.push({ ...btn, x, y: top, w: btnSize, h: btnSize });
    x += btnSize + gap;
  }
  let rightX = rightStart;
  for (const btn of rightButtons) {
    rightX -= btnSize;
    buttons.push({ ...btn, x: rightX, y: top, w: btnSize, h: btnSize });
    rightX -= gap;
  }
  return { buttons, height: TOOLBAR_H, top };
}

function drawToolbar(node, ctx, boardY) {
  const ui = ensureUiState(node);
  const config = getConfig(node);
  const theme = getThemeColors(node);
  const themeSettings = config.theme_settings || DEFAULT_CONFIG.theme_settings;
  const live = node.__tetrisLive;
  const state = live?.state;
  const isPlaying = !!(state && state.running && state.started && !state.gameOver);
  const pauseTooltip = isPlaying ? "Pause" : "Play";
  const desiredY = boardY - TOOLBAR_H - 10;
  const barY = Math.max(HEADER_H + 2, Math.round(desiredY));
  const barX = PADDING;
  const barW = node.size[0] - PADDING * 2;
  const barH = TOOLBAR_H - 6;
  const { buttons } = buildToolbarButtons(node, barY, barH);
  ui.toolbarButtons = buttons;
  ui.toolbarRect = { x: barX, y: barY, w: barW, h: barH };
  ctx.save();
  ctx.fillStyle = theme.panel_bg;
  ctx.strokeStyle = theme.panel_border;
  ctx.lineWidth = 1;
  if (config.theme === "neon") {
    ctx.shadowColor = theme.panel_border;
    ctx.shadowBlur = themeSettings.neon_glow || 8;
  }
  if ((config.theme === "glass" || config.theme === "neon") && typeof ctx.roundRect === "function") {
    const radius = getThemeCornerRadius(node);
    ctx.beginPath();
    ctx.roundRect(barX, barY, barW, barH, radius);
    ctx.fill();
    if (config.theme !== "flat" && config.theme !== "minimal") {
      ctx.stroke();
    }
  } else if (config.theme !== "minimal") {
    ctx.fillRect(barX, barY, barW, barH);
    if (config.theme !== "flat") {
      ctx.strokeRect(barX + 0.5, barY + 0.5, barW - 1, barH - 1);
    }
  }
  ctx.font = "12px sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  for (const btn of buttons) {
    if (btn.id === "pause") {
      btn.tooltip = pauseTooltip;
    }
    const hovered = ui.hoverButton && ui.hoverButton.id === btn.id;
    const iconColor = theme.button || theme.text;
    if (config.theme === "glass") {
      const radius = themeSettings.glass_radius ?? 6;
      const grad = ctx.createLinearGradient(0, btn.y, 0, btn.y + btn.h);
      const gradBase =
        "linear-gradient(180deg, rgba(255,255,255,0.45) 0%, rgba(255,255,255,0.22) 45%, rgba(255,255,255,0.08) 100%)";
      const gradHover =
        "linear-gradient(180deg, rgba(255,255,255,0.7) 0%, rgba(255,255,255,0.35) 45%, rgba(255,255,255,0.16) 100%)";
      const stops = (hovered ? gradHover : gradBase).match(/rgba\([^)]+\)/g) || [];
      grad.addColorStop(0, stops[0] || "rgba(255,255,255,0.45)");
      grad.addColorStop(0.45, stops[1] || "rgba(255,255,255,0.22)");
      grad.addColorStop(1, stops[2] || "rgba(255,255,255,0.08)");
      ctx.fillStyle = grad;
      if (typeof ctx.roundRect === "function") {
        ctx.beginPath();
        ctx.roundRect(btn.x, btn.y, btn.w, btn.h, radius);
        ctx.fill();
      } else {
        ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
      }
      if (typeof ctx.roundRect === "function") {
        const borderWidth = 1;
        const lightStroke = "rgba(255,255,255,0.7)";
        const baseStroke = "rgba(255,255,255,0.7)";
        const outerX = btn.x + 0.5;
        const outerY = btn.y + 0.5;
        const outerW = btn.w - 1;
        const outerH = btn.h - 1;
        const innerX = btn.x + 0.5;
        const innerY = outerY + borderWidth;
        const innerW = outerW;
        const innerH = outerH - borderWidth;
        const innerRadius = Math.max(0, radius - borderWidth);
        ctx.lineWidth = borderWidth;
        ctx.strokeStyle = lightStroke;
        ctx.beginPath();
        ctx.roundRect(innerX, innerY, innerW, innerH, innerRadius);
        ctx.stroke();
        ctx.strokeStyle = baseStroke;
        ctx.beginPath();
        ctx.roundRect(outerX, outerY, outerW, outerH, radius);
        ctx.stroke();
      } else {
        ctx.strokeStyle = hovered ? "rgba(255,255,255,0.7)" : "rgba(255,255,255,0.45)";
        ctx.strokeRect(btn.x + 0.5, btn.y + 0.5, btn.w - 1, btn.h - 1);
      }
    } else if (config.theme === "neon") {
      const radius = getThemeCornerRadius(node);
      ctx.fillStyle = hovered ? theme.button_hover : theme.button_bg;
      if (typeof ctx.roundRect === "function") {
        ctx.beginPath();
        ctx.roundRect(btn.x, btn.y, btn.w, btn.h, radius);
        ctx.fill();
      } else {
        ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
      }
    } else {
      ctx.fillStyle = hovered ? theme.button_hover : theme.button_bg;
      ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
    }
    if (config.theme !== "flat") {
      ctx.strokeStyle = theme.panel_border;
      if ((config.theme === "glass" || config.theme === "neon") && typeof ctx.roundRect === "function") {
        const radius = getThemeCornerRadius(node);
        ctx.beginPath();
        ctx.roundRect(btn.x + 0.5, btn.y + 0.5, btn.w - 1, btn.h - 1, radius);
        ctx.stroke();
      } else {
        ctx.strokeRect(btn.x + 0.5, btn.y + 0.5, btn.w - 1, btn.h - 1);
      }
    }
    ctx.fillStyle = theme.text;
    if (btn.id === "load") {
      const iconSize = Math.floor(btn.w * 0.82);
      const iconX = btn.x + (btn.w - iconSize) / 2;
      const iconY = btn.y + (btn.h - iconSize) / 2;
      if (!drawLoadIcon(ctx, iconX, iconY, iconSize, iconColor)) {
        ctx.fillText(btn.label, btn.x + btn.w / 2, btn.y + btn.h / 2 + 0.5);
      }
    } else if (btn.id === "save") {
      const iconSize = Math.floor(btn.w * 0.82);
      const iconX = btn.x + (btn.w - iconSize) / 2;
      const iconY = btn.y + (btn.h - iconSize) / 2;
      if (!drawSaveIcon(ctx, iconX, iconY, iconSize, iconColor)) {
        ctx.fillText(btn.label, btn.x + btn.w / 2, btn.y + btn.h / 2 + 0.5);
      }
    } else if (btn.id === "reset") {
      const iconSize = Math.floor(btn.w * 0.82);
      const iconX = btn.x + (btn.w - iconSize) / 2;
      const iconY = btn.y + (btn.h - iconSize) / 2;
      if (!drawResetIcon(ctx, iconX, iconY, iconSize, iconColor)) {
        ctx.fillText(btn.label, btn.x + btn.w / 2, btn.y + btn.h / 2 + 0.5);
      }
    } else if (btn.id === "pause") {
      const iconSize = Math.floor(btn.w * 0.75);
      const iconX = btn.x + (btn.w - iconSize) / 2;
      const iconY = btn.y + (btn.h - iconSize) / 2;
      const drew = isPlaying
        ? drawPauseIcon(ctx, iconX, iconY, iconSize, iconColor)
        : drawPlayIcon(ctx, iconX, iconY, iconSize, iconColor);
      if (!drew) {
        ctx.fillText(btn.label, btn.x + btn.w / 2, btn.y + btn.h / 2 + 0.5);
      }
    } else if (btn.id === "settings") {
      const iconSize = Math.floor(btn.w * 0.7);
      const iconX = btn.x + (btn.w - iconSize) / 2;
      const iconY = btn.y + (btn.h - iconSize) / 2;
      if (!drawSettingsIcon(ctx, iconX, iconY, iconSize, iconColor)) {
        ctx.fillText(btn.label, btn.x + btn.w / 2, btn.y + btn.h / 2 + 0.5);
      }
    } else {
      ctx.fillText(btn.label, btn.x + btn.w / 2, btn.y + btn.h / 2 + 0.5);
    }
  }
  if (ui.hoverButton?.tooltip) {
    const tooltip = ui.hoverButton.tooltip;
    ctx.font = "11px sans-serif";
    const padding = 6;
    const width = ctx.measureText(tooltip).width + padding * 2;
    const height = 20;
    const tipX = Math.min(node.size[0] - width - 8, ui.hoverButton.x + ui.hoverButton.w / 2 - width / 2);
    const tipY = barY + barH + 6;
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(tipX, tipY, width, height);
    ctx.fillStyle = "#fff";
    ctx.fillText(tooltip, tipX + width / 2, tipY + height / 2 + 0.5);
  }
  ctx.restore();
}

function hitToolbarButton(node, pos, boardY = null) {
  const ui = ensureUiState(node);
  if (!ui.toolbarButtons?.length) {
    const fallbackY = boardY ?? node.__tetrisLastLayout?.boardY ?? (HEADER_H + TOOLBAR_H + 10);
    const barY = Math.max(HEADER_H + 2, fallbackY - TOOLBAR_H - 10);
    const metrics = buildToolbarButtons(node, barY, TOOLBAR_H - 6);
    ui.toolbarButtons = metrics.buttons;
  }
  const [x, y] = pos;
  return ui.toolbarButtons.find(
    (btn) => x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h,
  );
}

function handleToolbarClick(node, pos) {
  const btn = hitToolbarButton(node, pos, node.__tetrisLastLayout?.boardY);
  if (!btn) return false;
  if (btn.id === "reset") {
    resetNode(node);
    return true;
  }
  if (btn.id === "pause") {
    togglePause(node);
    return true;
  }
  if (btn.id === "load") {
    openLoadStateModal(node);
    return true;
  }
  if (btn.id === "save") {
    openSaveStateModal(node);
    return true;
  }
  if (btn.id === "settings") {
    openSettingsModal(node);
    return true;
  }
  return false;
}

function closeModal(node) {
  const ui = ensureUiState(node);
  if (ui.modal?.el) {
    ui.modal.el.remove();
  }
  ui.modal = null;
  ui.captureAction = null;
  ui.confirmPrompt = null;
}

function pauseForModal(node) {
  const live = node.__tetrisLive;
  if (!live) return;
  live.state.running = false;
  live.state.showBoardWhilePaused = true;
  node.setDirtyCanvas(true, true);
}

function createModalBase(node, title, keepExisting = false) {
  if (!keepExisting) {
    closeModal(node);
  }
  pauseForModal(node);
  const config = getConfig(node);
  const theme = getThemeColors(node);
  const themeSettings = config.theme_settings || DEFAULT_CONFIG.theme_settings;
  const modal = document.createElement("div");
  modal.style.position = "fixed";
  modal.style.left = "50%";
  modal.style.top = "50%";
  modal.style.transform = "translate(-50%, -50%)";
  modal.style.minWidth = "360px";
  modal.style.maxWidth = "70vw";
  modal.style.maxHeight = "70vh";
  const modalBg = toOpaqueColor(theme.panel_bg);
  modal.style.background = modalBg;
  const showBorder = title === "Theme" || (config.theme !== "flat" && config.theme !== "minimal");
  modal.style.border = showBorder ? `1px solid ${theme.panel_border}` : "none";
  if (config.theme === "neon") {
    const glow = themeSettings.neon_glow || 8;
    modal.style.boxShadow = `0 0 ${glow}px ${theme.panel_border}, 0 10px 30px ${theme.panel_shadow}`;
  } else {
    modal.style.boxShadow = `0 10px 30px ${theme.panel_shadow}`;
  }
  modal.style.color = theme.text;
  modal.style.backdropFilter = "none";
  modal.style.padding = "12px";
  modal.style.borderRadius = `${getThemeCornerRadius(node)}px`;
  modal.style.zIndex = "9999";
  modal.style.display = "flex";
  modal.style.flexDirection = "column";
  modal.style.gap = "10px";

  const header = document.createElement("div");
  header.style.display = "flex";
  header.style.justifyContent = "space-between";
  header.style.alignItems = "center";
  header.style.cursor = "move";
  header.style.fontWeight = "600";
  header.textContent = title;

  const closeBtn = document.createElement("button");
  closeBtn.textContent = "X";
  closeBtn.style.marginLeft = "12px";
  closeBtn.style.border = "none";
  closeBtn.style.background = "transparent";
  closeBtn.style.color = theme.text;
  closeBtn.style.cursor = "pointer";
  closeBtn.addEventListener("click", () => {
    if (keepExisting) {
      modal.remove();
    } else {
      closeModal(node);
    }
  });
  header.appendChild(closeBtn);

  const body = document.createElement("div");
  body.style.overflow = "auto";
  body.style.display = "flex";
  body.style.flexDirection = "column";
  body.style.gap = "8px";

  modal.appendChild(header);
  modal.appendChild(body);
  document.body.appendChild(modal);

  let drag = null;
  header.addEventListener("mousedown", (event) => {
    drag = {
      startX: event.clientX,
      startY: event.clientY,
      rect: modal.getBoundingClientRect(),
    };
    event.preventDefault();
  });
  window.addEventListener("mousemove", (event) => {
    if (!drag) return;
    const dx = event.clientX - drag.startX;
    const dy = event.clientY - drag.startY;
    modal.style.left = `${drag.rect.left + dx}px`;
    modal.style.top = `${drag.rect.top + dy}px`;
    modal.style.transform = "translate(0, 0)";
  });
  window.addEventListener("mouseup", () => {
    drag = null;
  });

  if (!keepExisting) {
    ensureUiState(node).modal = {
      el: modal,
      body,
      title,
      kind: "generic",
      activeTab: null,
    };
  }
  return { modal, body };
}

function openLoadStateModal(node) {
  const { body } = createModalBase(node, "Load State");
  const textarea = document.createElement("textarea");
  textarea.style.width = "100%";
  textarea.style.minHeight = "140px";
  textarea.placeholder = "Paste state JSON here...";
  const actions = document.createElement("div");
  actions.style.display = "flex";
  actions.style.gap = "8px";
  const loadBtn = document.createElement("button");
  loadBtn.textContent = "Load";
  loadBtn.addEventListener("click", () => {
    loadStateFromText(node, textarea.value);
  });
  const closeBtn = document.createElement("button");
  closeBtn.textContent = "Close";
  closeBtn.addEventListener("click", () => closeModal(node));
  actions.append(loadBtn, closeBtn);
  body.append(textarea, actions);
}

function openSaveStateModal(node) {
  const { body } = createModalBase(node, "Save State");
  const live = node.__tetrisLive;
  const state = live?.state;
  const textarea = document.createElement("textarea");
  textarea.style.width = "100%";
  textarea.style.minHeight = "180px";
  textarea.value = state ? serializeState(state) : "";
  const actions = document.createElement("div");
  actions.style.display = "flex";
  actions.style.gap = "8px";
  actions.style.justifyContent = "flex-end";
  const copyBtn = document.createElement("button");
  copyBtn.textContent = "Copy";
  copyBtn.addEventListener("click", () => {
    if (navigator.clipboard?.writeText) {
      navigator.clipboard.writeText(textarea.value).catch(() => {});
    }
  });
  const closeBtn = document.createElement("button");
  closeBtn.textContent = "Close";
  closeBtn.addEventListener("click", () => closeModal(node));
  actions.append(copyBtn, closeBtn);
  body.append(textarea, actions);
}

function openSettingsModal(node) {
  const { body } = createModalBase(node, "Settings");
  const ui = ensureUiState(node);
  if (ui.modal) {
    ui.modal.kind = "settings";
    ui.modal.activeTab = "settings";
  }
  renderSettingsModal(node, body, "settings");
}

function renderSettingsModal(node, body, activeTab = "settings") {
  body.innerHTML = "";
  const ui = ensureUiState(node);
  if (ui.modal) {
    ui.modal.kind = "settings";
    ui.modal.activeTab = activeTab;
  }
  const tabs = [
    { id: "settings", label: "Settings" },
    { id: "controls", label: "Controls" },
    { id: "block_style", label: "Block Style" },
    { id: "colors", label: "Colors" },
    { id: "theme", label: "UI Themes" },
    { id: "animation", label: "Animation" },
  ];
  const tabRow = document.createElement("div");
  tabRow.style.display = "flex";
  tabRow.style.flexWrap = "wrap";
  tabRow.style.gap = "8px";
  tabRow.style.borderBottom = `1px solid ${getThemeColors(node).panel_border}`;
  tabRow.style.borderBottomColor = getThemeColors(node).panel_border;
  tabRow.style.paddingBottom = "0";
  tabRow.style.marginBottom = "0";
  tabs.forEach((tab) => {
    const btn = document.createElement("button");
    let underlineIndex = 0;
    if (tab.id === "colors") {
      underlineIndex = tab.label.indexOf("o");
    }
    if (underlineIndex < 0) {
      underlineIndex = 0;
    }
    const before = tab.label.slice(0, underlineIndex);
    const under = tab.label.slice(underlineIndex, underlineIndex + 1);
    const after = tab.label.slice(underlineIndex + 1);
    const label = document.createElement("span");
    const firstSpan = document.createElement("span");
    firstSpan.textContent = under;
    firstSpan.style.textDecoration = "underline";
    if (before) {
      const beforeSpan = document.createElement("span");
      beforeSpan.textContent = before;
      label.appendChild(beforeSpan);
    }
    label.appendChild(firstSpan);
    if (after) {
      const afterSpan = document.createElement("span");
      afterSpan.textContent = after;
      label.appendChild(afterSpan);
    }
    btn.appendChild(label);
    btn.dataset.tnTab = "true";
    btn.dataset.tnActive = tab.id === activeTab ? "true" : "false";
    btn.addEventListener("click", () => {
      renderSettingsModal(node, body, tab.id);
    });
    tabRow.appendChild(btn);
  });
  const panel = document.createElement("div");
  panel.style.display = "flex";
  panel.style.flexDirection = "column";
  panel.style.gap = "8px";
  body.append(tabRow, panel);
  if (activeTab === "controls") {
    renderControlsModal(node, panel);
  } else if (activeTab === "animation") {
    renderAnimationModal(node, panel);
  } else if (activeTab === "block_style") {
    renderBlockStyleModal(node, panel);
  } else if (activeTab === "colors") {
    renderColorsModal(node, panel);
  } else if (activeTab === "theme") {
    renderThemeModal(node, panel);
  } else {
    renderGameplayModal(node, panel);
  }
  const modalEl = body.parentElement || body;
  if (modalEl) {
    if (activeTab === "block_style") {
      modalEl.style.minWidth = "720px";
      modalEl.style.maxWidth = "80vw";
      modalEl.style.width = "";
    } else {
      modalEl.style.minWidth = "360px";
      modalEl.style.maxWidth = "70vw";
      modalEl.style.width = "";
    }
  }
  applyModalThemeStyles(node, modalEl);
}

function renderControlsModal(node, body) {
  body.innerHTML = "";
  const ui = ensureUiState(node);
  const config = getConfig(node);
  const theme = getThemeColors(node);
  const showBorders = config.theme !== "flat" && config.theme !== "minimal";
  const actions = CONTROL_ACTIONS;
  const renderConfirmPrompt = () => {
    const prompt = ui.confirmPrompt;
    if (!prompt) return;
    const panel = document.createElement("div");
    panel.style.display = "flex";
    panel.style.flexDirection = "column";
    panel.style.gap = "8px";
    panel.style.padding = "10px";
    panel.style.borderRadius = "8px";
    panel.style.background = theme.panel_bg;
    panel.style.border = `1px solid ${theme.panel_border}`;
    panel.style.boxShadow = `0 6px 14px ${theme.panel_shadow}`;
    const title = document.createElement("div");
    title.style.fontWeight = "600";
    title.textContent = prompt.title || "Confirm";
    const message = document.createElement("div");
    message.style.whiteSpace = "pre-line";
    message.textContent = Array.isArray(prompt.lines)
      ? prompt.lines.join("\n")
      : `${prompt.lines || ""}`;
    const actionsRow = document.createElement("div");
    actionsRow.style.display = "flex";
    actionsRow.style.gap = "8px";
    const confirmBtn = document.createElement("button");
    confirmBtn.textContent = prompt.confirmLabel || "Confirm";
    confirmBtn.addEventListener("click", () => {
      const onConfirm = prompt.onConfirm;
      ui.confirmPrompt = null;
      if (onConfirm) onConfirm();
      renderControlsModal(node, body);
    });
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = prompt.cancelLabel || "Cancel";
    cancelBtn.addEventListener("click", () => {
      const onCancel = prompt.onCancel;
      ui.confirmPrompt = null;
      if (onCancel) onCancel();
      renderControlsModal(node, body);
    });
    actionsRow.append(confirmBtn, cancelBtn);
    panel.append(title, message, actionsRow);
    body.appendChild(panel);
  };
  const hint = document.createElement("div");
  hint.style.fontSize = "12px";
  hint.style.opacity = "0.8";
  hint.textContent = ui.captureAction
    ? `Press a key for ${actions.find((a) => a.id === ui.captureAction)?.label || ""} (Esc to cancel)`
    : "Click Add to capture a key binding.";
  body.appendChild(hint);
  renderConfirmPrompt();
  if (ui.captureAction) {
    const cancel = document.createElement("button");
    cancel.textContent = "Cancel Capture";
    cancel.addEventListener("click", () => {
      ui.captureAction = null;
      renderControlsModal(node, body);
    });
    body.appendChild(cancel);
  }

  actions.forEach((action) => {
    const row = document.createElement("div");
    row.style.display = "grid";
    row.style.gridTemplateColumns = "120px 1fr auto auto";
    row.style.gap = "8px";
    row.style.alignItems = "center";
    const label = document.createElement("div");
    label.textContent = action.label;
    const keys = document.createElement("div");
    keys.style.display = "flex";
    keys.style.gap = "6px";
    keys.style.flexWrap = "wrap";
    const values = Array.isArray(config.bindings[action.id]) ? config.bindings[action.id] : [];
    values.forEach((value) => {
      const chip = document.createElement("div");
      chip.style.display = "flex";
      chip.style.alignItems = "center";
      chip.style.gap = "4px";
      chip.style.padding = "2px 6px";
      chip.style.borderRadius = "10px";
      chip.style.background = "rgba(255,255,255,0.08)";
      if (showBorders) {
        chip.style.border = `1px solid ${theme.panel_border}`;
      } else {
        chip.style.border = "none";
      }
      const text = document.createElement("span");
      text.textContent = formatKeyLabel(value);
      const remove = document.createElement("button");
      remove.textContent = "X";
      remove.style.border = "none";
      remove.style.background = "transparent";
      remove.style.cursor = "pointer";
      remove.addEventListener("click", () => {
        updateConfig(node, (next) => {
          next.bindings[action.id] = next.bindings[action.id].filter((k) => k !== value);
          return next;
        });
        updateBackendState(node);
        renderControlsModal(node, body);
      });
      chip.append(text, remove);
      keys.appendChild(chip);
    });
    const addBtn = document.createElement("button");
    addBtn.textContent = "Add";
    addBtn.addEventListener("click", () => {
      ui.confirmPrompt = null;
      ui.captureAction = action.id;
      renderControlsModal(node, body);
    });
    const resetBtn = document.createElement("button");
    resetBtn.textContent = "Reset";
    resetBtn.addEventListener("click", () => {
      const defaults = cloneDeep(DEFAULT_CONFIG.bindings[action.id] || []);
      const config = getConfig(node);
      const conflicts = [];
      defaults.forEach((value) => {
        const conflictId = findBindingConflict(config.bindings, action.id, value);
        if (conflictId) {
          conflicts.push({ key: value, action: conflictId });
        }
      });
      const applyReset = () => {
        updateConfig(node, (next) => {
          next.bindings[action.id] = defaults;
          if (conflicts.length) {
            conflicts.forEach((conflict) => {
              const list = Array.isArray(next.bindings[conflict.action])
                ? next.bindings[conflict.action]
                : [];
              next.bindings[conflict.action] = list.filter(
                (value) => normalizeBindingValue(value) !== normalizeBindingValue(conflict.key),
              );
            });
          }
          return next;
        });
        updateBackendState(node);
      };
      if (conflicts.length) {
        const lines = conflicts.map((conflict) =>
          ` ${formatKeyLabel(conflict.key)} is assigned to ${CONTROL_ACTION_LABELS[conflict.action] || conflict.action}`,
        );
        ui.confirmPrompt = {
          title: "Reset keys?",
          lines: [
            "Resetting will remove keys from other controls:",
            ...lines,
          ],
          confirmLabel: "Reset",
          cancelLabel: "Cancel",
          onConfirm: () => {
            applyReset();
          },
          onCancel: null,
        };
        renderControlsModal(node, body);
        return;
      }
      applyReset();
      renderControlsModal(node, body);
    });
    row.append(label, keys, addBtn, resetBtn);
    body.appendChild(row);
    const divider = document.createElement("div");
    divider.style.height = "1px";
    divider.style.margin = "6px 0";
    divider.style.background = theme.panel_border;
    divider.style.opacity = "0.3";
    body.appendChild(divider);
  });
  const modalEl = body.parentElement || body;
  applyModalThemeStyles(node, modalEl);
}

function createTetrominoLabel(shape, color, cellSize = 14) {
  if (!shape || !SHAPES[shape]) {
    const label = document.createElement("div");
    label.textContent = shape || "";
    return label;
  }
  const wrapper = document.createElement("div");
  wrapper.style.position = "relative";
  wrapper.style.display = "inline-block";
  wrapper.setAttribute("aria-label", shape);
  const cells = SHAPES[shape][0];
  let minX = 99;
  let minY = 99;
  let maxX = -99;
  let maxY = -99;
  cells.forEach(([x, y]) => {
    if (x < minX) minX = x;
    if (y < minY) minY = y;
    if (x > maxX) maxX = x;
    if (y > maxY) maxY = y;
  });
  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  wrapper.style.width = `${width * cellSize}px`;
  wrapper.style.height = `${height * cellSize}px`;
  cells.forEach(([x, y]) => {
    const block = document.createElement("div");
    block.style.position = "absolute";
    block.style.left = `${(x - minX) * cellSize}px`;
    block.style.top = `${(y - minY) * cellSize}px`;
    block.style.width = `${cellSize - 1}px`;
    block.style.height = `${cellSize - 1}px`;
    block.style.background = color;
    wrapper.appendChild(block);
  });
  return wrapper;
}

function renderColorsModal(node, body) {
  body.innerHTML = "";
  const config = getConfig(node);
  const ui = ensureUiState(node);
  const layout = document.createElement("div");
  layout.style.display = "flex";
  layout.style.flexDirection = "column";
  layout.style.gap = "8px";
  const presets = [
    {
      name: "Blueprint",
      colors: {
        color_i: "#6EC6FF",
        color_o: "#E9F1F7",
        color_t: "#1F3B5C",
        color_s: "#4FA3C7",
        color_z: "#8FAFC4",
        color_j: "#2E5E8A",
        color_l: "#B8C7D3",
      },
    },
    {
      name: "Bright Arcade",
      colors: {
        color_i: "#00E5FF",
        color_o: "#FFEB3B",
        color_t: "#9C27B0",
        color_s: "#00E676",
        color_z: "#FF1744",
        color_j: "#2979FF",
        color_l: "#FF9100",
      },
    },
    {
      name: "Taffy Shop",
      colors: {
        color_i: "#80DEEA",
        color_o: "#FFF176",
        color_t: "#F48FB1",
        color_s: "#A5D6A7",
        color_z: "#EF9A9A",
        color_j: "#9FA8DA",
        color_l: "#FFCC80",
      },
    },
    {
      name: "Classic (Default)",
      colors: {
        color_i: DEFAULT_CONFIG.colors.color_i,
        color_o: DEFAULT_CONFIG.colors.color_o,
        color_t: DEFAULT_CONFIG.colors.color_t,
        color_s: DEFAULT_CONFIG.colors.color_s,
        color_z: DEFAULT_CONFIG.colors.color_z,
        color_j: DEFAULT_CONFIG.colors.color_j,
        color_l: DEFAULT_CONFIG.colors.color_l,
      },
    },
    {
      name: "Dark Neon",
      colors: {
        color_i: "#00BCD4",
        color_o: "#FFC107",
        color_t: "#7C4DFF",
        color_s: "#00C853",
        color_z: "#D50000",
        color_j: "#1A237E",
        color_l: "#FF6D00",
      },
    },
    {
      name: "Desert Sunset",
      colors: {
        color_i: "#FFB366",
        color_o: "#FFD27D",
        color_t: "#F06A4A",
        color_s: "#7FAF8A",
        color_z: "#C84C4C",
        color_j: "#6B6FAE",
        color_l: "#FF8C42",
      },
    },
    {
      name: "Elemental",
      colors: {
        color_i: "#00E5FF",
        color_o: "#FF3D00",
        color_t: "#3F51B5",
        color_s: "#69F0AE",
        color_z: "#FF5252",
        color_j: "#1A237E",
        color_l: "#FF6F00",
      },
    },
    {
      name: "FutureTek",
      colors: {
        color_i: "#8FB3D9",
        color_o: "#F2C66D",
        color_t: "#A97FA5",
        color_s: "#9CC3B1",
        color_z: "#C46A5A",
        color_j: "#7FA1C8",
        color_l: "#D28A5C",
      },
    },
    {
      name: "Happy Holidays",
      colors: {
        color_i: "#F1F8F6",
        color_o: "#FFFFFF",
        color_t: "#C62828",
        color_s: "#2E7D32",
        color_z: "#8E1B1B",
        color_j: "#A5D6A7",
        color_l: "#D32F2F",
      },
    },
    {
      name: "High Contrast",
      colors: {
        color_i: "#00FFFF",
        color_o: "#FFFF00",
        color_t: "#FF00FF",
        color_s: "#00FF00",
        color_z: "#FF0000",
        color_j: "#0000FF",
        color_l: "#FF7F00",
      },
    },
    {
      name: "Industrial",
      colors: {
        color_i: "#4A6C82",
        color_o: "#7A6A2F",
        color_t: "#5E4A72",
        color_s: "#4F6B4A",
        color_z: "#6E3B3B",
        color_j: "#3F4F56",
        color_l: "#7A4A3A",
      },
    },
    {
      name: "Inverted Classic",
      colors: {
        color_i: "#FF3D00",
        color_o: "#3F51B5",
        color_t: "#4CAF50",
        color_s: "#E040FB",
        color_z: "#00BFA5",
        color_j: "#FFEB3B",
        color_l: "#00BCD4",
      },
    },
    {
      name: "Monochrome+",
      colors: {
        color_i: "#E3F2FD",
        color_o: "#BBDEFB",
        color_t: "#90CAF9",
        color_s: "#64B5F6",
        color_z: "#42A5F5",
        color_j: "#1E88E5",
        color_l: "#1565C0",
      },
    },
    {
      name: "Muted Earth",
      colors: {
        color_i: "#8D6E63",
        color_o: "#D7CCC8",
        color_t: "#A1887F",
        color_s: "#81C784",
        color_z: "#E57373",
        color_j: "#78909C",
        color_l: "#FFB74D",
      },
    },
    {
      name: "Noir Accent",
      colors: {
        color_i: "#B0BEC5",
        color_o: "#6D6A63",
        color_t: "#5E5668",
        color_s: "#5F6B63",
        color_z: "#6B4A4A",
        color_j: "#8E9EA6",
        color_l: "#C89B3C",
      },
    },
    {
      name: "Ocean Depths",
      colors: {
        color_i: "#4DD0E1",
        color_o: "#B2EBF2",
        color_t: "#7986CB",
        color_s: "#26A69A",
        color_z: "#EF5350",
        color_j: "#1A237E",
        color_l: "#4FC3F7",
      },
    },
    {
      name: "Pastel Dream",
      colors: {
        color_i: "#B3E5FC",
        color_o: "#FFF9C4",
        color_t: "#E1BEE7",
        color_s: "#C8E6C9",
        color_z: "#FFCDD2",
        color_j: "#BBDEFB",
        color_l: "#FFE0B2",
      },
    },
    {
      name: "Retro Terminal",
      colors: {
        color_i: "#00FF9C",
        color_o: "#66FF66",
        color_t: "#33CC99",
        color_s: "#00CC66",
        color_z: "#009966",
        color_j: "#006633",
        color_l: "#99FFCC",
      },
    },
    {
      name: "Spooktacular",
      colors: {
        color_i: "#7C4DFF",
        color_o: "#FF9100",
        color_t: "#8E24AA",
        color_s: "#76FF03",
        color_z: "#D50000",
        color_j: "#263238",
        color_l: "#FF6D00",
      },
    },
    {
      name: "Tropical Punch",
      colors: {
        color_i: "#26E6FF",
        color_o: "#FFE066",
        color_t: "#FF5A9E",
        color_s: "#1EEA88",
        color_z: "#FF6B5C",
        color_j: "#4A8DFF",
        color_l: "#FFB347",
      },
    },
    {
      name: "Vaporwave",
      colors: {
        color_i: "#00F0FF",
        color_o: "#FFC400",
        color_t: "#C400FF",
        color_s: "#00FFA8",
        color_z: "#FF1E8A",
        color_j: "#3D4CFF",
        color_l: "#FF7A00",
      },
    },
  ];
  const presetRow = document.createElement("div");
  presetRow.style.display = "grid";
  presetRow.style.gridTemplateColumns = "140px 1fr";
  presetRow.style.gap = "8px";
  presetRow.style.alignItems = "center";
  const presetLabel = document.createElement("div");
  presetLabel.textContent = "Presets";
  const presetSelect = document.createElement("select");
  const sortedPresets = presets.slice().sort((a, b) => a.name.localeCompare(b.name));
  const customOption = document.createElement("option");
  const ensureCustomLabel = () => {
    if (ui.colorPresetBase && ui.colorPresetBase !== "Custom") {
      customOption.textContent = `Custom (${ui.colorPresetBase})`;
    } else {
      customOption.textContent = "Custom";
    }
  };
  ensureCustomLabel();
  customOption.value = "Custom";
  presetSelect.appendChild(customOption);
  sortedPresets.forEach((preset) => {
    const opt = document.createElement("option");
    opt.value = preset.name;
    opt.textContent = preset.name;
    presetSelect.appendChild(opt);
  });
  const resolvePreset = (name, fallbackName) => {
    const preset = sortedPresets.find((entry) => entry.name === name);
    if (preset) return preset;
    return sortedPresets.find((entry) => entry.name === fallbackName) || sortedPresets[0];
  };
  if (!ui.colorPreset) {
    ui.colorPreset = "Classic (Default)";
    ui.colorPresetBase = ui.colorPreset;
  }
  if (!ui.colorPresetBase) {
    ui.colorPresetBase = ui.colorPreset === "Custom" ? "Classic (Default)" : ui.colorPreset;
  }
  ensureCustomLabel();
  presetSelect.value = ui.colorPreset;
  presetSelect.addEventListener("change", () => {
    const nextValue = presetSelect.value;
    if (nextValue === "Custom") {
      ui.colorPreset = "Custom";
      ui.colorPresetBase = ui.colorPresetBase || "Classic (Default)";
      ensureCustomLabel();
      renderColorsModal(node, body);
      return;
    }
    const chosen = resolvePreset(nextValue, "Classic (Default)");
    ui.colorPreset = chosen.name;
    ui.colorPresetBase = chosen.name;
    ensureCustomLabel();
    updateConfig(node, (next) => {
      const nextColors = { ...(next.colors || {}) };
      Object.entries(chosen.colors).forEach(([key, value]) => {
        nextColors[key] = value;
      });
      next.colors = nextColors;
      return next;
    });
    updateBackendState(node);
    node.setDirtyCanvas(true, true);
    renderColorsModal(node, body);
  });
  presetRow.append(presetLabel, presetSelect);
  const divider = document.createElement("div");
  divider.style.height = "1px";
  divider.style.background = getThemeColors(node).panel_border;
  divider.style.opacity = "0.6";
  layout.append(divider, presetRow, divider.cloneNode());
  const items = [
    { id: "color_i", label: "I", alpha: false },
    { id: "color_j", label: "J", alpha: false },
    { id: "color_l", label: "L", alpha: false },
    { id: "color_o", label: "O", alpha: false },
    { id: "color_s", label: "S", alpha: false },
    { id: "color_t", label: "T", alpha: false },
    { id: "color_z", label: "Z", alpha: false },
    { id: "background_color", label: "Background", alpha: false },
    { id: "grid_color", label: "Grid", alpha: true, target: "grid_color" },
  ];
  items.forEach((item) => {
    const row = document.createElement("div");
    row.style.display = "grid";
    row.style.gridTemplateColumns = "140px 1fr auto";
    row.style.gap = "8px";
    row.style.alignItems = "center";
    const label = document.createElement("div");
    label.style.display = "flex";
    label.style.alignItems = "center";
    label.style.justifyContent = "center";
    const isTetromino = item.id.startsWith("color_") && item.label.length === 1;
    if (isTetromino) {
      const color = config.colors[item.id];
      label.appendChild(createTetrominoLabel(item.label, color));
    } else {
      label.textContent = item.label;
    }
    const swatch = document.createElement("div");
    const value =
      item.id === "grid_color" ? config.grid_color : config.colors[item.id];
    swatch.style.width = "100%";
    swatch.style.height = "18px";
    swatch.style.border = "1px solid rgba(255,255,255,0.2)";
    applySwatchBackground(swatch, value, true);
    swatch.style.display = "flex";
    swatch.style.alignItems = "center";
    swatch.style.justifyContent = "center";
    swatch.style.fontSize = "10px";
    swatch.style.fontFamily = "sans-serif";
    const hexText = colorToHex(value, item.alpha !== false);
    swatch.textContent = hexText || "";
    swatch.style.color = getContrastTextColor(value);
    swatch.style.cursor = "pointer";
    swatch.addEventListener("click", () => {
      const fallback =
        item.id === "grid_color" ? DEFAULT_CONFIG.grid_color : DEFAULT_CONFIG.colors[item.id];
      openColorPicker(node, value, item.alpha !== false, fallback, (nextValue) => {
        if (ui.colorPreset !== "Custom") {
          ui.colorPresetBase = ui.colorPreset || "Classic (Default)";
          ui.colorPreset = "Custom";
        }
        ensureCustomLabel();
        updateConfig(node, (next) => {
          if (item.id === "grid_color") {
            next.grid_color = nextValue;
          } else {
            next.colors[item.id] = nextValue;
          }
          return next;
        });
        updateBackendState(node);
        renderColorsModal(node, body);
      });
    });
    const resetBtn = document.createElement("button");
    resetBtn.textContent = "Reset";
    resetBtn.addEventListener("click", () => {
      const presetName =
        ui.colorPreset === "Custom"
          ? ui.colorPresetBase || "Classic (Default)"
          : ui.colorPreset || "Classic (Default)";
      const activePreset = resolvePreset(presetName, "Classic (Default)");
      updateConfig(node, (next) => {
        if (item.id === "grid_color") {
          next.grid_color = DEFAULT_CONFIG.grid_color;
        } else {
          next.colors[item.id] = activePreset.colors[item.id] ?? DEFAULT_CONFIG.colors[item.id];
        }
        return next;
      });
      updateBackendState(node);
      renderColorsModal(node, body);
    });
    row.append(label, swatch, resetBtn);
    layout.appendChild(row);
  });
  body.appendChild(layout);
  const modalEl = body.parentElement || body;
  applyModalThemeStyles(node, modalEl);
}

function renderBlockStyleModal(node, body) {
  body.innerHTML = "";
  const config = getConfig(node);
  const theme = getThemeColors(node);
  const ui = ensureUiState(node);
  if (!ui.blockStylePreviewShape) {
    ui.blockStylePreviewShape = "O";
  }
  const layout = document.createElement("div");
  layout.style.display = "grid";
  layout.style.gridTemplateColumns = "1fr 1px 1fr 1px 1fr";
  layout.style.gap = "12px";
  const divider = document.createElement("div");
  divider.style.background = theme.panel_border;
  divider.style.opacity = "0.6";
  const dividerRight = document.createElement("div");
  dividerRight.style.background = theme.panel_border;
  dividerRight.style.opacity = "0.6";
  const leftCol = document.createElement("div");
  leftCol.style.display = "flex";
  leftCol.style.flexDirection = "column";
  leftCol.style.gap = "10px";
  const rightCol = document.createElement("div");
  rightCol.style.display = "flex";
  rightCol.style.flexDirection = "column";
  rightCol.style.gap = "10px";
  const previewCol = document.createElement("div");
  previewCol.style.display = "flex";
  previewCol.style.flexDirection = "column";
  previewCol.style.gap = "12px";
  const presetValues = {
    "Brushed Metal": {
      border: 0,
      gradient: 0,
      gradient_angle: 0,
      blur: 0,
      alpha: 1,
      clearcoat: 0,
      clearcoat_size: 0,
      rim_light: 0,
      roughness: 0,
      metallic: 1,
      scanlines: 0,
      shadow: 0,
      shadow_angle: 0,
      corner_radius: 3,
      bevel: 0,
      specular_size: 0.65,
      specular_strength: 0.9,
      inner_shadow: 4,
      inner_shadow_strength: 0.65,
      outline_opacity: 0,
      gradient_contrast: 0,
      saturation_shift: 0.3,
      brightness_shift: -0.24,
      noise: 0.05,
      glow: 0,
      glow_opacity: 0,
      pixel_snap: 0,
      texture_id: "brushed_metal",
      texture_opacity: 1,
      texture_scale: 1.2,
      texture_angle: 0,
    },
    "Candy Coated": {
      border: 0.5,
      gradient: 0,
      gradient_angle: 0,
      blur: 0,
      alpha: 1,
      clearcoat: 0.9,
      clearcoat_size: 0.45,
      rim_light: 0.25,
      roughness: 0.5,
      metallic: 0,
      scanlines: 0,
      shadow: 0.7,
      shadow_angle: 239,
      corner_radius: 6,
      bevel: 0.35,
      specular_size: 0.15,
      specular_strength: 1,
      inner_shadow: 1,
      inner_shadow_strength: 0.2,
      outline_opacity: 0,
      gradient_contrast: 0,
      saturation_shift: 0.3,
      brightness_shift: -0.18,
      noise: 0,
      glow: 0,
      glow_opacity: 0,
      pixel_snap: 1,
    },
    "Cartoon Outline": {
      bevel: 0,
      border: 4,
      brightness_shift: -0.18,
      blur: 0,
      clearcoat: 0,
      clearcoat_size: 0,
      corner_radius: 6,
      shadow: 1,
      shadow_angle: 0,
      glow: 0,
      glow_opacity: 0,
      gradient: 0,
      gradient_angle: 0,
      gradient_contrast: 0,
      inner_shadow: 8,
      inner_shadow_strength: 1,
      metallic: 0,
      noise: 0,
      outline_opacity: 1,
      pixel_snap: 1,
      rim_light: 0,
      roughness: 1,
      saturation_shift: 0.3,
      scanlines: 0,
      specular_size: 1,
      specular_strength: 1,
      alpha: 1,
    },
    "Chrome Metal": {
      bevel: 1,
      border: 3.5,
      border_blur: 0,
      brightness_shift: -0.18,
      clearcoat: 0.45,
      clearcoat_size: 0.7,
      corner_radius: 0.5,
      fill_blur: 0,
      shadow: 0.45,
      shadow_angle: 326,
      glow: 1.5,
      glow_opacity: 1,
      gradient: 2,
      gradient_angle: 0,
      gradient_contrast: 0,
      inner_shadow: 4,
      inner_shadow_strength: 0.15,
      metallic: 1,
      noise: 0,
      outline_opacity: 1,
      pixel_snap: 0,
      rim_light: 0.6,
      roughness: 0,
      saturation_shift: 0,
      scanlines: 0,
      specular_size: 1,
      specular_strength: 1,
      alpha: 1,
      texture_id: "",
      texture_opacity: 0,
      texture_scale: 1,
      texture_angle: 0,
    },
    "Clear Glass": {
      bevel: 0.8,
      border: 0,
      border_blur: 0,
      brightness_shift: -0.18,
      clearcoat: 0,
      clearcoat_size: 0,
      corner_radius: 3.5,
      fill_blur: 0,
      shadow: 0.1,
      shadow_angle: 45,
      glow: 0,
      glow_opacity: 0,
      gradient: 0,
      gradient_angle: 0,
      gradient_contrast: 0,
      inner_shadow: 1,
      inner_shadow_strength: 0.5,
      metallic: 0,
      noise: 0,
      outline_opacity: 0,
      pixel_snap: 0,
      rim_light: 0.5,
      roughness: 0,
      saturation_shift: 0,
      scanlines: 0,
      specular_size: 0.2,
      specular_strength: 1,
      alpha: 0.4,
      texture_id: "",
      texture_opacity: 0,
      texture_scale: 1,
      texture_angle: 0,
    },
    "Concrete (Rough Stone)": {
      bevel: 0,
      border: 0,
      brightness_shift: 0,
      clearcoat: 0,
      clearcoat_size: 0,
      corner_radius: 0.5,
      shadow: 0.4,
      shadow_angle: 45,
      glow: 0,
      glow_opacity: 0,
      gradient: 0,
      gradient_angle: 0,
      gradient_contrast: 0,
      inner_shadow: 1,
      inner_shadow_strength: 0.5,
      metallic: 0,
      noise: 0.5,
      outline_opacity: 0,
      pixel_snap: 0,
      rim_light: 0,
      roughness: 1,
      saturation_shift: 0,
      scanlines: 0,
      specular_size: 1,
      specular_strength: 0.1,
      alpha: 1,
      texture_id: "concrete",
      texture_opacity: 0.7,
      texture_scale: 1.1,
      texture_angle: 0,
    },
    "Crystal Gem": {
      bevel: 1,
      border: 4,
      border_blur: 0,
      brightness_shift: -0.1,
      clearcoat: 0,
      clearcoat_size: 0,
      corner_radius: 0,
      fill_blur: 0,
      shadow: 0.15,
      shadow_angle: 0,
      glow: 0.5,
      glow_opacity: 1,
      gradient: 0,
      gradient_angle: 0,
      gradient_contrast: 0,
      inner_shadow: 4.5,
      inner_shadow_strength: 0.8,
      metallic: 0,
      noise: 0,
      outline_opacity: 0.2,
      pixel_snap: 0,
      rim_light: 0.3,
      roughness: 0.35,
      saturation_shift: 0.15,
      scanlines: 0,
      specular_size: 0.05,
      specular_strength: 1,
      alpha: 0.6,
      texture_id: "",
      texture_opacity: 0,
      texture_scale: 1,
      texture_angle: 0,
    },
    "Flat (default)": {
      ...cloneDeep(DEFAULT_CONFIG.block_style),
    },
    "Frosted Glass": {
      bevel: 0.6,
      border: 3.5,
      border_blur: 0.5,
      brightness_shift: 0.18,
      clearcoat: 0,
      clearcoat_size: 0,
      corner_radius: 10,
      fill_blur: 0,
      shadow: 0.15,
      shadow_angle: 45,
      glow: 0,
      glow_opacity: 0,
      gradient: 0,
      gradient_angle: 0,
      gradient_contrast: 0,
      inner_shadow: 0,
      inner_shadow_strength: 0,
      metallic: 0,
      noise: 0,
      outline_opacity: 1,
      pixel_snap: 0,
      rim_light: 0.4,
      roughness: 1,
      saturation_shift: 0,
      scanlines: 0,
      specular_size: 0.8,
      specular_strength: 0.5,
      alpha: 0.4,
      texture_id: "",
      texture_opacity: 0,
      texture_scale: 1,
      texture_angle: 0,
    },
    "Glossy Plastic": {
      bevel: 0.6,
      border: 0,
      brightness_shift: 0,
      clearcoat: 0.8,
      clearcoat_size: 0.2,
      corner_radius: 1,
      shadow: 0.3,
      shadow_angle: 45,
      glow: 0,
      glow_opacity: 0,
      gradient: 0,
      gradient_angle: 0,
      gradient_contrast: 0,
      inner_shadow: 0,
      inner_shadow_strength: 0,
      metallic: 0,
      noise: 0,
      outline_opacity: 0,
      pixel_snap: 0,
      rim_light: 0,
      roughness: 0.2,
      saturation_shift: 0.1,
      scanlines: 0,
      specular_size: 0.3,
      specular_strength: 0.9,
      alpha: 1,
    },
    "Hologram": {
      bevel: 0,
      border: 0,
      brightness_shift: 0.05,
      clearcoat: 0,
      clearcoat_size: 0,
      corner_radius: 0.5,
      shadow: 0,
      shadow_angle: 45,
      glow: 5,
      glow_opacity: 0.7,
      gradient: 1,
      gradient_angle: 90,
      gradient_contrast: 0.8,
      inner_shadow: 0,
      inner_shadow_strength: 0,
      metallic: 0,
      noise: 0.1,
      outline_opacity: 0,
      pixel_snap: 0,
      rim_light: 0,
      roughness: 1,
      saturation_shift: -0.1,
      scanlines: 0.5,
      specular_size: 0,
      specular_strength: 0,
      alpha: 0.5,
    },
    "Ice": {
      bevel: 0.8,
      border: 0,
      brightness_shift: 0,
      clearcoat: 0.7,
      clearcoat_size: 0.3,
      corner_radius: 0.5,
      shadow: 0.1,
      shadow_angle: 45,
      glow: 0,
      glow_opacity: 0,
      gradient: 0,
      gradient_angle: 0,
      gradient_contrast: 0,
      inner_shadow: 0,
      inner_shadow_strength: 0,
      metallic: 0,
      noise: 0.05,
      outline_opacity: 0,
      pixel_snap: 0,
      rim_light: 0.6,
      roughness: 0.1,
      saturation_shift: -0.2,
      scanlines: 0,
      specular_size: 0.2,
      specular_strength: 1,
      alpha: 0.5,
    },
    "Laser Outline": {
      bevel: 0,
      border: 3,
      border_blur: 6,
      brightness_shift: -0.18,
      fill_blur: 0,
      clearcoat: 0,
      clearcoat_size: 0,
      corner_radius: 10,
      shadow: 0,
      shadow_angle: 0,
      glow: 10,
      glow_opacity: 0.55,
      gradient: 0,
      gradient_angle: 0,
      gradient_contrast: 0,
      inner_shadow: 0,
      inner_shadow_strength: 0,
      metallic: 0,
      noise: 0,
      outline_opacity: 1,
      pixel_snap: 1,
      rim_light: 0.15,
      roughness: 0,
      saturation_shift: 1,
      scanlines: 0,
      specular_size: 0.1,
      specular_strength: 0.55,
      alpha: 0.2,
    },
    "Matte Plastic": {
      bevel: 0.2,
      border: 0,
      brightness_shift: 0,
      clearcoat: 0,
      clearcoat_size: 0,
      corner_radius: 1,
      shadow: 0.25,
      shadow_angle: 45,
      glow: 0,
      glow_opacity: 0,
      gradient: 0,
      gradient_angle: 0,
      gradient_contrast: 0,
      inner_shadow: 0,
      inner_shadow_strength: 0,
      metallic: 0,
      noise: 0.02,
      outline_opacity: 0,
      pixel_snap: 0,
      rim_light: 0,
      roughness: 0.95,
      saturation_shift: -0.1,
      scanlines: 0,
      specular_size: 0,
      specular_strength: 0,
      alpha: 1,
    },
    "Neon Glow": {
      bevel: 0,
      border: 0,
      brightness_shift: 0,
      clearcoat: 0,
      clearcoat_size: 0,
      corner_radius: 6,
      shadow: 0,
      shadow_angle: 45,
      glow: 8,
      glow_opacity: 1,
      gradient: 0,
      gradient_angle: 0,
      gradient_contrast: 0,
      inner_shadow: 0,
      inner_shadow_strength: 0,
      metallic: 0,
      noise: 0,
      outline_opacity: 0,
      pixel_snap: 0,
      rim_light: 0,
      roughness: 1,
      saturation_shift: 0.3,
      scanlines: 0,
      specular_size: 0,
      specular_strength: 0,
      alpha: 1,
    },
    "Pixel Art": {
      bevel: 0,
      border: 0,
      border_blur: 0,
      fill_blur: 0,
      brightness_shift: 0,
      clearcoat: 0,
      clearcoat_size: 0,
      corner_radius: 0,
      shadow: 0,
      shadow_angle: 0,
      glow: 0,
      glow_opacity: 0,
      gradient: 0,
      gradient_angle: 0,
      gradient_contrast: 0,
      inner_shadow: 0,
      inner_shadow_strength: 0,
      metallic: 0,
      noise: 0,
      outline_opacity: 0,
      pixel_snap: 1,
      rim_light: 0,
      roughness: 0,
      saturation_shift: 0,
      scanlines: 0,
      specular_size: 0,
      specular_strength: 0,
      alpha: 1,
      texture_id: "pixelated",
      texture_opacity: 1,
      texture_scale: 1,
      texture_angle: 0,
    },
    "Porcelain Ceramic": {
      bevel: 0.8,
      border: 0,
      brightness_shift: 0,
      clearcoat: 0.8,
      clearcoat_size: 0.3,
      corner_radius: 7.5,
      shadow: 0.25,
      shadow_angle: 45,
      glow: 0,
      glow_opacity: 0,
      gradient: 0,
      gradient_angle: 0,
      gradient_contrast: 0,
      inner_shadow: 0,
      inner_shadow_strength: 0,
      metallic: 0,
      noise: 0,
      outline_opacity: 0,
      pixel_snap: 0,
      rim_light: 0,
      roughness: 0.6,
      saturation_shift: 0,
      scanlines: 0,
      specular_size: 0.4,
      specular_strength: 0.9,
      alpha: 1,
    },
    "Retro CRT": {
      bevel: 0,
      border: 0,
      border_blur: 0,
      brightness_shift: -0.2,
      fill_blur: 1,
      clearcoat: 0,
      clearcoat_size: 0,
      corner_radius: 2.5,
      shadow: 0,
      shadow_angle: 45,
      glow: 1,
      glow_opacity: 0.5,
      gradient: 0,
      gradient_angle: 0,
      gradient_contrast: 0,
      inner_shadow: 0,
      inner_shadow_strength: 0,
      metallic: 0,
      noise: 0.44,
      outline_opacity: 0,
      pixel_snap: 1,
      rim_light: 0,
      roughness: 0,
      saturation_shift: 0.05,
      scanlines: 1,
      specular_size: 0.25,
      specular_strength: 1,
      alpha: 1,
    },
    "Toxic Slime": {
      bevel: 0,
      border: 1.5,
      border_blur: 0,
      brightness_shift: -0.18,
      fill_blur: 0,
      clearcoat: 0,
      clearcoat_size: 0,
      corner_radius: 10,
      shadow: 0,
      shadow_angle: 0,
      glow: 7,
      glow_opacity: 1,
      gradient: 2,
      gradient_angle: 260,
      gradient_contrast: 0,
      inner_shadow: 0,
      inner_shadow_strength: 0,
      metallic: 0,
      noise: 0,
      outline_opacity: 1,
      pixel_snap: 1,
      rim_light: 0,
      roughness: 0,
      saturation_shift: 1,
      scanlines: 0,
      specular_size: 0,
      specular_strength: 0,
      alpha: 0.7,
      texture_id: "toxic_slime",
      texture_opacity: 1,
      texture_scale: 1,
      texture_angle: 0,
    },
    "Wooden Block": {
      bevel: 0.4,
      border: 0,
      brightness_shift: 0,
      clearcoat: 0.4,
      clearcoat_size: 0.5,
      corner_radius: 1,
      shadow: 0.2,
      shadow_angle: 45,
      glow: 0,
      glow_opacity: 0,
      gradient: 0,
      gradient_angle: 0,
      gradient_contrast: 0,
      inner_shadow: 0,
      inner_shadow_strength: 0,
      metallic: 0,
      noise: 0.1,
      outline_opacity: 0,
      pixel_snap: 0,
      rim_light: 0,
      roughness: 0.7,
      saturation_shift: -0.1,
      scanlines: 0,
      specular_size: 0.4,
      specular_strength: 0.8,
      alpha: 1,
      texture_id: "wooden",
      texture_opacity: 0.7,
      texture_scale: 1.1,
      texture_angle: 0,
    },
  };
  Object.entries(presetValues).forEach(([key, preset]) => {
    presetValues[key] = {
      ...cloneDeep(DEFAULT_CONFIG.block_style),
      ...preset,
    };
  });
  const presetNames = Object.keys(presetValues).sort((a, b) => a.localeCompare(b));
  const presetsHeader = document.createElement("div");
  presetsHeader.textContent = "Presets";
  presetsHeader.style.fontWeight = "600";
  const presetsSelect = document.createElement("select");
  const customOption = document.createElement("option");
  customOption.value = "Custom";
  customOption.textContent = "Custom";
  presetsSelect.appendChild(customOption);
  const normalizePresetLabel = (name) => {
    if (!name) return "";
    const parenIndex = name.indexOf("(");
    return (parenIndex >= 0 ? name.slice(0, parenIndex) : name).trim();
  };
  presetNames.forEach((name) => {
    const option = document.createElement("option");
    option.value = name;
    option.textContent = name;
    presetsSelect.appendChild(option);
  });
  const defaultPresetName = ui.blockStylePreset || "Flat (default)";
  if (!ui.blockStylePresetBaseFull) {
    ui.blockStylePresetBaseFull = defaultPresetName;
    ui.blockStylePresetBaseLabel = normalizePresetLabel(defaultPresetName);
  }
  if (ui.blockStylePreset === "Custom" && ui.blockStylePresetBaseLabel) {
    customOption.textContent = `Custom (${ui.blockStylePresetBaseLabel})`;
  }
  presetsSelect.value = defaultPresetName;
  presetsSelect.addEventListener("change", () => {
    const name = presetsSelect.value;
    const preset = presetValues[name];
    if (!preset) return;
    ui.blockStylePreset = name;
    ui.blockStylePresetBaseFull = name;
    ui.blockStylePresetBaseLabel = normalizePresetLabel(name);
    customOption.textContent = "Custom";
    updateConfig(node, (next) => {
      next.block_style = cloneDeep(preset);
      return next;
    });
    node.setDirtyCanvas(true, true);
    if (ui.blockStylePreviewDraw) {
      ui.blockStylePreviewDraw();
    }
    renderBlockStyleModal(node, body);
  });
  const markCustom = () => {
    const baseLabel = ui.blockStylePresetBaseLabel || "";
    customOption.textContent = baseLabel ? `Custom (${baseLabel})` : "Custom";
    if (ui.blockStylePreset !== "Custom") {
      ui.blockStylePreset = "Custom";
      presetsSelect.value = "Custom";
    }
  };
  ui.blockStyleMarkCustom = markCustom;
  const presetRule = document.createElement("div");
  presetRule.style.height = "1px";
  presetRule.style.background = theme.panel_border;
  presetRule.style.opacity = "0.6";
  previewCol.append(presetsHeader, presetsSelect, presetRule);
  const infoIcon = (text) => {
    const icon = document.createElement("span");
    icon.title = text;
    icon.style.display = "inline-flex";
    icon.style.alignItems = "center";
    icon.style.justifyContent = "center";
    icon.style.width = "18px";
    icon.style.height = "18px";
    icon.style.marginLeft = "0";
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("viewBox", `0 0 ${INFO_ICON_VIEWBOX} ${INFO_ICON_VIEWBOX}`);
    svg.setAttribute("width", "16");
    svg.setAttribute("height", "16");
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", INFO_ICON_PATH);
    path.setAttribute("fill", theme.accent);
    svg.appendChild(path);
    icon.appendChild(svg);
    return icon;
  };
  const formatSliderValue = (value, stepSize) => {
    const numeric = Number.parseFloat(value);
    if (!Number.isFinite(numeric)) return "0";
    const decimals = stepSize < 1 ? Math.min(3, `${stepSize}`.split(".")[1]?.length || 0) : 0;
    return numeric.toFixed(decimals);
  };
  const buildLabeledHint = (labelText, hint) => {
    const label = document.createElement("div");
    label.style.display = "inline";
    label.style.lineHeight = "1.1";
    label.style.fontSize = "12px";
    const words = `${labelText}`.trim().split(/\s+/);
    const lastWord = words.pop() || "";
    if (words.length) {
      const prefix = document.createElement("span");
      prefix.textContent = `${words.join(" ")} `;
      label.appendChild(prefix);
    }
    const tail = document.createElement("span");
    tail.style.whiteSpace = "nowrap";
    const lastSpan = document.createElement("span");
    lastSpan.textContent = lastWord;
    const icon = infoIcon(hint);
    icon.style.marginLeft = "6px";
    icon.style.verticalAlign = "text-bottom";
    tail.append(lastSpan, icon);
    label.appendChild(tail);
    return label;
  };
  const addSlider = (container, labelText, key, min, max, step, hint) => {
    const row = document.createElement("div");
    row.style.display = "grid";
    row.style.gridTemplateColumns = "140px 1fr 64px auto";
    row.style.gap = "8px";
    row.style.alignItems = "center";
    const label = buildLabeledHint(labelText, hint);
    const slider = document.createElement("input");
    slider.type = "range";
    slider.min = `${min}`;
    slider.max = `${max}`;
    slider.step = `${step}`;
    slider.value = `${config.block_style?.[key] ?? DEFAULT_CONFIG.block_style[key] ?? 0}`;
    const valueBox = document.createElement("div");
    valueBox.textContent = formatSliderValue(slider.value, step);
    valueBox.style.fontFamily = "monospace";
    valueBox.style.textAlign = "right";
    valueBox.style.padding = "2px 6px";
    valueBox.style.border = `1px solid ${theme.panel_border}`;
    valueBox.style.borderRadius = "6px";
    valueBox.style.background = theme.button_bg;
    slider.addEventListener("input", () => {
      updateConfig(node, (next) => {
        if (!next.block_style) next.block_style = cloneDeep(DEFAULT_CONFIG.block_style);
        next.block_style[key] = Number.parseFloat(slider.value);
        return next;
      });
      valueBox.textContent = formatSliderValue(slider.value, step);
      node.setDirtyCanvas(true, true);
      if (ui.blockStylePreviewDraw) {
        ui.blockStylePreviewDraw();
      }
      if (ui.blockStyleMarkCustom) {
        ui.blockStyleMarkCustom();
      }
    });
    const resetBtn = document.createElement("button");
    resetBtn.textContent = "Reset";
    resetBtn.addEventListener("click", () => {
      const basePreset =
        ui.blockStylePresetBaseFull && presetValues[ui.blockStylePresetBaseFull]
          ? presetValues[ui.blockStylePresetBaseFull]
          : null;
      updateConfig(node, (next) => {
        if (!next.block_style) next.block_style = cloneDeep(DEFAULT_CONFIG.block_style);
        if (basePreset && key in basePreset) {
          next.block_style[key] = basePreset[key];
        } else {
          next.block_style[key] = DEFAULT_CONFIG.block_style[key] ?? 0;
        }
        return next;
      });
      const nextValue = basePreset && key in basePreset ? basePreset[key] : DEFAULT_CONFIG.block_style[key] ?? 0;
      slider.value = `${nextValue}`;
      valueBox.textContent = formatSliderValue(slider.value, step);
      node.setDirtyCanvas(true, true);
      if (ui.blockStylePreviewDraw) {
        ui.blockStylePreviewDraw();
      }
      if (ui.blockStyleMarkCustom) {
        ui.blockStyleMarkCustom();
      }
    });
    row.append(label, slider, valueBox, resetBtn);
    container.appendChild(row);
  };
  const sliderDefs = [
    { label: "Bevel/Shine", key: "bevel", min: 0, max: 1, step: 0.05, hint: "Faux 3D highlight/shadow on edges." },
    { label: "Border", key: "border", min: 0, max: 4, step: 0.5, hint: "Border thickness using a darker edge." },
    { label: "Border Blur", key: "border_blur", min: 0, max: 6, step: 0.5, hint: "Soft blur applied to the border stroke." },
    { label: "Border Opacity", key: "outline_opacity", min: 0, max: 1, step: 0.05, hint: "Opacity of the border." },
    { label: "Brightness Shift", key: "brightness_shift", min: -0.3, max: 0.3, step: 0.01, hint: "Adjust overall lightness." },
    { label: "Clearcoat", key: "clearcoat", min: 0, max: 1, step: 0.05, hint: "Second tight specular layer." },
    { label: "Clearcoat Size", key: "clearcoat_size", min: 0, max: 1, step: 0.05, hint: "Size of the clearcoat highlight." },
    { label: "Corner Radius", key: "corner_radius", min: 0, max: 10, step: 0.5, hint: "Round block corners." },
    { label: "Drop Shadow", key: "shadow", min: 0, max: 3, step: 0.05, hint: "Shadow intensity." },
    { label: "Drop Shadow Angle", key: "shadow_angle", min: 0, max: 360, step: 1, hint: "Direction of the drop shadow." },
    { label: "Fill Blur", key: "fill_blur", min: 0, max: 6, step: 0.5, hint: "Soft blur applied to the block fill." },
    { label: "Fill Opacity", key: "alpha", min: 0, max: 1, step: 0.05, hint: "Transparency of the block fill." },
    { label: "Glow", key: "glow", min: 0, max: 10, step: 0.5, hint: "Colored outer glow." },
    { label: "Glow Opacity", key: "glow_opacity", min: 0, max: 1, step: 0.05, hint: "Glow alpha separate from blur radius." },
    { label: "Gradient", key: "gradient", min: 0, max: 2, step: 0.05, hint: "Gradient strength." },
    { label: "Gradient Angle", key: "gradient_angle", min: 0, max: 360, step: 1, hint: "Direction of the gradient." },
    { label: "Gradient Contrast", key: "gradient_contrast", min: 0, max: 1, step: 0.05, hint: "Contrast between gradient ends." },
    { label: "Inner Shadow", key: "inner_shadow", min: 0, max: 8, step: 0.5, hint: "Inset shadow depth." },
    { label: "Inner Shadow Strength", key: "inner_shadow_strength", min: 0, max: 1, step: 0.05, hint: "Inset shadow opacity." },
    { label: "Metallic", key: "metallic", min: 0, max: 2, step: 0.05, hint: "Tint specular and darken diffuse for metal." },
    { label: "Noise/Grain", key: "noise", min: 0, max: 1, step: 0.02, hint: "Subtle texture." },
    { label: "Pixel Snap", key: "pixel_snap", min: 0, max: 1, step: 1, hint: "Slightly contract fill for crisp edges." },
    { label: "Rim Light", key: "rim_light", min: 0, max: 1, step: 0.05, hint: "Edge tint to fake fresnel lighting." },
    { label: "Roughness", key: "roughness", min: 0, max: 1, step: 0.05, hint: "Softens and spreads highlights." },
    { label: "Saturation Shift", key: "saturation_shift", min: -1, max: 1, step: 0.02, hint: "Boost or reduce saturation." },
    { label: "Scanlines", key: "scanlines", min: 0, max: 1, step: 0.05, hint: "Subtle horizontal scanline overlay." },
    { label: "Specular Highlight Size", key: "specular_size", min: 0, max: 1, step: 0.05, hint: "Size of the gloss highlight." },
    { label: "Specular Highlight Strength", key: "specular_strength", min: 0, max: 1, step: 0.05, hint: "Brightness of the gloss highlight." },
  ];
  const gradientIndex = sliderDefs.findIndex((def) => def.key === "gradient");
  const splitIndex = Math.max(
    Math.ceil(sliderDefs.length / 2),
    gradientIndex >= 0 ? gradientIndex + 1 : 0,
  );
  sliderDefs.slice(0, splitIndex).forEach((def) => {
    addSlider(leftCol, def.label, def.key, def.min, def.max, def.step, def.hint);
  });
  sliderDefs.slice(splitIndex).forEach((def) => {
    addSlider(rightCol, def.label, def.key, def.min, def.max, def.step, def.hint);
  });
  const textureRow = document.createElement("div");
  textureRow.style.display = "grid";
  textureRow.style.gridTemplateColumns = "140px 1fr auto";
  textureRow.style.gap = "8px";
  textureRow.style.alignItems = "center";
  textureRow.style.marginTop = "6px";
  const textureLabel = buildLabeledHint("Texture", "Overlay a texture pattern on the block fill.");
  const textureSelect = document.createElement("select");
  const textureOptions = [
    { label: "None", value: "" },
    { label: "Brushed Metal", value: "brushed_metal" },
    { label: "Concrete (Rough Stone)", value: "concrete" },
    { label: "Pixel Art", value: "pixelated" },
    { label: "Toxic Slime", value: "toxic_slime" },
    { label: "Wooden Block", value: "wooden" },
  ];
  textureOptions.forEach((option) => {
    const item = document.createElement("option");
    item.value = option.value;
    item.textContent = option.label;
    textureSelect.appendChild(item);
  });
  textureSelect.value = config.block_style?.texture_id ?? DEFAULT_CONFIG.block_style.texture_id ?? "";
  textureSelect.addEventListener("change", () => {
    updateConfig(node, (next) => {
      if (!next.block_style) next.block_style = cloneDeep(DEFAULT_CONFIG.block_style);
      next.block_style.texture_id = textureSelect.value;
      if (next.block_style.texture_id && (next.block_style.texture_opacity ?? 0) <= 0) {
        next.block_style.texture_opacity = 1;
      }
      return next;
    });
    if (ui.blockStylePreviewDraw) {
      ui.blockStylePreviewDraw();
    }
    if (ui.blockStyleMarkCustom) {
      ui.blockStyleMarkCustom();
    }
    node.setDirtyCanvas(true, true);
  });
  const textureReset = document.createElement("button");
  textureReset.textContent = "Reset";
  textureReset.addEventListener("click", () => {
    const basePreset =
      ui.blockStylePresetBaseFull && presetValues[ui.blockStylePresetBaseFull]
        ? presetValues[ui.blockStylePresetBaseFull]
        : null;
    updateConfig(node, (next) => {
      if (!next.block_style) next.block_style = cloneDeep(DEFAULT_CONFIG.block_style);
      if (basePreset && "texture_id" in basePreset) {
        next.block_style.texture_id = basePreset.texture_id;
      } else {
        next.block_style.texture_id = DEFAULT_CONFIG.block_style.texture_id;
      }
      return next;
    });
    const nextValue = basePreset && "texture_id" in basePreset
      ? basePreset.texture_id
      : DEFAULT_CONFIG.block_style.texture_id;
    textureSelect.value = nextValue;
    if (ui.blockStylePreviewDraw) {
      ui.blockStylePreviewDraw();
    }
    if (ui.blockStyleMarkCustom) {
      ui.blockStyleMarkCustom();
    }
    node.setDirtyCanvas(true, true);
  });
  textureRow.append(textureLabel, textureSelect, textureReset);
  rightCol.appendChild(textureRow);
  const previewHeader = document.createElement("div");
  previewHeader.textContent = "Preview";
  previewHeader.style.fontWeight = "600";
  previewCol.appendChild(previewHeader);
  const shapeRow = document.createElement("div");
  shapeRow.style.display = "flex";
  shapeRow.style.gap = "6px";
  shapeRow.style.flexWrap = "wrap";
  shapeRow.style.justifyContent = "space-between";
  const shapes = ["I", "J", "L", "O", "S", "T", "Z"];
  shapes.forEach((shape) => {
    const swatch = document.createElement("button");
    swatch.dataset.tnSwatch = "true";
    swatch.style.display = "inline-flex";
    swatch.style.alignItems = "center";
    swatch.style.justifyContent = "center";
    swatch.style.padding = "4px";
    swatch.style.borderRadius = "6px";
    swatch.style.background = theme.button_bg;
    swatch.style.border = `1px solid ${theme.panel_border}`;
    if (shape === ui.blockStylePreviewShape) {
      swatch.style.borderColor = theme.accent;
      swatch.style.boxShadow = `0 0 0 1px ${theme.accent}`;
    }
    const label = createTetrominoLabel(shape, config.colors[`color_${shape.toLowerCase()}`], 10);
    swatch.appendChild(label);
    swatch.addEventListener("click", () => {
      ui.blockStylePreviewShape = shape;
      renderBlockStyleModal(node, body);
    });
    shapeRow.appendChild(swatch);
  });
  previewCol.appendChild(shapeRow);
  const previewWrap = document.createElement("div");
  previewWrap.style.display = "flex";
  previewWrap.style.alignItems = "center";
  previewWrap.style.justifyContent = "center";
  previewWrap.style.minHeight = "140px";
  const previewShape = ui.blockStylePreviewShape || "O";
  const previewColor = config.colors[`color_${previewShape.toLowerCase()}`];
  const previewCells = SHAPES[previewShape]?.[0] || [];
  const previewTransforms = getUiPreviewTextureTransforms(ui, previewShape);
  let minX = 99;
  let minY = 99;
  let maxX = -99;
  let maxY = -99;
  previewCells.forEach(([x, y]) => {
    if (x < minX) minX = x;
    if (y < minY) minY = y;
    if (x > maxX) maxX = x;
    if (y > maxY) maxY = y;
  });
  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const renderPreview = () => {
    const maxW = Math.max(0, previewWrap.clientWidth - 8);
    const maxH = Math.max(0, previewWrap.clientHeight - 8);
    if (!maxW || !maxH) return;
    const cellSize = Math.max(6, Math.floor(Math.min(maxW / width, maxH / height)));
    canvas.width = width * cellSize;
    canvas.height = height * cellSize;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    previewCells.forEach(([x, y], index) => {
      drawBlockSized(
        ctx,
        (x - minX) * cellSize,
        (y - minY) * cellSize,
        cellSize,
        previewColor,
        node,
        previewTransforms[index] ?? null,
      );
    });
  };
  ui.blockStylePreviewDraw = renderPreview;
  if (ui.blockStylePreviewObserver) {
    ui.blockStylePreviewObserver.disconnect();
  }
  ui.blockStylePreviewObserver = new ResizeObserver(() => {
    renderPreview();
  });
  ui.blockStylePreviewObserver.observe(previewWrap);
  previewWrap.appendChild(canvas);
  requestAnimationFrame(() => renderPreview());
  previewCol.appendChild(previewWrap);
  layout.append(leftCol, divider, rightCol, dividerRight, previewCol);
  body.appendChild(layout);
  const modalEl = body.parentElement || body;
  applyModalThemeStyles(node, modalEl);
}

function renderThemeModal(node, body) {
  body.innerHTML = "";
  const config = getConfig(node);
  const ensureThemePreset = (next, theme) => {
    if (!next.theme_colors) next.theme_colors = cloneDeep(DEFAULT_CONFIG.theme_colors);
    if (!next.theme_colors[theme]) {
      next.theme_colors[theme] = cloneDeep(DEFAULT_CONFIG.theme_colors[theme]);
    }
    return next.theme_colors[theme];
  };
  const themeSwatches = [
    { name: "Red", hex: "#FF3B30" },
    { name: "Orange", hex: "#FF9500" },
    { name: "Yellow", hex: "#FFCC00" },
    { name: "Green", hex: "#34C759" },
    { name: "Teal", hex: "#00C7BE" },
    { name: "Blue", hex: "#0A84FF" },
    { name: "Indigo", hex: "#5E5CE6" },
    { name: "Purple", hex: "#BF5AF2" },
    { name: "Pink", hex: "#FF2D55" },
    { name: "Gray", hex: "#8E8E93" },
  ];
  const themeRow = document.createElement("div");
  themeRow.style.display = "flex";
  themeRow.style.gap = "8px";
  ["glass", "flat", "neon", "minimal"].forEach((theme) => {
    const btn = document.createElement("button");
    btn.textContent = formatThemeName(theme);
    btn.disabled = config.theme === theme;
    btn.dataset.tnActive = btn.disabled ? "true" : "false";
    btn.addEventListener("click", () => {
      updateConfig(node, (next) => {
        next.theme = theme;
        return next;
      });
      renderThemeModal(node, body);
      node.setDirtyCanvas(true, true);
    });
    themeRow.appendChild(btn);
  });
  const swatchRow = document.createElement("div");
  swatchRow.style.display = "grid";
  swatchRow.style.gridTemplateColumns = "repeat(10, minmax(0, 1fr))";
  swatchRow.style.gap = "6px";
  swatchRow.style.width = "100%";
  themeSwatches.forEach((swatch) => {
    const btn = document.createElement("div");
    btn.title = swatch.name;
    btn.dataset.tnSwatch = "true";
    btn.style.width = "100%";
    btn.style.height = "22px";
    btn.style.borderRadius = "4px";
    btn.style.background = swatch.hex;
    btn.style.border = `1px solid ${getThemeColors(node).panel_border}`;
    btn.style.cursor = "pointer";
    btn.style.boxSizing = "border-box";
    btn.tabIndex = 0;
    btn.setAttribute("role", "button");
    const applySwatch = () => {
      updateConfig(node, (next) => {
        const preset = ensureThemePreset(next, next.theme);
        const palette = buildThemePaletteFromSwatch(swatch.hex, next.theme);
        Object.assign(preset, palette);
        return next;
      });
      renderThemeModal(node, body);
      node.setDirtyCanvas(true, true);
    };
    btn.addEventListener("click", applySwatch);
    btn.addEventListener("keydown", (event) => {
      if (event.key === "Enter" || event.key === " ") {
        applySwatch();
        event.preventDefault();
      }
    });
    swatchRow.appendChild(btn);
  });
  const resetBtn = document.createElement("button");
  resetBtn.textContent = "Reset Theme Colors";
  resetBtn.addEventListener("click", () => {
    updateConfig(node, (next) => {
      next.theme_colors[config.theme] = cloneDeep(DEFAULT_CONFIG.theme_colors[config.theme]);
      return next;
    });
    renderThemeModal(node, body);
    node.setDirtyCanvas(true, true);
  });
  body.append(themeRow, swatchRow, resetBtn);

  const settings = config.theme_settings || DEFAULT_CONFIG.theme_settings;
  if (config.theme === "glass") {
    const row = document.createElement("div");
    row.style.display = "grid";
    row.style.gridTemplateColumns = "150px 1fr auto";
    row.style.gap = "8px";
    const label = document.createElement("div");
    label.textContent = "Corner Radius";
    const slider = document.createElement("input");
    slider.type = "range";
    slider.min = "0";
    slider.max = "16";
    slider.step = "1";
    slider.value = `${settings.glass_radius}`;
    slider.addEventListener("input", () => {
      updateConfig(node, (next) => {
        next.theme_settings.glass_radius = Number.parseInt(slider.value, 10);
        return next;
      });
      node.setDirtyCanvas(true, true);
    });
    const resetBtn = document.createElement("button");
    resetBtn.textContent = "Reset";
    resetBtn.addEventListener("click", () => {
      updateConfig(node, (next) => {
        next.theme_settings.glass_radius = DEFAULT_CONFIG.theme_settings.glass_radius;
        return next;
      });
      renderThemeModal(node, body);
      node.setDirtyCanvas(true, true);
    });
    row.append(label, slider, resetBtn);
    body.appendChild(row);
  }

  if (config.theme === "neon") {
    const glowRow = document.createElement("div");
    glowRow.style.display = "grid";
    glowRow.style.gridTemplateColumns = "150px 1fr auto";
    glowRow.style.gap = "8px";
    const glowLabel = document.createElement("div");
    glowLabel.textContent = "Glow Strength";
    const glowSlider = document.createElement("input");
    glowSlider.type = "range";
    glowSlider.min = "0";
    glowSlider.max = "24";
    glowSlider.step = "1";
    glowSlider.value = `${settings.neon_glow}`;
    glowSlider.addEventListener("input", () => {
      updateConfig(node, (next) => {
        next.theme_settings.neon_glow = Number.parseInt(glowSlider.value, 10);
        return next;
      });
      node.setDirtyCanvas(true, true);
    });
    const glowReset = document.createElement("button");
    glowReset.textContent = "Reset";
    glowReset.addEventListener("click", () => {
      updateConfig(node, (next) => {
        next.theme_settings.neon_glow = DEFAULT_CONFIG.theme_settings.neon_glow;
        return next;
      });
      renderThemeModal(node, body);
      node.setDirtyCanvas(true, true);
    });
    glowRow.append(glowLabel, glowSlider, glowReset);
    body.appendChild(glowRow);

    const radiusRow = document.createElement("div");
    radiusRow.style.display = "grid";
    radiusRow.style.gridTemplateColumns = "150px 1fr auto";
    radiusRow.style.gap = "8px";
    const radiusLabel = document.createElement("div");
    radiusLabel.textContent = "Corner Radius";
    const radiusSlider = document.createElement("input");
    radiusSlider.type = "range";
    radiusSlider.min = "0";
    radiusSlider.max = "16";
    radiusSlider.step = "1";
    radiusSlider.value = `${settings.neon_radius ?? settings.glass_radius ?? 6}`;
    radiusSlider.addEventListener("input", () => {
      updateConfig(node, (next) => {
        next.theme_settings.neon_radius = Number.parseInt(radiusSlider.value, 10);
        return next;
      });
      node.setDirtyCanvas(true, true);
    });
    const radiusReset = document.createElement("button");
    radiusReset.textContent = "Reset";
    radiusReset.addEventListener("click", () => {
      updateConfig(node, (next) => {
        next.theme_settings.neon_radius = DEFAULT_CONFIG.theme_settings.neon_radius;
        return next;
      });
      renderThemeModal(node, body);
      node.setDirtyCanvas(true, true);
    });
    radiusRow.append(radiusLabel, radiusSlider, radiusReset);
    body.appendChild(radiusRow);
  }

  const themeColors = config.theme_colors?.[config.theme] || THEME_PRESETS[config.theme];
  Object.entries(themeColors)
    .filter(([key]) => THEME_USED_KEYS.has(key))
    .forEach(([key, value]) => {
      const row = document.createElement("div");
      row.style.display = "grid";
      row.style.gridTemplateColumns = "150px 1fr auto";
      row.style.gap = "8px";
      row.style.alignItems = "center";
      const label = document.createElement("div");
      label.textContent = formatThemeKeyLabel(key);
      const swatch = document.createElement("div");
    swatch.style.width = "100%";
    swatch.style.height = "18px";
    swatch.style.border = "1px solid rgba(255,255,255,0.2)";
    applySwatchBackground(swatch, value, true);
    swatch.style.display = "flex";
    swatch.style.alignItems = "center";
    swatch.style.justifyContent = "center";
    swatch.style.fontSize = "11px";
    swatch.style.fontFamily = "sans-serif";
    swatch.style.fontWeight = "bold";
    const hexText = colorToHex(value, true);
    swatch.textContent = hexText || "";
    swatch.style.color = getContrastTextColor(value);
      swatch.style.cursor = "pointer";
      swatch.addEventListener("click", () => {
        const fallback = THEME_PRESETS[config.theme][key];
        openColorPicker(node, value, true, fallback, (nextValue) => {
          updateConfig(node, (next) => {
            next.theme_colors[config.theme][key] = nextValue;
            return next;
          });
          renderThemeModal(node, body);
          node.setDirtyCanvas(true, true);
        });
      });
      const resetBtn = document.createElement("button");
      resetBtn.textContent = "Reset";
      resetBtn.addEventListener("click", () => {
        updateConfig(node, (next) => {
          next.theme_colors[config.theme][key] = THEME_PRESETS[config.theme][key];
          return next;
        });
        renderThemeModal(node, body);
        node.setDirtyCanvas(true, true);
      });
      row.append(label, swatch, resetBtn);
      body.appendChild(row);
    });
  const modalEl = body.parentElement || body;
  applyModalThemeStyles(node, modalEl);
}

function renderGameplayModal(node, body) {
  body.innerHTML = "";
  const config = getConfig(node);
  const checkbox = (labelText, key, attach = true) => {
    const row = document.createElement("label");
    row.style.display = "flex";
    row.style.gap = "8px";
    row.style.alignItems = "center";
    const input = document.createElement("input");
    input.type = "checkbox";
    input.checked = !!config[key];
    input.addEventListener("change", () => {
      updateConfig(node, (next) => {
        next[key] = input.checked;
        return next;
      });
      if (key === "anim_lock_flash" && input.checked === false) {
        if (node.__tetrisLive?.state) {
          node.__tetrisLive.state.lockFlash = null;
        }
      }
      updateBackendState(node);
      node.setDirtyCanvas(true, true);
    });
    row.append(input, document.createTextNode(labelText));
    if (attach) {
      body.appendChild(row);
    }
    return row;
  };
  const showControlsRow = checkbox("Show Controls", "show_controls", false);
  const versionLabel = document.createElement("div");
  versionLabel.textContent = `v${TETRINODE_VERSION}`;
  versionLabel.style.marginLeft = "auto";
  versionLabel.style.fontSize = "12px";
  versionLabel.style.opacity = "0.8";
  const topRow = document.createElement("div");
  topRow.style.display = "flex";
  topRow.style.alignItems = "center";
  topRow.style.justifyContent = "space-between";
  topRow.append(showControlsRow, versionLabel);
  body.appendChild(topRow);
  checkbox("Ghost Piece", "ghost_piece");
  checkbox("Next Piece", "next_piece");
  checkbox("Hold Queue", "hold_queue");
  checkbox("Grid", "grid_enabled");

  const selectRow = (labelText, key, options) => {
    const row = document.createElement("div");
    row.style.display = "grid";
    row.style.gridTemplateColumns = "140px 1fr";
    row.style.gap = "8px";
    const label = document.createElement("div");
    label.textContent = labelText;
    const select = document.createElement("select");
    options.forEach((value) => {
      const opt = document.createElement("option");
      const optionValue = typeof value === "string" ? value : value.value;
      const optionLabel = typeof value === "string" ? value : value.label;
      opt.value = optionValue;
      opt.textContent = optionLabel;
      if (`${config[key]}` === optionValue) opt.selected = true;
      select.appendChild(opt);
    });
    select.addEventListener("change", () => {
      updateConfig(node, (next) => {
        next[key] = select.value;
        return next;
      });
      updateBackendState(node);
    });
    row.append(label, select);
    body.appendChild(row);
  };

  selectRow("Lock Down", "lock_down_mode", [
    { value: "extended", label: "Extended" },
    { value: "infinite", label: "Infinite" },
    { value: "classic", label: "Classic" },
  ]);
  selectRow("Level Progression", "level_progression", [
    { value: "fixed", label: "Fixed" },
    { value: "variable", label: "Variable" },
  ]);

  const numberRow = (labelText, key, min, max) => {
    const row = document.createElement("div");
    row.style.display = "grid";
    row.style.gridTemplateColumns = "140px 1fr";
    row.style.gap = "8px";
    const label = document.createElement("div");
    label.textContent = labelText;
    const input = document.createElement("input");
    input.type = "number";
    input.min = min;
    input.max = max;
    input.value = config[key];
    input.addEventListener("change", () => {
      updateConfig(node, (next) => {
        next[key] = Number.parseInt(input.value, 10);
        return next;
      });
      updateBackendState(node);
    });
    row.append(label, input);
    body.appendChild(row);
  };

  numberRow("Start Level", "start_level", 1, 15);
  numberRow("Queue Size", "queue_size", 0, 6);
}

function renderAnimationModal(node, body) {
  body.innerHTML = "";
  const config = getConfig(node);
  const checkbox = (labelText, key) => {
    const row = document.createElement("label");
    row.style.display = "flex";
    row.style.gap = "8px";
    row.style.alignItems = "center";
    const input = document.createElement("input");
    input.type = "checkbox";
    input.checked = config[key] !== false;
    input.addEventListener("change", () => {
      updateConfig(node, (next) => {
        next[key] = input.checked;
        return next;
      });
      updateBackendState(node);
      node.setDirtyCanvas(true, true);
    });
    row.append(input, document.createTextNode(labelText));
    body.appendChild(row);
  };
  checkbox("Hard Drop Trail", "anim_hard_drop_trail");
  checkbox("Lock Flash", "anim_lock_flash");
  checkbox("Line Clear", "anim_line_clear");
  checkbox("Score Toasts", "anim_score_toasts");
}

function openColorPicker(node, value, allowAlpha, defaultValue, onApply) {
  const overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.inset = "0";
  overlay.style.background = "rgba(0,0,0,0.4)";
  overlay.style.zIndex = "10000";
  const dialog = document.createElement("div");
  dialog.style.position = "fixed";
  dialog.style.left = "50%";
  dialog.style.top = "50%";
  dialog.style.transform = "translate(-50%, -50%)";
  dialog.style.padding = "12px";
  dialog.style.borderRadius = "10px";
  const theme = getThemeColors(node);
  dialog.style.background = toOpaqueColor(theme.panel_bg);
  dialog.style.border = `1px solid ${theme.panel_border}`;
  dialog.style.color = theme.text;
  dialog.style.display = "flex";
  dialog.style.flexDirection = "column";
  dialog.style.gap = "8px";
  dialog.style.width = "max-content";
  dialog.style.maxWidth = "360px";
  const components = parseColorComponents(value);
  const defaultColor = defaultValue ?? value;
  const hsl = rgbToHsl(components.r, components.g, components.b);
  let hsv = rgbToHsv(components.r, components.g, components.b);
  const preview = document.createElement("div");
  preview.style.width = "100%";
  preview.style.height = "24px";
  preview.style.border = "1px solid rgba(255,255,255,0.2)";
  const checkerboardBg =
    "linear-gradient(45deg, rgba(255,255,255,0.25) 25%, transparent 25%)," +
    "linear-gradient(-45deg, rgba(255,255,255,0.25) 25%, transparent 25%)," +
    "linear-gradient(45deg, transparent 75%, rgba(255,255,255,0.25) 75%)," +
    "linear-gradient(-45deg, transparent 75%, rgba(255,255,255,0.25) 75%)";
  preview.style.backgroundSize = "12px 12px";
  preview.style.backgroundPosition = "0 0, 0 6px, 6px -6px, -6px 0px";
  preview.style.backgroundImage = allowAlpha && components.a < 1 ? checkerboardBg : "none";
  preview.style.backgroundColor = rgbaString(components, allowAlpha);

  const pickerWrap = document.createElement("div");
  pickerWrap.style.display = "flex";
  pickerWrap.style.flexDirection = "column";
  pickerWrap.style.gap = "6px";
  pickerWrap.style.alignItems = "center";

  const svCanvas = document.createElement("canvas");
  svCanvas.width = 200;
  svCanvas.height = 120;
  svCanvas.style.width = "200px";
  svCanvas.style.height = "120px";
  svCanvas.style.border = "1px solid rgba(255,255,255,0.18)";
  svCanvas.style.borderRadius = "6px";
  svCanvas.style.cursor = "crosshair";

  const hueRow = document.createElement("div");
  hueRow.style.display = "flex";
  hueRow.style.gap = "8px";
  hueRow.style.alignItems = "center";
  hueRow.style.width = "100%";
  hueRow.style.justifyContent = "center";

  const hueCanvas = document.createElement("canvas");
  hueCanvas.width = 200;
  hueCanvas.height = 14;
  hueCanvas.style.width = "200px";
  hueCanvas.style.height = "14px";
  hueCanvas.style.border = "1px solid rgba(255,255,255,0.18)";
  hueCanvas.style.borderRadius = "8px";
  hueCanvas.style.cursor = "pointer";

  hueRow.append(hueCanvas);
  pickerWrap.append(svCanvas, hueRow);

  const rgbaRow = document.createElement("div");
  rgbaRow.style.display = "grid";
  rgbaRow.style.gridTemplateColumns = allowAlpha
    ? "60px repeat(4, 1fr)"
    : "60px repeat(3, 1fr)";
  rgbaRow.style.gap = "6px";
  const rgbaLabel = document.createElement("div");
  rgbaLabel.textContent = "RGBA";
  const rgbaKeys = allowAlpha ? ["r", "g", "b", "a"] : ["r", "g", "b"];
  const rgbaInputs = rgbaKeys.map((key) => {
    const input = document.createElement("input");
    input.type = "number";
    input.min = "0";
    input.max = key === "a" ? "1" : "255";
    input.step = key === "a" ? "0.01" : "1";
    input.style.width = key === "a" ? "calc(7ch + 2px)" : "calc(6ch + 4px)";
    input.value = key === "a" ? `${components.a}` : `${components[key]}`;
    input.dataset.key = key;
    return input;
  });
  rgbaRow.append(rgbaLabel, ...rgbaInputs);

  const hslaRow = document.createElement("div");
  hslaRow.style.display = "grid";
  hslaRow.style.gridTemplateColumns = allowAlpha
    ? "60px repeat(4, 1fr)"
    : "60px repeat(3, 1fr)";
  hslaRow.style.gap = "6px";
  const hslaLabel = document.createElement("div");
  hslaLabel.textContent = "HSLA";
  const hslaInputs = [
    { key: "h", min: 0, max: 360, step: 1, value: Math.round(hsl.h) },
    { key: "s", min: 0, max: 100, step: 1, value: Math.round(hsl.s) },
    { key: "l", min: 0, max: 100, step: 1, value: Math.round(hsl.l) },
    ...(allowAlpha ? [{ key: "a", min: 0, max: 1, step: 0.01, value: components.a }] : []),
  ].map((meta) => {
    const input = document.createElement("input");
    input.type = "number";
    input.min = `${meta.min}`;
    input.max = `${meta.max}`;
    input.step = `${meta.step}`;
    input.style.width = meta.key === "a" ? "calc(7ch + 2px)" : "calc(6ch + 4px)";
    input.value = `${meta.value}`;
    input.dataset.key = meta.key;
    return input;
  });
  hslaRow.append(hslaLabel, ...hslaInputs);

  const hexRow = document.createElement("div");
  hexRow.style.display = "grid";
  hexRow.style.gridTemplateColumns = "60px 1fr";
  hexRow.style.gap = "6px";
  const hexLabel = document.createElement("div");
  hexLabel.textContent = "HEX";
  const hexInput = document.createElement("input");
  hexInput.type = "text";
  hexInput.style.width = "10ch";
  hexInput.value = allowAlpha
    ? rgbToHex8(components.r, components.g, components.b, components.a)
    : rgbToHex6(components.r, components.g, components.b);
  hexRow.append(hexLabel, hexInput);

  const alphaRow = document.createElement("div");
  alphaRow.style.display = "grid";
  alphaRow.style.gridTemplateColumns = "60px 1fr";
  alphaRow.style.gap = "6px";
  const alphaLabel = document.createElement("div");
  alphaLabel.textContent = "Alpha";
  const alphaInput = document.createElement("input");
  alphaInput.type = "range";
  alphaInput.min = "0";
  alphaInput.max = "1";
  alphaInput.step = "0.01";
  alphaInput.value = `${components.a}`;
  alphaRow.append(alphaLabel, alphaInput);
  if (!allowAlpha) {
    alphaRow.style.display = "none";
  }

  const actions = document.createElement("div");
  actions.style.display = "flex";
  actions.style.gap = "8px";
  const reset = document.createElement("button");
  reset.textContent = "Reset";
  const apply = document.createElement("button");
  apply.textContent = "Apply";
  const cancel = document.createElement("button");
  cancel.textContent = "Cancel";
  actions.append(reset, apply, cancel);

  dialog.append(preview, pickerWrap, rgbaRow, hslaRow, hexRow, alphaRow, actions);
  overlay.appendChild(dialog);
  document.body.appendChild(overlay);
  applyModalThemeStyles(node, dialog);

  const readRgbaInputs = () => {
    const values = {};
    rgbaInputs.forEach((input) => {
      values[input.dataset.key] = Number.parseFloat(input.value);
    });
    if ([values.r, values.g, values.b].some((v) => !Number.isFinite(v))) return null;
    const a = allowAlpha ? clamp01(values.a ?? components.a) : 1;
    return { r: clamp255(values.r), g: clamp255(values.g), b: clamp255(values.b), a };
  };

  const readHslaInputs = () => {
    const values = {};
    hslaInputs.forEach((input) => {
      values[input.dataset.key] = Number.parseFloat(input.value);
    });
    if ([values.h, values.s, values.l].some((v) => !Number.isFinite(v))) return null;
    const a = allowAlpha ? clamp01(values.a ?? components.a) : 1;
    const rgb = hslToRgb(values.h, values.s, values.l);
    return { r: rgb.r, g: rgb.g, b: rgb.b, a };
  };

  const readHexInput = () => {
    const parsed = parseHexToRgba(hexInput.value);
    if (!parsed) return null;
    if (!allowAlpha) parsed.a = 1;
    return parsed;
  };

  const drawSvPicker = () => {
    const ctx = svCanvas.getContext("2d");
    if (!ctx) return;
    const { width, height } = svCanvas;
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = `hsl(${hsv.h}, 100%, 50%)`;
    ctx.fillRect(0, 0, width, height);
    const whiteGrad = ctx.createLinearGradient(0, 0, width, 0);
    whiteGrad.addColorStop(0, "rgba(255,255,255,1)");
    whiteGrad.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = whiteGrad;
    ctx.fillRect(0, 0, width, height);
    const blackGrad = ctx.createLinearGradient(0, 0, 0, height);
    blackGrad.addColorStop(0, "rgba(0,0,0,0)");
    blackGrad.addColorStop(1, "rgba(0,0,0,1)");
    ctx.fillStyle = blackGrad;
    ctx.fillRect(0, 0, width, height);
    const x = hsv.s * width;
    const y = (1 - hsv.v) * height;
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.stroke();
  };

  const drawHuePicker = () => {
    const ctx = hueCanvas.getContext("2d");
    if (!ctx) return;
    const { width, height } = hueCanvas;
    const grad = ctx.createLinearGradient(0, 0, width, 0);
    for (let i = 0; i <= 360; i += 60) {
      grad.addColorStop(i / 360, `hsl(${i}, 100%, 50%)`);
    }
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, width, height);
    const x = (hsv.h / 360) * width;
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, height / 2, 6, 0, Math.PI * 2);
    ctx.stroke();
  };

  const updateFromRgba = (rgba) => {
    const next = {
      r: clamp255(rgba.r),
      g: clamp255(rgba.g),
      b: clamp255(rgba.b),
      a: allowAlpha ? clamp01(rgba.a) : 1,
    };
    rgbaInputs.find((input) => input.dataset.key === "r").value = `${next.r}`;
    rgbaInputs.find((input) => input.dataset.key === "g").value = `${next.g}`;
    rgbaInputs.find((input) => input.dataset.key === "b").value = `${next.b}`;
    if (allowAlpha) {
      rgbaInputs.find((input) => input.dataset.key === "a").value = `${next.a}`;
    }
    const nextHsl = rgbToHsl(next.r, next.g, next.b);
    hslaInputs.find((input) => input.dataset.key === "h").value = `${Math.round(nextHsl.h)}`;
    hslaInputs.find((input) => input.dataset.key === "s").value = `${Math.round(nextHsl.s)}`;
    hslaInputs.find((input) => input.dataset.key === "l").value = `${Math.round(nextHsl.l)}`;
    if (allowAlpha) {
      hslaInputs.find((input) => input.dataset.key === "a").value = `${next.a}`;
    }
    hexInput.value = allowAlpha
      ? rgbToHex8(next.r, next.g, next.b, next.a)
      : rgbToHex6(next.r, next.g, next.b);
    preview.style.backgroundColor = rgbaString(next, allowAlpha);
    preview.style.backgroundImage =
      allowAlpha && next.a < 1 ? checkerboardBg : "none";
    preview.style.backgroundImage =
      allowAlpha && next.a < 1 ? checkerboardBg : "none";
    if (allowAlpha) {
      alphaInput.value = `${next.a}`;
    }
    hsv = rgbToHsv(next.r, next.g, next.b);
    drawSvPicker();
    drawHuePicker();
  };

  const updatePreview = () => {
    const rgba = readRgbaInputs() || readHslaInputs() || readHexInput();
    if (!rgba) return;
    updateFromRgba(rgba);
  };

  [...rgbaInputs, ...hslaInputs, hexInput].forEach((input) => {
    input.addEventListener("input", updatePreview);
  });
  alphaInput.addEventListener("input", () => {
    if (!allowAlpha) return;
    const val = clamp01(Number.parseFloat(alphaInput.value));
    rgbaInputs.find((input) => input.dataset.key === "a").value = `${val}`;
    hslaInputs.find((input) => input.dataset.key === "a").value = `${val}`;
    updatePreview();
  });
  const handleSvPointer = (event) => {
    const rect = svCanvas.getBoundingClientRect();
    const x = Math.max(0, Math.min(rect.width, event.clientX - rect.left));
    const y = Math.max(0, Math.min(rect.height, event.clientY - rect.top));
    hsv.s = rect.width ? x / rect.width : 0;
    hsv.v = rect.height ? 1 - y / rect.height : 0;
    const rgb = hsvToRgb(hsv.h, hsv.s, hsv.v);
    const alpha = allowAlpha ? clamp01(Number.parseFloat(alphaInput.value)) : 1;
    updateFromRgba({ r: rgb.r, g: rgb.g, b: rgb.b, a: alpha });
  };
  const handleHuePointer = (event) => {
    const rect = hueCanvas.getBoundingClientRect();
    const x = Math.max(0, Math.min(rect.width, event.clientX - rect.left));
    hsv.h = rect.width ? (x / rect.width) * 360 : 0;
    const rgb = hsvToRgb(hsv.h, hsv.s, hsv.v);
    const alpha = allowAlpha ? clamp01(Number.parseFloat(alphaInput.value)) : 1;
    updateFromRgba({ r: rgb.r, g: rgb.g, b: rgb.b, a: alpha });
  };
  const bindDrag = (element, handler) => {
    let active = false;
    const onMove = (event) => {
      if (!active) return;
      handler(event);
    };
    const onUp = () => {
      active = false;
      window.removeEventListener("mousemove", onMove);
      window.removeEventListener("mouseup", onUp);
    };
    element.addEventListener("mousedown", (event) => {
      active = true;
      handler(event);
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp);
    });
  };
  bindDrag(svCanvas, handleSvPointer);
  bindDrag(hueCanvas, handleHuePointer);
  updatePreview();
  reset.addEventListener("click", () => {
    const parsed = parseColorComponents(defaultColor);
    updateFromRgba(parsed);
  });
  cancel.addEventListener("click", () => overlay.remove());
  apply.addEventListener("click", () => {
    const rgba = readRgbaInputs() || readHslaInputs() || readHexInput();
    if (!rgba) {
      overlay.remove();
      return;
    }
    const next = allowAlpha
      ? rgbToHex8(rgba.r, rgba.g, rgba.b, rgba.a)
      : rgbToHex6(rgba.r, rgba.g, rgba.b);
    onApply(next);
    overlay.remove();
  });
}

function parseColorComponents(value) {
  const rgba = parseRgbaString(value || "");
  if (rgba) {
    const parts = rgba
      .replace(/rgba?\(|\)/g, "")
      .split(",")
      .map((v) => Number.parseFloat(v.trim()));
    return { r: parts[0] || 0, g: parts[1] || 0, b: parts[2] || 0, a: parts[3] ?? 1 };
  }
  const hexParsed = parseHexToRgba(value);
  if (hexParsed) return hexParsed;
  return { r: 255, g: 255, b: 255, a: 1 };
}

function parseHexToRgba(value) {
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  const hex = trimmed.startsWith("#") ? trimmed.slice(1) : trimmed;
  if (!/^[0-9a-fA-F]{6}([0-9a-fA-F]{2})?$/.test(hex)) return null;
  const r = Number.parseInt(hex.slice(0, 2), 16);
  const g = Number.parseInt(hex.slice(2, 4), 16);
  const b = Number.parseInt(hex.slice(4, 6), 16);
  const a = hex.length === 8 ? Number.parseInt(hex.slice(6, 8), 16) / 255 : 1;
  return { r, g, b, a: Number.isFinite(a) ? a : 1 };
}

function rgbToHex8(r, g, b, a = 1) {
  const alpha = Math.round(clamp01(a) * 255);
  const toHex = (value) => value.toString(16).padStart(2, "0");
  return `#${toHex(clamp255(r))}${toHex(clamp255(g))}${toHex(clamp255(b))}${toHex(alpha)}`;
}

function rgbToHex6(r, g, b) {
  const toHex = (value) => value.toString(16).padStart(2, "0");
  return `#${toHex(clamp255(r))}${toHex(clamp255(g))}${toHex(clamp255(b))}`;
}

function clamp255(value) {
  const v = Number.isFinite(value) ? Math.round(value) : 0;
  return Math.min(255, Math.max(0, v));
}

function clamp01(value) {
  const v = Number.isFinite(value) ? value : 1;
  return Math.min(1, Math.max(0, v));
}

function rgbaString({ r, g, b, a }, allowAlpha) {
  const alpha = allowAlpha ? clamp01(a) : 1;
  return `rgba(${clamp255(r)},${clamp255(g)},${clamp255(b)},${alpha})`;
}

function rgbToHsl(r, g, b) {
  const rn = r / 255;
  const gn = g / 255;
  const bn = b / 255;
  const max = Math.max(rn, gn, bn);
  const min = Math.min(rn, gn, bn);
  let h = 0;
  let s = 0;
  const l = (max + min) / 2;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case rn:
        h = (gn - bn) / d + (gn < bn ? 6 : 0);
        break;
      case gn:
        h = (bn - rn) / d + 2;
        break;
      default:
        h = (rn - gn) / d + 4;
        break;
    }
    h *= 60;
  }
  return { h, s: s * 100, l: l * 100 };
}

function hslToRgb(h, s, l) {
  const hn = (Number.isFinite(h) ? h : 0) / 360;
  const sn = (Number.isFinite(s) ? s : 0) / 100;
  const ln = (Number.isFinite(l) ? l : 0) / 100;
  if (sn === 0) {
    const gray = Math.round(ln * 255);
    return { r: gray, g: gray, b: gray };
  }
  const q = ln < 0.5 ? ln * (1 + sn) : ln + sn - ln * sn;
  const p = 2 * ln - q;
  const hue2rgb = (pVal, qVal, t) => {
    let tt = t;
    if (tt < 0) tt += 1;
    if (tt > 1) tt -= 1;
    if (tt < 1 / 6) return pVal + (qVal - pVal) * 6 * tt;
    if (tt < 1 / 2) return qVal;
    if (tt < 2 / 3) return pVal + (qVal - pVal) * (2 / 3 - tt) * 6;
    return pVal;
  };
  const r = hue2rgb(p, q, hn + 1 / 3);
  const g = hue2rgb(p, q, hn);
  const b = hue2rgb(p, q, hn - 1 / 3);
  return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
}

function rgbToHsv(r, g, b) {
  const rn = r / 255;
  const gn = g / 255;
  const bn = b / 255;
  const max = Math.max(rn, gn, bn);
  const min = Math.min(rn, gn, bn);
  const d = max - min;
  let h = 0;
  if (d !== 0) {
    switch (max) {
      case rn:
        h = (gn - bn) / d + (gn < bn ? 6 : 0);
        break;
      case gn:
        h = (bn - rn) / d + 2;
        break;
      default:
        h = (rn - gn) / d + 4;
        break;
    }
    h *= 60;
  }
  const s = max === 0 ? 0 : d / max;
  const v = max;
  return { h, s, v };
}

function hsvToRgb(h, s, v) {
  const hh = ((Number.isFinite(h) ? h : 0) % 360 + 360) % 360;
  const ss = Number.isFinite(s) ? s : 0;
  const vv = Number.isFinite(v) ? v : 0;
  const c = vv * ss;
  const x = c * (1 - Math.abs(((hh / 60) % 2) - 1));
  const m = vv - c;
  let r1 = 0;
  let g1 = 0;
  let b1 = 0;
  if (hh < 60) {
    r1 = c;
    g1 = x;
  } else if (hh < 120) {
    r1 = x;
    g1 = c;
  } else if (hh < 180) {
    g1 = c;
    b1 = x;
  } else if (hh < 240) {
    g1 = x;
    b1 = c;
  } else if (hh < 300) {
    r1 = x;
    b1 = c;
  } else {
    r1 = c;
    b1 = x;
  }
  return {
    r: Math.round((r1 + m) * 255),
    g: Math.round((g1 + m) * 255),
    b: Math.round((b1 + m) * 255),
  };
}

function ensureBackgroundUpdater(node) {
  const live = node.__tetrisLive;
  if (!live || live.bgTimer) return;
  live.bgTimer = setInterval(() => {
    const bg = getBackgroundSource(node);
    if (bg && live.bgSource !== bg) {
      live.bgSource = bg;
      node.setDirtyCanvas(true, true);
    }
  }, 250);
}

function loadStateFromText(node, text) {
  const live = node.__tetrisLive;
  if (!live) return;
  if (!text || !text.trim()) {
    setStatusMessage(node, "No state input found.", "error");
    return;
  }
  let parsed = null;
  try {
    parsed = JSON.parse(text);
  } catch {
    setStatusMessage(node, "Invalid state JSON.", "error");
    return;
  }
  const validationError = validateStatePayload(parsed);
  if (validationError) {
    setStatusMessage(node, validationError, "error");
    return;
  }
  const seed = getSeedValue(node, { allowRandomize: false });
  const startLevel = getStartLevel(node);
  const progression = getLevelProgression(node);
  const hydrated = hydrateState(text, seed ?? 0, startLevel, progression);
  if (!hydrated) {
    setStatusMessage(node, "Failed to load state.", "error");
    return;
  }
  node.__tetrisLive.state = hydrated;
  node.__tetrisLive.state.boardDirty = true;
  node.__tetrisLive.state.started = true;
  node.__tetrisLive.state.running = false;
  node.__tetrisLive.state.showBoardWhilePaused = true;
  resetInputState(node.__tetrisLive.state);
  stopTimer(node);
  ensureTimer(node);
  updateBackendState(node);
  node.setDirtyCanvas(true, true);
  setStatusMessage(node, "State loaded.", "success");
}

function validateStatePayload(payload) {
  if (!payload || typeof payload !== "object") return "Invalid state payload.";
  if (!Array.isArray(payload.board)) return "State missing board.";
  if (payload.board.length !== GRID_H_TOTAL) return "Board must be 40 rows.";
  for (const row of payload.board) {
    if (!Array.isArray(row) || row.length !== GRID_W) return "Board rows must be 10 columns.";
  }
  const piece = payload.piece;
  if (!piece || typeof piece !== "object") return "State missing piece.";
  if (typeof piece.shape !== "string") return "Piece shape missing.";
  if (!Number.isInteger(piece.rot)) return "Piece rotation invalid.";
  if (!Number.isInteger(piece.x) || !Number.isInteger(piece.y)) return "Piece position invalid.";
  return null;
}

function setStatusMessage(node, text, kind = "info") {
  node.__tetrisStatusMessage = {
    text,
    kind,
    until: performance.now() + 2500,
  };
  node.setDirtyCanvas(true, true);
}

function resetInputState(state) {
  state.moveDir = null;
  state.moveHeldLeft = false;
  state.moveHeldRight = false;
  state.moveDasElapsed = 0;
  state.moveArrElapsed = 0;
  state.softDrop = false;
  state.dropMs = state.baseDropMs;
}

function syncSeed(state, node) {
  const nextSeed = getSeedValue(node, { allowRandomize: false });
  if (Number.isInteger(nextSeed)) {
    if (nextSeed !== state.seed) {
      if (state.started) {
        return;
      }
      stopTimer(node);
      const nextState = createState(nextSeed, state.startLevel);
      nextState.running = false;
      nextState.started = false;
      node.__tetrisLive.state = nextState;
      updateBackendState(node);
      ensureTimer(node);
      node.setDirtyCanvas(true, true);
      return;
    }
    state.seed = nextSeed;
  }
}

function getStartLevel(node) {
  const defaultValue = 1;
  const parsed = Number.parseInt(`${getConfig(node).start_level}`, 10);
  if (!Number.isFinite(parsed)) return defaultValue;
  return clampLevel(parsed);
}

function getLevelProgression(node) {
  const raw = `${getConfig(node).level_progression || ""}`.trim().toLowerCase();
  if (raw === "variable") return "variable";
  return "fixed";
}

function syncStartLevel(state, node) {
  const startLevel = getStartLevel(node);
  const progression = getLevelProgression(node);
  if (startLevel !== state.startLevel || progression !== state.levelProgression) {
    if (state.started) {
      return;
    }
    stopTimer(node);
    const nextState = createState(state.seed, startLevel, progression);
    nextState.running = false;
    nextState.started = false;
    node.__tetrisLive.state = nextState;
    updateBackendState(node);
    ensureTimer(node);
    node.setDirtyCanvas(true, true);
  } else {
    state.levelProgression = progression;
    updateLevel(state);
  }
}

function resetNode(node) {
  const live = node.__tetrisLive;
  if (!live) return;
  const seed = getSeedValue(node, { allowRandomize: true });
  const startLevel = getStartLevel(node);
  const progression = getLevelProgression(node);
  live.state = createState(seed ?? live.state.seed, startLevel, progression);
  live.state.boardDirty = true;
  node.size = [750, 950];
  node.__tetrisSizeInitialized = true;
  live.state.started = true;
  live.state.running = true;
  live.state.showBoardWhilePaused = false;
  updateBackendState(node);
  node.setDirtyCanvas(true, true);
}

function togglePause(node) {
  const live = node.__tetrisLive;
  if (!live) return;
  if (!live.state.started && !live.state.gameOver) {
    live.state.started = true;
    live.state.running = true;
  } else {
    live.state.running = !live.state.running;
  }
  live.state.showBoardWhilePaused = false;
  updateBackendState(node);
  node.setDirtyCanvas(true, true);
}

function ensureTimer(node) {
  const live = node.__tetrisLive;
  if (!live || live.state.timer) return;
  live.state.timer = setInterval(() => {
    if (live.state.running && live.state.started && !live.state.gameOver && !isNodeSelected(node)) {
      live.state.running = false;
      updateBackendState(node);
      node.setDirtyCanvas(true, true);
      return;
    }
    if (!live.state.running || live.state.gameOver) return;
    if (live.state.lockFlash) {
      if (getConfig(node).anim_lock_flash === false) {
        live.state.lockFlash = null;
        live.state.boardDirty = true;
      } else {
      const now = typeof performance !== "undefined" ? performance.now() : Date.now();
      const start = live.state.lockFlash.start ?? now;
      if (live.state.lockFlash.start == null) {
        live.state.lockFlash.start = start;
      }
      live.state.lockFlash.elapsed = Math.max(0, now - start);
      if (now >= live.state.lockFlash.until || live.state.lockFlash.elapsed >= live.state.lockFlash.duration) {
        live.state.lockFlash = null;
      }
      live.state.boardDirty = true;
      }
    }
    if (live.state.hardDropTrail) {
      const now = typeof performance !== "undefined" ? performance.now() : Date.now();
      if (now - live.state.hardDropTrail.start >= live.state.hardDropTrail.duration) {
        live.state.hardDropTrail = null;
      } else {
        live.state.boardDirty = true;
      }
    }
    if (live.state.actionToast) {
      const now = typeof performance !== "undefined" ? performance.now() : Date.now();
      if (now >= live.state.actionToast.until) {
        live.state.actionToast = null;
      } else {
        live.state.boardDirty = true;
      }
    }
    if (live.state.clearing) {
      const { lineClear } = live.state;
      if (lineClear) {
        lineClear.elapsed += 50;
        live.state.boardDirty = true;
        if (lineClear.elapsed >= lineClear.duration) {
          const pending = live.state.pendingClear;
          if (pending) {
            applyPendingClear(live.state, pending);
          }
          live.state.pendingClear = null;
          live.state.clearing = false;
          live.state.lineClear = null;
          live.state.boardDirty = true;
        } else {
          live.state.boardDirty = true;
        }
      }
      updateBackendState(node);
      node.setDirtyCanvas(true, true);
      return;
    }
    const lockMode = getLockMode(node);
    updateAutoRepeat(live.state, node, 50);
    live.state.elapsed += 50;
    live.state.timeMs += 50;
    if (live.state.locking) {
      if (lockMode === "extended" && live.state.lockMoves >= 15) {
        settlePiece(live.state);
        updateBackendState(node);
        node.setDirtyCanvas(true, true);
        return;
      }
      live.state.lockElapsed += 50;
      if (live.state.lockElapsed >= live.state.lockDelayMs) {
        settlePiece(live.state);
        updateBackendState(node);
        node.setDirtyCanvas(true, true);
        return;
      }
    }
    if (live.state.elapsed >= live.state.dropMs) {
      live.state.elapsed = 0;
      stepDown(live.state);
      if (lockMode === "extended" && live.state.lockMoves >= 15 && live.state.locking) {
        settlePiece(live.state);
        updateBackendState(node);
        node.setDirtyCanvas(true, true);
        return;
      }
      updateBackendState(node);
      node.setDirtyCanvas(true, true);
    }
  }, 50);
}

function stopTimer(node) {
  const live = node.__tetrisLive;
  if (live?.state?.timer) {
    clearInterval(live.state.timer);
    live.state.timer = null;
  }
  if (live?.bgTimer) {
    clearInterval(live.bgTimer);
    live.bgTimer = null;
  }
}

function getSelectedLiveNode(allowFallback = false) {
  const selected = app.canvas?.selected_nodes;
  let fallback = null;
  if (allowFallback) {
    const nodes = app.graph?._nodes || [];
    for (const node of nodes) {
      if (node?.comfyClass === NODE_CLASS && node.__tetrisLive) {
        fallback = node;
        break;
      }
    }
  }
  if (!selected) return fallback;
  for (const key of Object.keys(selected)) {
    const node = selected[key];
    if (node?.comfyClass === NODE_CLASS && node.__tetrisLive) return node;
  }
  return fallback;
}

function getCaptureNode() {
  const nodes = app.graph?._nodes || [];
  for (const node of nodes) {
    if (node?.comfyClass === NODE_CLASS && node.__tetrisUi?.captureAction) {
      return node;
    }
  }
  return null;
}

function isNodeSelected(node) {
  const selected = app.canvas?.selected_nodes;
  if (!selected) return false;
  for (const key of Object.keys(selected)) {
    if (selected[key] === node) return true;
  }
  return false;
}

function handleKey(event) {
  if (event.target && ["INPUT", "TEXTAREA"].includes(event.target.tagName)) return;
  const node = getCaptureNode() || getSelectedLiveNode(false);
  if (!node) return;
  const live = node.__tetrisLive;
  if (!live) return;
  const ui = node.__tetrisUi;
  if (ui?.captureAction) {
    if (ui.confirmPrompt) {
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    if (event.key && event.key.toLowerCase() === "escape") {
      ui.captureAction = null;
      if (ui.modal?.body) {
        if (ui.modal.kind === "settings") {
          renderSettingsModal(node, ui.modal.body, ui.modal.activeTab || "controls");
        } else {
          renderControlsModal(node, ui.modal.body);
        }
      }
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    const binding = bindingFromEvent(event);
    if (!binding) {
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    const config = getConfig(node);
    const conflictId = findBindingConflict(config.bindings, ui.captureAction, binding);
    if (conflictId) {
      const conflictLabel = CONTROL_ACTION_LABELS[conflictId] || conflictId;
      const currentLabel = CONTROL_ACTION_LABELS[ui.captureAction] || ui.captureAction;
      const actionId = ui.captureAction;
      ui.captureAction = null;
      ui.confirmPrompt = {
        title: "Key already in use",
        lines: [
          `"${formatKeyLabel(binding)}" is already assigned to ${conflictLabel}.`,
          `Switch it to ${currentLabel}?`,
        ],
        confirmLabel: "Switch",
        cancelLabel: "Cancel",
        onConfirm: () => {
          updateConfig(node, (next) => {
            const list = Array.isArray(next.bindings[actionId])
              ? next.bindings[actionId]
              : [];
            if (!list.includes(binding)) {
              list.push(binding);
            }
            next.bindings[actionId] = list.slice(0, 5);
            const conflictList = Array.isArray(next.bindings[conflictId])
              ? next.bindings[conflictId]
              : [];
            next.bindings[conflictId] = conflictList.filter(
              (value) => normalizeBindingValue(value) !== normalizeBindingValue(binding),
            );
            return next;
          });
          updateBackendState(node);
        },
        onCancel: null,
      };
      if (ui.modal?.body) {
        if (ui.modal.kind === "settings") {
          renderSettingsModal(node, ui.modal.body, ui.modal.activeTab || "controls");
        } else {
          renderControlsModal(node, ui.modal.body);
        }
      }
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    updateConfig(node, (next) => {
      const list = Array.isArray(next.bindings[ui.captureAction])
        ? next.bindings[ui.captureAction]
        : [];
      if (!list.includes(binding)) {
        list.push(binding);
      }
      next.bindings[ui.captureAction] = list.slice(0, 5);
      if (conflictId) {
        const conflictList = Array.isArray(next.bindings[conflictId])
          ? next.bindings[conflictId]
          : [];
        next.bindings[conflictId] = conflictList.filter(
          (value) => normalizeBindingValue(value) !== normalizeBindingValue(binding),
        );
      }
      return next;
    });
    updateBackendState(node);
    ui.captureAction = null;
    if (ui.modal?.body) {
      if (ui.modal.kind === "settings") {
        renderSettingsModal(node, ui.modal.body, ui.modal.activeTab || "controls");
      } else {
        renderControlsModal(node, ui.modal.body);
      }
    }
    event.preventDefault();
    event.stopPropagation();
    return;
  }
  if (ui?.modal) {
    if (event.key && event.key.toLowerCase() === "escape") {
      closeModal(node);
      event.preventDefault();
      event.stopPropagation();
    }
    if (ui.modal.kind === "settings" && !ui.captureAction) {
      const key = event.key ? event.key.toLowerCase() : "";
      const tabMap = {
        s: "settings",
        a: "animation",
        c: "controls",
        b: "block_style",
        o: "colors",
        u: "theme",
      };
      const targetTab = tabMap[key];
      if (targetTab && ui.modal.body) {
        renderSettingsModal(node, ui.modal.body, targetTab);
        event.preventDefault();
        event.stopPropagation();
      }
    }
    return;
  }

  const state = live.state;
  const bindings = getControlBindings(node);
  const matches = (binding) => keyMatches(event, binding);
  const resetPressed = matches(bindings.reset);
  const pausePressed = matches(bindings.pause);
  const settingsPressed = matches(bindings.settings);
  if (settingsPressed) {
    if (ui?.modal?.kind === "settings") {
      closeModal(node);
    } else {
      openSettingsModal(node);
    }
    event.preventDefault();
    event.stopPropagation();
    return;
  }
  if (state.gameOver) {
    if (resetPressed || pausePressed) {
      resetNode(node);
      event.preventDefault();
      event.stopPropagation();
    }
    return;
  }
  if (
    event.repeat
    && (matches(bindings.rotateCw)
      || matches(bindings.rotateCcw)
      || matches(bindings.moveLeft)
      || matches(bindings.moveRight)
      || matches(bindings.softDrop)
      || matches(bindings.hardDrop)
      || matches(bindings.hold)
      || matches(bindings.reset)
      || matches(bindings.pause)
      || matches(bindings.settings))
  ) {
    event.preventDefault();
    event.stopPropagation();
    return;
  }
  const canAct =
    state.running ||
    matches(bindings.pause) ||
    matches(bindings.reset);
  if (!canAct) return;
  if (state.clearing && !(matches(bindings.pause) || matches(bindings.reset))) {
    event.preventDefault();
    event.stopPropagation();
    return;
  }
  let handled = true;
  if (matches(bindings.moveLeft)) {
    state.moveHeldLeft = true;
    setMoveDirection(state, "left");
    if (move(state, -1, 0)) applyLockModeAfterAction(state, getLockMode(node));
  } else if (matches(bindings.moveRight)) {
    state.moveHeldRight = true;
    setMoveDirection(state, "right");
    if (move(state, 1, 0)) applyLockModeAfterAction(state, getLockMode(node));
  } else if (matches(bindings.rotateCw)) {
    if (rotate(state, 1)) {
      applyLockModeAfterAction(state, getLockMode(node));
    }
  } else if (matches(bindings.rotateCcw)) {
    if (rotate(state, -1)) {
      applyLockModeAfterAction(state, getLockMode(node));
    }
  } else if (matches(bindings.softDrop)) {
    state.softDrop = true;
    state.dropMs = Math.max(1, Math.floor(state.baseDropMs / 20));
  } else if (matches(bindings.hardDrop)) {
    hardDrop(state);
  } else if (matches(bindings.hold)) {
    holdPiece(state);
  } else if (matches(bindings.reset)) {
    resetNode(node);
  } else if (matches(bindings.pause)) {
    togglePause(node);
  } else {
    handled = false;
  }

  if (handled) {
    event.preventDefault();
    event.stopPropagation();
    updateBackendState(node);
    node.setDirtyCanvas(true, true);
  }
}

function handleKeyUp(event) {
  if (event.target && ["INPUT", "TEXTAREA"].includes(event.target.tagName)) return;
  const node = getSelectedLiveNode(false);
  if (!node) return;
  const live = node.__tetrisLive;
  if (!live || live.state.gameOver) return;
  if (node.__tetrisUi?.modal) return;
  const bindings = getControlBindings(node);
  const matches = (binding) => keyMatches(event, binding);
  if (matches(bindings.moveLeft)) {
    live.state.moveHeldLeft = false;
    if (live.state.moveHeldRight) {
      setMoveDirection(live.state, "right");
    } else {
      clearMoveDirection(live.state);
    }
  }
  if (matches(bindings.moveRight)) {
    live.state.moveHeldRight = false;
    if (live.state.moveHeldLeft) {
      setMoveDirection(live.state, "left");
    } else {
      clearMoveDirection(live.state);
    }
  }
  if (!matches(bindings.softDrop)) return;
  live.state.softDrop = false;
  live.state.dropMs = live.state.baseDropMs;
}

function applyWidgetHiding(node) {
  const hideWidgets = new Set([
    "action",
    "state",
    "block_size",
  ]);
  if (!node.widgets) return;
  let touched = false;
  for (const widget of node.widgets) {
    if (hideWidgets.has(widget?.name)) {
      widget.hidden = true;
      widget.computeSize = () => [0, 0];
      widget.draw = () => {};
      touched = true;
    }
  }
  if (touched) {
    node.__tetrisWidgetsHidden = true;
    node.setDirtyCanvas(true, true);
  }
}

function isValidLinkId(link) {
  return Number.isInteger(link) && link >= 0;
}

function getInputLink(node, name) {
  const input = node?.inputs?.find((inp) => inp?.name === name);
  if (!input || !isValidLinkId(input.link)) return null;
  let linkId = input.link;
  let link = null;
  let origin = null;
  for (let hop = 0; hop < 8; hop += 1) {
    link = node.graph?.links?.[linkId];
    if (!link) return null;
    origin = node.graph?._nodes_by_id?.[link.origin_id];
    if (!origin) return null;
    const isReroute = origin?.type === "Reroute" || origin?.comfyClass === "Reroute";
    if (!isReroute) {
      return { link, origin };
    }
    const rerouteInput = origin.inputs?.[0];
    if (!rerouteInput || !isValidLinkId(rerouteInput.link)) {
      return { link, origin };
    }
    linkId = rerouteInput.link;
  }
  return null;
}

function getInputValue(node, name) {
  const idx = node?.inputs?.findIndex((inp) => inp?.name === name);
  if (idx == null || idx < 0) return null;
  const input = node.inputs[idx];
  if (!isValidLinkId(input?.link)) return null;
  if (typeof node.getInputData !== "function") return null;
  const value = node.getInputData(idx);
  let candidate = value;
  if (value && typeof value === "object") {
    if ("value" in value) {
      candidate = value.value;
    } else if ("seed" in value) {
      candidate = value.seed;
    }
  }
  const coerced = coerceInt(candidate);
  return coerced != null ? coerced : null;
}

function coerceInt(value) {
  if (Number.isInteger(value)) return value;
  if (typeof value === "string" && value.trim() !== "") {
    const parsed = Number.parseInt(value, 10);
    if (Number.isInteger(parsed)) return parsed;
  }
  if (typeof value === "number" && Number.isFinite(value)) {
    return Math.trunc(value);
  }
  return null;
}

function getLinkedInputValue(node, name) {
  const resolved = getInputLink(node, name);
  if (!resolved) return null;
  const { link, origin } = resolved;
  const output = origin.outputs?.[link.origin_slot];
  if (output && output.value !== undefined) {
    const coerced = coerceInt(output.value);
    if (coerced != null) return coerced;
  }
  const outputName = output?.name;
  if (outputName && origin.widgets) {
    const widgetIndex = origin.widgets.findIndex((w) => w.name === outputName);
    if (widgetIndex >= 0) {
      const widgetValue = origin.widgets[widgetIndex]?.value;
      const coerced = coerceInt(widgetValue);
      if (coerced != null) return coerced;
      if (origin.widgets_values && origin.widgets_values.length > widgetIndex) {
        const coercedStored = coerceInt(origin.widgets_values[widgetIndex]);
        if (coercedStored != null) return coercedStored;
      }
    }
  }
  if (origin.widgets_values && origin.widgets_values.length) {
    const coerced = coerceInt(origin.widgets_values[0]);
    if (coerced != null) return coerced;
  }
  if (origin.widgets && origin.widgets.length) {
    const coerced = coerceInt(origin.widgets[0]?.value);
    if (coerced != null) return coerced;
  }
  return null;
}

function isSeedLinked(node) {
  return !!getInputLink(node, "seed");
}

function resolveSeed(value, allowRandomize) {
  const coerced = coerceInt(value);
  if (coerced == null) return null;
  if (coerced < 0) {
    if (!allowRandomize) return null;
    const max = 0xffffffff;
    return Math.floor(Math.random() * (max + 1));
  }
  return coerced;
}

function getSeedValue(node, options = {}) {
  const allowRandomize = options.allowRandomize === true;
  const liveInput = getInputValue(node, "seed");
  const liveResolved = resolveSeed(liveInput, allowRandomize);
  if (liveResolved != null) return liveResolved;
  const linked = getLinkedInputValue(node, "seed");
  const linkedResolved = resolveSeed(linked, allowRandomize);
  if (linkedResolved != null) return linkedResolved;
  const seedWidget = node.widgets?.find((w) => w.name === "seed");
  const fallback = resolveSeed(seedWidget?.value, allowRandomize);
  return fallback != null ? fallback : 0;
}

function normalizeBindingValue(value) {
  if (!value) return null;
  const rawValue = `${value}`;
  if (rawValue === " ") return " ";
  const raw = rawValue.trim().toLowerCase();
  if (!raw) return null;
  if (raw === "space" || raw === "spacebar") return " ";
  if (raw === "backslash") return "\\";
  if (raw === "slash" || raw === "forwardslash") return "/";
  if (raw === "control" || raw === "ctrl") return "control";
  if (raw === "shift") return "shift";
  if (raw === "none" || raw === "null") return null;
  return raw;
}

function findBindingConflict(bindings, actionId, binding) {
  const normalized = normalizeBindingValue(binding);
  if (!normalized) return null;
  for (const [key, values] of Object.entries(bindings || {})) {
    if (key === actionId) continue;
    const list = Array.isArray(values) ? values : [values];
    if (list.some((value) => normalizeBindingValue(value) === normalized)) {
      return key;
    }
  }
  return null;
}

function getControlBindings(node) {
  const config = getConfig(node);
  const normalizeList = (values) =>
    (Array.isArray(values) ? values : [values])
      .map((value) => normalizeBindingValue(value))
      .filter((value) => value);
  return {
    moveLeft: normalizeList(config.bindings.move_left),
    moveRight: normalizeList(config.bindings.move_right),
    rotateCw: normalizeList(config.bindings.rotate_cw),
    rotateCcw: normalizeList(config.bindings.rotate_ccw),
    softDrop: normalizeList(config.bindings.soft_drop),
    hardDrop: normalizeList(config.bindings.hard_drop),
    hold: normalizeList(config.bindings.hold),
    reset: normalizeList(config.bindings.reset),
    pause: normalizeList(config.bindings.pause),
    settings: normalizeList(config.bindings.settings),
  };
}

function getQueueSize(node) {
  const parsed = Number.parseInt(`${getConfig(node).queue_size}`, 10);
  if (!Number.isFinite(parsed)) return 6;
  return Math.max(0, Math.min(6, parsed));
}

function getHoldEnabled(node) {
  return !!getConfig(node).hold_queue;
}

function getNextPieceEnabled(node) {
  return !!getConfig(node).next_piece;
}

function getShowControls(node) {
  return !!getConfig(node).show_controls;
}

function getGridEnabled(node) {
  return !!getConfig(node).grid_enabled;
}

function getGridColor(node) {
  const raw = getConfig(node).grid_color;
  const parsed = normalizeColor(raw, true);
  return parsed || "rgba(255,255,255,0.2)";
}

function formatKeyLabel(value) {
  if (!value) return "";
  if (value === "null" || value === "none") return "";
  if (value === " ") return "Space";
  if (value === "\\") return "\\";
  if (value === "/") return "/";
  if (value === "control") return "Ctrl";
  if (value === "shift") return "Shift";
  if (value === "escape") return "Esc";
  if (value === "enter") return "Enter";
  if (value === "tab") return "Tab";
  if (value === "backspace") return "Bksp";
  if (value === "delete") return "Del";
  if (value === "insert") return "Ins";
  if (value === "home") return "Home";
  if (value === "end") return "End";
  if (value === "pageup") return "PgUp";
  if (value === "pagedown") return "PgDn";
  if (value === "arrowleft") return "Left Arrow";
  if (value === "arrowright") return "Right Arrow";
  if (value === "arrowup") return "Up Arrow";
  if (value === "arrowdown") return "Down Arrow";
  if (value.startsWith("numpad")) {
    const suffix = value.replace("numpad", "");
    if (/^\d+$/.test(suffix)) return `${suffix} (Numpad)`;
    const label = suffix ? `${suffix[0].toUpperCase()}${suffix.slice(1)}` : "";
    return label ? `${label} (Numpad)` : "Numpad";
  }
  return value.toUpperCase();
}

function formatTimeMs(ms) {
  const total = Math.max(0, Math.floor(ms || 0));
  const minutes = Math.floor(total / 60000);
  const seconds = Math.floor((total % 60000) / 1000);
  const centis = Math.floor((total % 1000) / 10);
  const mm = `${minutes}`.padStart(2, "0");
  const ss = `${seconds}`.padStart(2, "0");
  const cc = `${centis}`.padStart(2, "0");
  return `${mm}:${ss}.${cc}`;
}

function normalizeEventKey(event) {
  const key = event.key ? event.key.toLowerCase() : "";
  const code = event.code ? event.code.toLowerCase() : "";
  return { key, code };
}

function bindingFromEvent(event) {
  if (event.altKey || event.metaKey) return null;
  if (["alt", "meta", "capslock", "numlock", "scrolllock"].includes(event.key?.toLowerCase())) {
    return null;
  }
  const { key, code } = normalizeEventKey(event);
  if (code && code.startsWith("numpad")) {
    return ALLOWED_KEYS.has(code) ? code : null;
  }
  if (key === " ") return " ";
  if (ALLOWED_KEYS.has(key)) return key;
  return null;
}

function keyMatches(event, binding) {
  if (!binding) return false;
  const bindings = Array.isArray(binding) ? binding : [binding];
  const { key, code } = normalizeEventKey(event);
  return bindings.some((value) => {
    if (!value) return false;
    if (value === " ") return key === " " || code === "space";
    if (value.startsWith("numpad")) {
      return code === value;
    }
    return key === value;
  });
}

function parseHexColor(value) {
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  const hex = trimmed.startsWith("#") ? trimmed.slice(1) : trimmed;
  if (!/^[0-9a-fA-F]{6}([0-9a-fA-F]{2})?$/.test(hex)) return null;
  const r = Number.parseInt(hex.slice(0, 2), 16);
  const g = Number.parseInt(hex.slice(2, 4), 16);
  const b = Number.parseInt(hex.slice(4, 6), 16);
  const a = hex.length === 8 ? Number.parseInt(hex.slice(6, 8), 16) / 255 : 1;
  return `rgba(${r},${g},${b},${Math.min(1, Math.max(0, a))})`;
}

function cloneDeep(value) {
  return JSON.parse(JSON.stringify(value));
}

function mergeConfig(defaults, stored) {
  if (!stored || typeof stored !== "object") return cloneDeep(defaults);
  const result = Array.isArray(defaults) ? [] : {};
  for (const [key, value] of Object.entries(defaults)) {
    if (value && typeof value === "object" && !Array.isArray(value)) {
      result[key] = mergeConfig(value, stored[key]);
    } else if (Array.isArray(value)) {
      const storedValue = stored[key];
      result[key] = Array.isArray(storedValue) ? storedValue.slice(0, 5) : value.slice();
    } else if (stored[key] !== undefined) {
      result[key] = stored[key];
    } else {
      result[key] = value;
    }
  }
  return result;
}

function getConfig(node) {
  if (!node) return cloneDeep(DEFAULT_CONFIG);
  if (!node.properties) node.properties = {};
  const stored = node.properties.tetrinode_config;
  const merged = mergeConfig(DEFAULT_CONFIG, stored);
  node.properties.tetrinode_config = merged;
  return merged;
}

function updateConfig(node, updater) {
  const current = getConfig(node);
  const next = updater(cloneDeep(current));
  node.properties.tetrinode_config = next;
  if (node.__tetrisLive?.state) {
    node.__tetrisLive.state.boardDirty = true;
    node.__tetrisLive.boardCacheKey = null;
  }
  return next;
}

function getOptionsForState(node) {
  const config = getConfig(node);
  return {
    ghost_piece: !!config.ghost_piece,
    next_piece: !!config.next_piece,
    hold_queue: !!config.hold_queue,
    show_controls: !!config.show_controls,
    lock_down_mode: config.lock_down_mode,
    start_level: config.start_level,
    level_progression: config.level_progression,
    queue_size: config.queue_size,
    grid_enabled: !!config.grid_enabled,
    grid_color: config.grid_color,
    anim_hard_drop_trail: config.anim_hard_drop_trail !== false,
    anim_lock_flash: config.anim_lock_flash !== false,
    anim_line_clear: config.anim_line_clear !== false,
    anim_score_toasts: config.anim_score_toasts !== false,
    block_style: cloneDeep(config.block_style || DEFAULT_CONFIG.block_style),
    ...config.colors,
  };
}

function normalizeColor(value, allowAlpha = true) {
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  if (trimmed.startsWith("#")) {
    const parsed = parseHexColor(trimmed);
    return parsed;
  }
  const rgba = parseRgbaString(trimmed);
  if (rgba) {
    if (!allowAlpha) return rgba.replace(/,([0-9.]+)\)$/, ",1)");
    return rgba;
  }
  return null;
}

function parseRgbaString(value) {
  if (typeof value !== "string") return null;
  const rgbaMatch = value.match(
    /^rgba?\s*\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})(?:\s*,\s*([0-9]*\.?[0-9]+))?\s*\)$/i,
  );
  if (!rgbaMatch) return null;
  const r = Number.parseInt(rgbaMatch[1], 10);
  const g = Number.parseInt(rgbaMatch[2], 10);
  const b = Number.parseInt(rgbaMatch[3], 10);
  const a = rgbaMatch[4] != null ? Number.parseFloat(rgbaMatch[4]) : 1;
  if ([r, g, b].some((v) => !Number.isFinite(v) || v < 0 || v > 255)) return null;
  const clampedA = Math.min(1, Math.max(0, Number.isFinite(a) ? a : 1));
  return `rgba(${r},${g},${b},${clampedA})`;
}

function getColorPalette(node) {
  const palette = { ...COLORS };
  const config = getConfig(node);
  const mapping = {
    color_i: "I",
    color_j: "J",
    color_l: "L",
    color_o: "O",
    color_s: "S",
    color_t: "T",
    color_z: "Z",
    background_color: "X",
  };
  for (const [key, shape] of Object.entries(mapping)) {
    const raw = config.colors?.[key];
    const parsed = normalizeColor(raw, false);
    if (parsed) palette[shape] = parsed;
  }
  return palette;
}

function isGhostEnabled(node) {
  return !!getConfig(node).ghost_piece;
}

function ensureSeedControlWidget(node) {
  if (!node?.widgets) return;
  const existing = node.widgets.find((w) => w.name === "control_after_generate");
  if (existing) return;
  const seedIndex = node.widgets.findIndex((w) => w.name === "seed");
  if (seedIndex < 0) return;
  const widget = node.addWidget(
    "combo",
    "control_after_generate",
    "randomize",
    () => {},
    { values: ["randomize", "increment", "decrement", "fixed"] }
  );
  const currentIndex = node.widgets.indexOf(widget);
  if (currentIndex >= 0) {
    node.widgets.splice(currentIndex, 1);
    node.widgets.splice(seedIndex + 1, 0, widget);
  }
}

function applySeedAfterGenerate(node) {
  if (isSeedLinked(node)) return;
  if (!node?.widgets) return;
  const seedWidget = node.widgets.find((w) => w.name === "seed");
  const controlWidget = node.widgets.find((w) => w.name === "control_after_generate");
  if (!seedWidget || !controlWidget) return;
  let mode = controlWidget.value;
  const controlIndex = node.widgets.indexOf(controlWidget);
  if (!mode && controlIndex >= 0 && node.widgets_values) {
    mode = node.widgets_values[controlIndex];
  }
  mode = `${mode || ""}`.toLowerCase();
  if (mode === "fixed") return;
  const min = coerceInt(seedWidget.options?.min) ?? 0;
  const maxOption = seedWidget.options?.max;
  if (maxOption != null && !Number.isSafeInteger(maxOption)) {
    return;
  }
  const max =
    Number.isFinite(maxOption) && Number.isSafeInteger(maxOption)
      ? maxOption
      : 0x7fffffff;
  const current = coerceInt(seedWidget.value) ?? min;
  let next = current;
  if (mode === "increment") {
    next = current >= max ? min : current + 1;
  } else if (mode === "decrement") {
    next = current <= min ? max : current - 1;
  } else if (mode === "randomize") {
    next = Math.floor(Math.random() * (max - min + 1)) + min;
  }
  seedWidget.value = next;
  const seedIndex = node.widgets.indexOf(seedWidget);
  if (!node.widgets_values) node.widgets_values = [];
  if (seedIndex >= 0) node.widgets_values[seedIndex] = next;
}

app.registerExtension({
  name: EXT_NAME,
  async nodeCreated(node) {
    if (node?.comfyClass !== NODE_CLASS) return;
    applyWidgetHiding(node);
    ensureSeedControlWidget(node);
    ensureUiState(node);
    getConfig(node);
    const seed = getSeedValue(node, { allowRandomize: true });
    const startLevel = getStartLevel(node);
    const progression = getLevelProgression(node);
    node.__tetrisLive = { state: createState(seed ?? 0, startLevel, progression) };

    if (!node.__tetrisSizeInitialized) {
      node.size = [750, 950];
      const layout = getLayout(node);
      const targetHeight = Math.ceil(layout.boardY + layout.boardH + PADDING);
      node.size = [node.size[0], Math.max(targetHeight, 400)];
      node.__tetrisSizeInitialized = true;
    }

    const originalDraw = node.onDrawForeground;
    node.onDrawForeground = function (ctx) {
      const result = originalDraw?.apply(this, arguments);
      ensureWidgetDrawCapture(node);
      drawNode(node, ctx);
      return result;
    };

    const originalMouseDown = node.onMouseDown;
    node.onMouseDown = function (event, pos, _graphcanvas) {
      if (handleToolbarClick(node, pos)) {
        node.setDirtyCanvas(true, true);
        return true;
      }
      return originalMouseDown?.apply(this, arguments);
    };

    const originalMouseMove = node.onMouseMove;
    node.onMouseMove = function (event, pos, _graphcanvas) {
      const ui = ensureUiState(node);
      const hovered = hitToolbarButton(node, pos, node.__tetrisLastLayout?.boardY);
      const next = hovered ? hovered.id : null;
      if (next !== (ui.hoverButton?.id || null)) {
        ui.hoverButton = hovered;
        node.setDirtyCanvas(true, true);
      }
      return originalMouseMove?.apply(this, arguments);
    };

    const originalRemoved = node.onRemoved;
    node.onRemoved = function () {
      closeModal(node);
      stopTimer(node);
      return originalRemoved?.apply(this, arguments);
    };
    const originalExecuted = node.onExecuted;
    node.onExecuted = function () {
      const result = originalExecuted?.apply(this, arguments);
      applySeedAfterGenerate(node);
      return result;
    };

    syncSeed(node.__tetrisLive.state, node);
    node.__tetrisLive.state.running = false;
    updateBackendState(node);
    ensureTimer(node);
    ensureBackgroundUpdater(node);
    if (!node.__tetrisLive.api) {
      node.__tetrisLive.api = {
        rotateCw: () => {
          rotate(node.__tetrisLive.state, 1);
          updateBackendState(node);
          node.setDirtyCanvas(true, true);
        },
        rotateCcw: () => {
          rotate(node.__tetrisLive.state, -1);
          updateBackendState(node);
          node.setDirtyCanvas(true, true);
        },
        hardDrop: () => {
          hardDrop(node.__tetrisLive.state);
          updateBackendState(node);
          node.setDirtyCanvas(true, true);
        },
      };
    }
  },
  async setup() {
    window.addEventListener("keydown", handleKey, true);
    window.addEventListener("keyup", handleKeyUp, true);
  },
});
