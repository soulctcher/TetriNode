import { app } from "../../scripts/app.js";

const EXT_NAME = "tetrinode.live";
const NODE_CLASS = "TetriNode";

const GRID_W = 10;
const GRID_H_TOTAL = 40;
const GRID_H_VISIBLE = 20;
const HIDDEN_ROWS = GRID_H_TOTAL - GRID_H_VISIBLE;
const EXTRA_VISIBLE_ROWS = 1 / 3;
const SPAWN_Y = HIDDEN_ROWS - 2;
const PREVIEW_GRID = 4;
const PREVIEW_SCALE = 0.86;
const BLOCK = 16;
const PADDING = 12;
const HEADER_H = 28;
const TOOLBAR_H = 44;
const CONTROL_GAP = 0;
const CONTROL_MIN = 110;
const DAS_MS = 300;
const ARR_MS = 56;
const IMAGE_CACHE = new Map();
const TETRINODE_VERSION = "1.3.0";
const LOAD_ICON_VIEWBOX = 1536;
const LOAD_ICON_PATH =
  "M751.50,1388.52C748.78,1387.75 742.88,1387.62 733.02,1388.11C725.06,1388.51 718.09,1388.55 717.52,1388.20C716.96,1387.84 659.35,1387.43 589.50,1387.27C136.44,1386.27 150.64,1386.39 137.10,1383.38C118.74,1379.30 103.81,1366.16 97.97,1348.95C94.86,1339.80 94.90,1325.05 98.05,1316.03C100.06,1310.28 104.55,1302.31 108.22,1298.00C115.11,1289.89 128.18,1282.95 140.06,1281.09C150.99,1279.37 201.24,1278.99 441.50,1278.81C569.10,1278.72 674.94,1278.32 676.70,1277.94C678.46,1277.55 680.10,1277.44 680.36,1277.69C680.61,1277.94 687.04,1278.06 694.66,1277.96C711.75,1277.73 713.75,1277.74 717.50,1278.04C719.15,1278.17 726.35,1278.18 733.50,1278.06C740.65,1277.95 747.29,1278.16 748.25,1278.53C749.39,1278.98 750.01,1278.74 750.02,1277.86C750.03,1276.77 750.21,1276.79 750.94,1277.94C751.65,1279.06 752.16,1279.11 753.28,1278.19C754.20,1277.42 756.61,1277.20 760.10,1277.57C763.07,1277.89 774.73,1278.12 786.00,1278.08C797.27,1278.04 818.88,1278.09 834.00,1278.18C865.00,1278.37 872.46,1278.38 886.00,1278.21C898.87,1278.06 899.31,1278.06 925.50,1278.19C938.15,1278.26 957.27,1278.26 968.00,1278.19C978.73,1278.12 991.89,1278.11 997.25,1278.15C1002.61,1278.20 1008.69,1278.23 1010.75,1278.23C1012.81,1278.23 1032.05,1278.26 1053.50,1278.30C1074.95,1278.34 1094.53,1278.37 1097.00,1278.37C1099.47,1278.38 1111.62,1278.27 1124.00,1278.13C1136.38,1277.99 1147.96,1278.18 1149.75,1278.55C1151.66,1278.95 1153.00,1278.82 1153.00,1278.25C1153.00,1277.17 1193.81,1277.08 1195.50,1278.16C1196.05,1278.51 1202.80,1278.64 1210.50,1278.44C1246.95,1277.49 1276.00,1277.51 1276.33,1278.48C1276.54,1279.10 1277.32,1278.97 1278.32,1278.14C1279.58,1277.10 1281.76,1276.97 1287.73,1277.56C1292.00,1277.98 1297.53,1278.21 1300.00,1278.06C1324.37,1276.61 1382.81,1279.27 1394.00,1282.35C1419.74,1289.43 1435.36,1313.80 1431.01,1340.11C1427.94,1358.66 1416.92,1373.28 1400.56,1380.52C1393.46,1383.66 1389.00,1384.55 1372.90,1386.04C1352.00,1387.98 1323.03,1388.19 1179.00,1387.40C1145.72,1387.22 1117.38,1387.08 1116.00,1387.10C1075.02,1387.64 1044.59,1387.88 1033.50,1387.75C1025.80,1387.66 1017.25,1387.60 1014.50,1387.62C1011.75,1387.63 996.45,1387.67 980.50,1387.70C964.55,1387.72 934.40,1387.81 913.50,1387.88C892.60,1387.96 849.64,1388.07 818.02,1388.14C786.41,1388.21 759.41,1388.58 758.02,1388.96C756.64,1389.34 753.70,1389.14 751.50,1388.52ZM751.61,1152.18C751.29,1151.66 749.00,1150.93 746.54,1150.56C744.07,1150.19 741.78,1149.46 741.46,1148.94C741.14,1148.42 740.26,1148.00 739.51,1148.00C738.00,1148.00 728.10,1142.18 726.50,1140.36C725.95,1139.73 723.48,1137.98 721.00,1136.46C718.52,1134.94 716.22,1133.27 715.88,1132.74C714.04,1129.93 706.63,1122.00 705.84,1122.00C704.86,1122.00 704.15,1121.49 699.75,1117.66C698.24,1116.35 697.00,1114.97 697.00,1114.60C697.00,1113.48 689.24,1106.00 688.08,1106.00C687.49,1106.00 687.00,1105.58 687.00,1105.07C687.00,1104.57 684.75,1101.87 682.00,1099.10C679.25,1096.32 677.00,1093.58 677.00,1093.02C677.00,1092.46 676.56,1092.00 676.01,1092.00C674.76,1092.00 671.47,1089.33 668.11,1085.58C663.21,1080.10 645.51,1061.70 643.12,1059.60C641.81,1058.44 636.77,1053.56 631.92,1048.75C627.06,1043.94 622.67,1040.00 622.16,1040.00C621.65,1040.00 620.47,1038.84 619.54,1037.42C618.60,1035.99 614.84,1031.80 611.17,1028.11C607.50,1024.41 601.93,1018.60 598.79,1015.19C595.65,1011.79 592.85,1009.00 592.56,1009.00C591.61,1009.00 581.00,997.62 580.96,996.55C580.94,995.97 578.91,994.22 576.44,992.66C573.97,991.09 571.17,988.68 570.23,987.30C569.28,985.92 565.63,982.03 562.11,978.65C558.60,975.27 554.10,970.77 552.11,968.65C550.13,966.54 547.41,963.84 546.07,962.65C543.21,960.12 536.49,953.35 521.80,938.19C515.91,932.12 510.51,926.78 509.80,926.33C509.08,925.87 506.47,922.96 504.00,919.85C499.47,914.16 494.83,910.51 493.64,911.69C493.29,912.05 493.00,911.60 493.00,910.70C493.00,909.80 491.65,908.06 490.00,906.84C488.35,905.62 487.00,904.24 487.00,903.78C487.00,902.96 482.75,898.63 477.87,894.48C476.57,893.37 474.38,890.94 473.00,889.07C471.62,887.20 469.23,884.51 467.67,883.09C460.13,876.18 457.63,873.42 454.32,868.36C451.44,863.95 448.40,861.00 446.74,861.00C445.47,861.00 444.01,859.16 443.57,857.00C443.22,855.30 441.73,854.17 440.46,854.66C439.45,855.04 439.16,854.75 439.55,853.74C439.90,852.83 438.26,850.28 435.31,847.14C425.18,836.38 422.45,830.46 422.58,819.50C422.73,806.73 426.79,798.71 436.38,792.26C441.81,788.61 444.74,787.74 457.50,786.02C462.45,785.35 467.78,784.33 469.34,783.74C470.91,783.16 473.91,782.75 476.01,782.83C478.12,782.91 482.14,782.54 484.96,782.01C487.78,781.47 508.18,780.78 530.29,780.47C552.41,780.17 574.86,779.46 580.19,778.91C585.52,778.36 591.60,777.99 593.69,778.08C602.97,778.48 616.19,772.35 619.83,765.94C620.75,764.33 621.84,763.01 622.25,763.01C622.66,763.00 623.00,762.33 623.00,761.50C623.00,760.67 623.45,760.00 624.00,760.00C624.55,760.00 625.00,758.87 625.00,757.49C625.00,756.10 625.43,754.19 625.95,753.24C628.39,748.79 629.89,744.04 630.47,738.95C630.81,735.89 631.03,710.69 630.95,682.95C630.70,599.99 630.64,414.01 630.86,392.00C630.97,380.73 631.07,359.80 631.08,345.50C631.16,261.24 631.90,201.54 632.99,192.00C633.64,186.22 634.54,178.12 634.97,174.00C637.85,146.44 644.14,130.65 657.59,117.25C661.04,113.81 664.28,111.00 664.78,111.00C665.29,111.00 667.45,109.75 669.60,108.23C675.04,104.36 684.02,99.89 685.05,100.53C685.53,100.83 686.72,100.63 687.71,100.09C689.50,99.10 698.75,97.48 700.36,97.86C700.83,97.98 701.76,97.61 702.43,97.05C703.11,96.50 706.10,95.83 709.08,95.58C714.38,95.13 748.53,93.18 752.50,93.10C764.47,92.87 788.34,93.09 788.89,93.43C789.28,93.67 794.98,94.12 801.55,94.43C808.12,94.73 815.30,95.46 817.50,96.06C819.70,96.65 823.08,97.53 825.00,98.01C842.31,102.36 846.13,104.03 857.12,112.06C873.46,124.00 882.83,138.60 885.49,156.27C885.72,157.80 886.12,159.38 886.37,159.79C887.44,161.52 888.93,176.62 889.50,191.50C889.83,200.30 890.49,210.43 890.96,214.00C892.03,222.25 891.93,217.39 891.91,262.50C891.90,283.95 891.90,302.40 891.91,303.50C892.52,353.19 892.97,402.82 892.95,417.50C892.94,427.95 892.97,452.48 893.02,472.00C893.13,516.81 893.13,518.33 893.05,542.83C893.01,554.01 893.24,563.57 893.55,564.08C893.86,564.59 893.61,565.00 892.98,565.00C892.24,565.00 892.07,566.03 892.49,567.94C892.84,569.56 893.30,605.22 893.50,647.19C893.70,689.16 894.12,726.65 894.44,730.50C895.54,743.76 896.15,748.00 896.94,748.00C897.38,748.00 897.98,750.12 898.27,752.71C898.62,755.83 899.51,757.99 900.90,759.12C902.06,760.06 903.00,761.29 903.00,761.87C903.00,764.30 911.20,770.90 916.25,772.53C919.14,773.46 922.40,774.78 923.50,775.46C924.60,776.14 928.88,776.99 933.00,777.36C937.12,777.73 944.33,778.42 949.00,778.90C953.67,779.38 967.17,779.85 979.00,779.94C1036.71,780.40 1044.49,780.92 1069.00,786.00C1090.77,790.52 1099.01,797.49 1101.99,813.94C1103.34,821.38 1102.62,826.79 1099.45,833.08C1096.79,838.35 1088.33,848.93 1082.80,853.92C1080.71,855.80 1079.00,857.95 1079.00,858.70C1079.00,859.45 1078.33,860.32 1077.50,860.64C1076.67,860.95 1076.00,861.73 1076.00,862.36C1076.00,863.82 1068.12,871.50 1066.63,871.50C1066.01,871.50 1065.50,871.96 1065.50,872.52C1065.50,873.79 1054.81,886.84 1053.70,886.93C1052.61,887.02 1036.00,903.96 1036.00,904.97C1036.00,905.42 1035.33,906.05 1034.50,906.36C1033.67,906.68 1033.00,907.53 1033.00,908.25C1033.00,908.98 1031.54,910.42 1029.75,911.45C1026.39,913.40 1006.43,932.87 999.18,941.28C996.91,943.90 994.71,946.10 994.28,946.15C992.23,946.42 991.00,947.34 991.00,948.61C991.00,949.37 990.59,950.00 990.08,950.00C989.57,950.00 987.44,951.79 985.33,953.97C983.22,956.15 981.05,958.40 980.50,958.97C979.95,959.54 977.14,962.29 974.25,965.09C971.36,967.88 969.00,970.53 969.00,970.97C969.00,971.41 967.99,972.44 966.75,973.26C963.52,975.39 948.00,990.80 948.00,991.87C948.00,992.36 947.11,993.00 946.01,993.29C944.92,993.57 943.59,994.95 943.06,996.36C942.52,997.76 940.78,999.58 939.18,1000.41C937.58,1001.23 933.20,1005.30 929.44,1009.45C925.68,1013.60 922.13,1017.01 921.55,1017.02C920.97,1017.03 919.22,1018.85 917.66,1021.06C916.09,1023.27 913.51,1026.04 911.91,1027.23C910.31,1028.41 909.00,1029.97 909.00,1030.69C909.00,1031.41 908.63,1032.00 908.19,1032.00C907.74,1032.00 902.45,1036.97 896.44,1043.05C870.52,1069.23 867.75,1072.00 867.47,1072.00C866.68,1072.00 850.00,1089.01 850.00,1089.82C850.00,1090.34 849.10,1091.00 848.00,1091.29C846.90,1091.58 846.00,1092.48 846.00,1093.29C846.00,1094.10 845.10,1095.00 844.00,1095.29C842.90,1095.58 842.00,1096.53 842.00,1097.41C842.00,1098.28 841.33,1099.00 840.50,1099.00C839.67,1099.00 839.00,1099.45 839.00,1100.01C839.00,1100.56 837.88,1101.99 836.50,1103.19C835.12,1104.38 834.00,1105.77 834.00,1106.28C834.00,1107.42 828.11,1113.00 826.90,1113.00C825.42,1113.00 821.00,1117.27 821.00,1118.70C821.00,1119.44 819.91,1120.54 818.58,1121.15C817.24,1121.75 815.88,1123.34 815.55,1124.67C815.21,1125.99 814.50,1126.81 813.97,1126.48C813.44,1126.15 813.00,1126.36 813.00,1126.94C813.00,1127.52 812.48,1128.00 811.85,1128.00C811.22,1128.00 809.21,1129.46 807.40,1131.25C802.36,1136.20 801.24,1137.00 799.29,1137.02C797.77,1137.03 797.73,1137.18 799.00,1138.00C800.05,1138.68 800.11,1138.97 799.22,1138.98C797.45,1139.01 784.00,1147.11 784.00,1148.16C784.00,1148.62 783.66,1148.95 783.25,1148.88C782.84,1148.82 782.27,1148.84 782.00,1148.94C773.03,1152.10 752.89,1154.25 751.61,1152.18Z";
let LOAD_ICON_PATH2D = null;
const RESET_ICON_VIEWBOX = 1536;
const RESET_ICON_PATH =
  "M742.67,1305.35C742.58,1305.27 736.06,1304.94 728.19,1304.62C720.32,1304.30 713.42,1303.76 712.87,1303.42C712.31,1303.08 708.63,1302.65 704.68,1302.47C691.20,1301.87 672.89,1299.72 665.88,1297.93C663.90,1297.42 660.97,1296.99 659.38,1296.99C657.80,1296.98 654.02,1296.28 651.00,1295.44C647.98,1294.59 643.25,1293.51 640.50,1293.03C635.32,1292.12 633.55,1291.69 631.00,1290.74C630.17,1290.44 626.12,1289.42 622.00,1288.48C617.88,1287.55 613.77,1286.41 612.87,1285.96C611.98,1285.51 609.50,1284.82 607.37,1284.44C605.24,1284.05 603.05,1283.41 602.50,1283.01C601.62,1282.37 597.43,1281.05 594.50,1280.49C593.95,1280.39 593.16,1280.18 592.75,1280.03C592.34,1279.87 591.66,1279.68 591.25,1279.60C587.34,1278.82 581.00,1276.58 581.00,1275.98C581.00,1275.56 579.31,1274.91 577.25,1274.52C575.19,1274.14 573.05,1273.46 572.50,1273.02C571.95,1272.58 567.90,1270.96 563.50,1269.43C559.10,1267.90 554.61,1266.05 553.53,1265.32C552.44,1264.60 550.85,1264.00 549.99,1264.00C549.13,1264.00 543.87,1261.75 538.29,1259.00C532.72,1256.25 527.45,1254.00 526.58,1254.00C525.71,1254.00 525.00,1253.55 525.00,1253.00C525.00,1252.45 524.53,1252.00 523.95,1252.00C523.36,1252.00 520.78,1251.02 518.20,1249.81C515.61,1248.61 512.97,1247.53 512.31,1247.41C511.66,1247.29 509.86,1246.03 508.32,1244.60C506.78,1243.17 505.14,1242.00 504.66,1242.00C504.19,1242.00 502.61,1241.16 501.15,1240.14C499.69,1239.12 496.76,1237.71 494.63,1237.02C492.51,1236.33 489.92,1234.92 488.88,1233.88C487.85,1232.85 486.24,1232.00 485.30,1232.00C483.57,1232.00 478.57,1228.92 471.55,1223.53C466.93,1219.99 464.76,1218.65 460.05,1216.43C458.15,1215.54 454.78,1213.33 452.55,1211.54C450.32,1209.74 447.49,1207.74 446.25,1207.10C445.01,1206.45 444.00,1205.38 443.99,1204.71C443.99,1204.05 442.98,1202.99 441.74,1202.36C432.61,1197.70 430.22,1196.13 425.27,1191.61C422.20,1188.80 418.62,1186.05 417.31,1185.50C414.80,1184.44 403.47,1174.33 394.07,1164.75C390.97,1161.59 388.08,1159.00 387.66,1159.00C386.84,1159.00 380.58,1152.84 372.90,1144.50C370.38,1141.75 366.78,1138.13 364.90,1136.46C360.40,1132.44 348.88,1119.61 344.88,1114.16C343.12,1111.77 340.17,1108.20 338.32,1106.24C336.46,1104.27 333.16,1100.04 330.97,1096.84C326.94,1090.93 325.83,1089.48 320.50,1083.09C316.88,1078.76 313.93,1074.62 308.34,1066.00C306.02,1062.42 303.61,1058.93 303.00,1058.23C302.38,1057.53 301.19,1055.30 300.34,1053.27C298.77,1049.51 290.27,1035.91 288.91,1034.99C288.50,1034.71 287.85,1033.24 287.47,1031.73C287.09,1030.22 286.41,1028.75 285.95,1028.47C285.50,1028.19 283.94,1025.38 282.48,1022.23C281.02,1019.08 279.35,1015.62 278.77,1014.54C278.19,1013.46 276.66,1010.58 275.36,1008.14C274.06,1005.70 272.53,1003.14 271.94,1002.43C270.81,1001.07 267.73,993.35 265.39,986.02C264.60,983.56 263.11,979.74 262.07,977.52C257.98,968.85 256.15,964.15 253.49,955.50C251.97,950.55 249.92,944.48 248.95,942.00C245.98,934.41 245.71,933.58 245.31,931.00C244.96,928.75 243.68,924.12 241.02,915.50C237.10,902.84 232.65,883.85 231.06,873.00C230.54,869.42 229.63,863.70 229.04,860.28C228.45,856.86 227.80,852.13 227.59,849.78C227.38,847.43 226.68,840.55 226.03,834.50C223.18,808.07 222.79,776.63 225.01,753.11C225.62,746.72 226.51,736.77 227.01,731.00C227.50,725.23 228.85,715.10 230.02,708.50C231.18,701.90 232.56,693.58 233.08,690.00C233.60,686.42 234.49,682.15 235.06,680.50C235.63,678.85 236.74,674.12 237.51,670.00C238.29,665.88 239.88,659.12 241.05,655.00C242.23,650.88 244.27,643.49 245.58,638.59C246.90,633.69 248.64,628.68 249.44,627.46C250.24,626.23 250.84,624.39 250.77,623.37C250.59,620.70 256.88,602.12 260.12,595.76C260.60,594.81 261.00,593.40 261.00,592.64C261.00,591.87 261.63,590.72 262.40,590.09C263.16,589.45 264.08,587.38 264.43,585.50C264.79,583.61 265.62,581.49 266.29,580.78C266.96,580.08 268.36,577.02 269.42,574.00C270.47,570.98 272.38,566.93 273.67,565.02C274.95,563.10 276.00,561.16 276.00,560.69C276.00,560.23 277.80,556.77 280.00,553.00C282.20,549.23 284.00,545.20 284.00,544.04C284.00,542.89 284.68,541.68 285.50,541.36C286.33,541.05 287.00,539.90 287.00,538.82C287.00,537.74 288.24,534.97 289.75,532.66C294.59,525.27 294.98,524.61 298.34,518.00C302.88,509.07 306.57,503.14 312.85,494.69C315.79,490.74 318.59,486.49 319.07,485.25C319.56,484.01 320.34,483.00 320.81,483.00C321.28,483.00 322.30,481.78 323.08,480.29C323.86,478.79 326.41,475.56 328.75,473.11C331.09,470.65 333.00,468.07 333.00,467.36C333.00,466.65 333.82,465.27 334.81,464.29C335.81,463.31 338.36,460.25 340.49,457.50C342.61,454.75 345.06,451.82 345.93,451.00C346.80,450.18 349.18,447.22 351.20,444.44C353.23,441.66 356.17,438.28 357.73,436.94C359.29,435.60 361.36,433.25 362.33,431.72C363.29,430.19 366.28,426.82 368.97,424.22C371.66,421.62 378.12,415.34 383.32,410.25C388.52,405.16 393.01,401.00 393.28,401.00C393.56,401.00 396.05,398.86 398.82,396.25C403.49,391.85 407.94,387.92 417.13,380.09C419.13,378.39 421.17,377.00 421.67,377.00C422.17,377.00 424.59,374.95 427.04,372.44C429.49,369.92 434.05,366.31 437.18,364.41C440.30,362.50 443.00,360.59 443.18,360.16C443.61,359.10 459.66,348.00 460.76,348.00C461.23,348.00 462.50,347.21 463.56,346.24C464.63,345.28 466.62,343.93 468.00,343.25C471.85,341.35 474.43,339.61 475.23,338.38C475.63,337.77 477.31,336.70 478.98,336.01C480.64,335.32 482.00,334.36 482.00,333.88C482.00,333.40 482.48,333.00 483.07,333.00C483.66,333.00 487.37,331.04 491.32,328.64C498.12,324.51 505.18,320.56 513.00,316.49C514.92,315.48 517.17,314.30 518.00,313.85C518.83,313.40 521.52,312.08 524.00,310.91C526.48,309.74 531.55,307.29 535.27,305.47C538.99,303.66 543.94,301.86 546.27,301.47C548.60,301.09 551.62,300.22 553.00,299.55C561.62,295.33 566.92,293.27 580.50,288.88C585.45,287.28 591.52,285.27 594.00,284.40C596.48,283.54 599.62,282.62 601.00,282.34C602.38,282.07 604.40,281.47 605.50,281.02C606.60,280.56 608.40,279.87 609.50,279.49C612.54,278.43 632.96,272.97 637.50,272.00C639.70,271.53 643.30,270.68 645.50,270.09C647.70,269.51 657.33,267.89 666.90,266.49C676.47,265.08 684.62,263.73 685.02,263.49C685.41,263.24 688.16,262.78 691.12,262.46C694.08,262.14 698.75,261.48 701.50,260.99C719.93,257.70 783.02,258.04 804.00,261.55C808.67,262.33 816.10,263.18 820.50,263.44C824.90,263.70 829.62,264.16 831.00,264.45C832.38,264.74 837.33,265.68 842.00,266.53C855.55,268.99 869.02,271.75 875.50,273.37C880.95,274.74 885.54,276.07 900.50,280.61C903.25,281.45 908.88,283.01 913.00,284.09C917.12,285.16 921.85,286.65 923.50,287.41C925.15,288.16 927.62,289.08 929.00,289.45C930.38,289.82 932.40,290.55 933.50,291.07C934.60,291.59 939.26,293.32 943.86,294.92C948.46,296.51 952.71,298.31 953.31,298.91C953.91,299.51 954.80,300.00 955.28,300.00C956.33,300.00 968.91,305.81 978.00,310.49C981.58,312.34 989.00,316.14 994.50,318.95C1004.51,324.06 1006.99,325.46 1017.61,332.00C1020.74,333.93 1025.02,336.40 1027.12,337.50C1033.31,340.73 1051.00,355.88 1051.00,357.95C1051.00,358.41 1052.35,360.23 1054.00,362.00C1055.65,363.77 1057.00,365.79 1057.00,366.50C1057.00,367.21 1057.67,368.05 1058.50,368.36C1059.38,368.70 1060.00,370.20 1060.00,372.00C1060.00,373.68 1060.90,377.74 1062.00,381.01C1063.10,384.28 1064.14,387.87 1064.32,388.99C1064.49,390.10 1066.13,392.57 1067.98,394.48L1071.33,397.93L1077.41,394.53C1083.21,391.28 1089.27,386.25 1100.00,375.75C1102.67,373.14 1105.34,371.00 1105.93,371.00C1106.52,371.00 1107.00,370.63 1107.00,370.17C1107.00,369.71 1109.14,367.84 1111.75,366.01C1114.36,364.18 1117.62,361.66 1119.00,360.41C1124.77,355.15 1136.39,353.32 1147.50,355.92C1152.92,357.19 1153.96,357.88 1158.25,363.07C1160.86,366.23 1163.00,369.30 1163.00,369.90C1163.00,370.51 1163.45,371.00 1164.00,371.00C1164.55,371.00 1164.93,371.34 1164.84,371.75C1164.42,373.65 1166.36,378.00 1167.63,378.00C1168.98,378.00 1171.52,382.82 1170.63,383.70C1170.40,383.93 1171.29,385.29 1172.60,386.71C1173.92,388.13 1175.00,389.94 1175.00,390.73C1175.00,391.52 1176.80,395.80 1179.00,400.24C1181.20,404.68 1183.00,409.53 1183.00,411.02C1183.00,412.51 1184.12,415.38 1185.50,417.40C1186.88,419.43 1188.00,421.46 1188.00,421.91C1188.00,422.36 1189.36,426.02 1191.02,430.05C1192.68,434.08 1194.74,440.11 1195.60,443.44C1196.46,446.77 1197.57,449.93 1198.08,450.45C1198.58,450.97 1199.00,452.17 1199.00,453.12C1199.00,454.06 1199.34,454.98 1199.75,455.17C1200.16,455.35 1201.56,458.43 1202.85,462.00C1207.97,476.19 1212.81,490.67 1213.47,493.75C1213.85,495.54 1214.52,497.00 1214.97,497.00C1215.42,497.00 1216.51,498.81 1217.39,501.02C1218.92,504.84 1219.71,507.59 1222.02,517.25C1222.58,519.59 1223.44,522.40 1223.93,523.50C1225.22,526.41 1228.02,535.17 1228.39,537.50C1228.57,538.60 1229.43,541.19 1230.30,543.25C1231.18,545.31 1232.86,551.70 1234.04,557.46C1235.75,565.81 1235.96,568.59 1235.09,571.22C1234.38,573.39 1234.32,575.64 1234.93,577.76C1235.44,579.54 1235.53,581.00 1235.12,581.00C1234.71,581.00 1233.80,583.25 1233.10,586.00C1232.39,588.75 1231.41,591.00 1230.91,591.00C1230.41,591.00 1230.00,591.47 1230.00,592.04C1230.00,593.91 1225.60,599.08 1222.24,601.16C1220.43,602.28 1216.83,605.43 1214.23,608.15C1209.44,613.18 1205.09,616.12 1201.55,616.72C1200.48,616.90 1198.91,617.65 1198.05,618.38C1197.13,619.18 1194.68,619.61 1192.00,619.45C1189.53,619.30 1186.90,619.67 1186.17,620.27C1185.19,621.09 1184.62,621.01 1183.98,619.96C1183.26,618.80 1182.99,618.86 1182.44,620.30C1181.95,621.58 1181.43,621.77 1180.50,621.00C1179.20,619.92 1154.45,620.51 1150.50,621.72C1149.40,622.05 1147.15,622.40 1145.50,622.49C1139.37,622.81 1117.30,625.12 1111.50,626.03C1108.20,626.56 1101.49,627.23 1096.58,627.54C1091.68,627.84 1087.28,628.33 1086.81,628.62C1086.34,628.91 1083.83,629.32 1081.23,629.55C1076.84,629.92 1066.14,631.20 1065.00,631.48C1063.77,631.78 1052.99,633.08 1048.00,633.52C1044.97,633.78 1040.25,634.55 1037.50,635.23C1034.21,636.04 1023.78,636.47 1007.00,636.48L981.50,636.50L973.67,633.12C964.82,629.31 957.86,623.05 955.18,616.50C953.13,611.49 952.94,595.09 954.88,590.00C957.23,583.83 963.26,571.60 965.47,568.50C966.65,566.85 969.08,562.66 970.86,559.19C972.65,555.72 975.54,550.94 977.30,548.57C979.06,546.21 981.40,542.98 982.50,541.40C983.60,539.82 985.40,537.60 986.50,536.47C987.60,535.33 989.03,533.24 989.67,531.83C990.32,530.41 992.28,527.62 994.03,525.62C995.78,523.63 996.86,522.00 996.43,522.00C996.00,522.00 996.61,520.97 997.79,519.72C998.97,518.47 1000.96,515.59 1002.22,513.32C1008.36,502.22 1011.60,497.14 1014.99,493.28C1017.03,490.97 1020.14,486.13 1021.91,482.53C1023.68,478.94 1025.54,476.00 1026.04,476.00C1026.55,476.00 1027.24,474.91 1027.57,473.57C1027.91,472.24 1029.04,470.37 1030.09,469.42C1031.14,468.47 1032.00,467.09 1032.00,466.36C1032.00,465.63 1033.35,462.24 1035.00,458.84C1036.65,455.43 1038.00,451.85 1038.00,450.88C1038.00,449.91 1038.50,448.81 1039.10,448.44C1039.72,448.05 1039.95,446.52 1039.63,444.92C1039.32,443.36 1039.48,441.82 1039.99,441.50C1041.24,440.73 1039.62,436.62 1037.07,434.07C1035.40,432.40 1034.17,432.15 1029.78,432.58C1026.88,432.87 1023.98,433.27 1023.35,433.48C1022.30,433.83 1015.21,432.63 1002.50,429.97C999.75,429.40 992.50,426.47 986.39,423.46C980.27,420.46 974.76,418.00 974.14,418.00C973.51,418.00 973.00,417.55 973.00,417.00C973.00,416.45 972.12,416.00 971.05,416.00C969.98,416.00 968.74,415.41 968.30,414.68C967.86,413.95 962.10,410.75 955.50,407.56C948.90,404.38 942.04,400.67 940.25,399.33C938.46,397.99 935.53,396.42 933.75,395.84C931.96,395.26 927.24,393.26 923.26,391.39C919.28,389.53 915.50,388.00 914.86,388.00C914.22,388.00 909.15,386.27 903.60,384.15C890.83,379.28 883.91,376.86 882.00,376.58C881.17,376.46 879.23,375.83 877.68,375.18C876.14,374.53 874.38,374.00 873.77,374.00C873.17,374.00 870.39,373.34 867.59,372.53C861.96,370.90 843.64,366.27 840.50,365.68C839.40,365.47 837.83,365.05 837.00,364.74C836.17,364.44 832.35,363.66 828.50,363.01C824.65,362.36 819.02,361.40 816.00,360.88C812.98,360.36 809.38,359.74 808.00,359.51C793.34,356.99 726.68,356.64 704.50,358.96C700.10,359.42 696.19,359.61 695.82,359.38C695.44,359.15 694.88,359.38 694.57,359.88C694.26,360.38 690.74,361.10 686.75,361.48C682.76,361.85 677.92,362.54 676.00,363.01C674.08,363.48 670.13,364.08 667.23,364.34C662.15,364.81 660.03,365.35 642.59,370.61C638.24,371.93 634.18,373.00 633.58,373.00C632.97,373.00 628.88,374.16 624.49,375.58C615.38,378.53 615.75,378.42 610.75,379.45C608.69,379.88 607.00,380.59 607.00,381.03C607.00,381.48 605.62,382.14 603.93,382.51C602.25,382.89 599.66,383.82 598.18,384.59C596.71,385.36 594.70,385.99 593.73,385.99C591.15,386.00 580.61,390.45 575.02,393.89C572.37,395.52 568.36,397.41 566.11,398.08C563.87,398.76 561.28,400.14 560.36,401.15C559.44,402.17 558.20,403.01 557.60,403.02C556.11,403.04 545.27,408.62 535.50,414.39C515.63,426.12 514.11,427.10 503.56,435.00C501.73,436.38 499.22,438.18 497.99,439.00C496.76,439.82 495.25,440.98 494.63,441.57C494.01,442.15 492.15,443.49 490.50,444.54C486.20,447.27 478.31,453.81 473.37,458.75C471.03,461.09 468.73,463.00 468.25,463.00C467.44,463.00 453.58,475.36 450.07,479.22C449.20,480.16 444.00,485.65 438.50,491.41C428.92,501.45 424.73,506.13 419.77,512.35C418.52,513.93 416.71,516.06 415.75,517.10C414.79,518.15 414.00,519.23 414.00,519.51C414.00,519.80 412.09,522.46 409.75,525.43C404.12,532.59 398.77,539.88 397.52,542.11C396.96,543.10 393.01,549.04 388.75,555.31C384.49,561.57 380.99,567.10 380.97,567.60C380.96,568.09 379.61,570.27 377.97,572.43C376.34,574.59 375.00,576.99 375.00,577.77C375.00,578.55 374.19,580.39 373.21,581.85C372.22,583.31 370.32,586.98 368.99,590.00C367.65,593.02 365.60,597.08 364.43,599.00C363.27,600.92 361.52,604.98 360.54,608.00C359.57,611.02 357.87,615.08 356.77,617.00C355.67,618.92 353.64,623.88 352.26,628.00C350.89,632.12 349.43,635.95 349.03,636.50C348.29,637.51 346.53,643.10 340.97,662.00C339.27,667.77 337.23,673.92 336.44,675.65C335.65,677.38 335.00,679.94 335.00,681.34C335.00,682.73 334.56,685.04 334.01,686.46C333.01,689.10 332.42,691.74 331.42,698.00C331.11,699.92 330.25,704.65 329.52,708.50C327.82,717.37 327.21,721.76 326.46,730.50C326.12,734.35 325.38,740.20 324.81,743.50C324.24,746.81 323.81,762.74 323.85,779.00C323.93,808.17 325.46,832.34 328.44,851.50C330.05,861.88 335.40,886.29 336.96,890.39C337.54,891.92 337.78,893.55 337.49,894.01C337.20,894.48 337.42,895.14 337.98,895.49C338.54,895.84 339.00,897.10 338.99,898.31C338.97,901.89 346.27,923.93 351.79,937.00C361.66,960.33 366.27,970.61 367.49,972.00C368.22,972.83 372.25,980.21 376.45,988.41C380.65,996.61 385.08,1004.52 386.29,1006.00C387.51,1007.47 389.62,1010.59 391.00,1012.93C392.38,1015.26 394.92,1019.11 396.65,1021.46C398.38,1023.82 400.36,1026.82 401.04,1028.12C401.73,1029.43 403.79,1032.30 405.61,1034.50C407.44,1036.70 410.05,1039.85 411.41,1041.50C412.77,1043.15 415.00,1045.76 416.36,1047.31C417.72,1048.85 421.21,1053.24 424.11,1057.06C427.02,1060.88 429.73,1064.00 430.14,1064.00C430.90,1064.00 450.19,1083.15 458.12,1091.77C460.53,1094.39 463.62,1097.11 465.00,1097.80C466.38,1098.50 469.33,1100.74 471.57,1102.79C478.01,1108.66 484.61,1114.11 486.81,1115.36C487.92,1115.98 490.91,1117.96 493.46,1119.75C496.01,1121.54 498.44,1123.00 498.85,1123.00C499.27,1123.00 501.33,1124.58 503.43,1126.50C505.53,1128.42 507.42,1130.00 507.62,1130.00C507.82,1130.00 510.05,1131.58 512.57,1133.50C515.09,1135.42 517.79,1137.00 518.58,1137.00C519.36,1137.00 520.00,1137.40 520.00,1137.89C520.00,1138.38 522.14,1139.77 524.75,1140.99C527.36,1142.20 530.40,1144.02 531.50,1145.02C532.60,1146.02 538.23,1149.22 544.00,1152.12C549.77,1155.02 554.74,1157.74 555.04,1158.17C555.34,1158.59 557.41,1159.59 559.65,1160.38C561.88,1161.16 568.61,1164.13 574.61,1166.96C580.60,1169.80 586.40,1172.47 587.50,1172.91C588.60,1173.35 591.65,1174.67 594.28,1175.85C596.90,1177.03 599.91,1178.00 600.97,1178.00C602.02,1178.00 603.13,1178.40 603.43,1178.88C603.73,1179.37 606.12,1180.08 608.74,1180.47C611.36,1180.85 616.20,1182.27 619.50,1183.61C625.11,1185.90 647.14,1191.96 655.00,1193.38C656.92,1193.72 659.62,1194.27 661.00,1194.60C662.38,1194.93 667.10,1195.78 671.50,1196.51C675.90,1197.23 681.46,1198.32 683.86,1198.94C686.26,1199.56 690.98,1200.22 694.36,1200.41C697.74,1200.61 705.67,1201.31 712.00,1201.97C732.17,1204.08 783.17,1203.24 800.39,1200.52C805.40,1199.72 813.05,1198.83 817.39,1198.52C821.73,1198.22 828.71,1197.13 832.89,1196.09C837.08,1195.06 842.70,1193.94 845.40,1193.61C848.09,1193.27 850.79,1192.60 851.40,1192.11C852.79,1191.00 861.10,1188.96 867.00,1188.28C869.48,1188.00 871.73,1187.46 872.00,1187.07C872.27,1186.69 875.20,1185.55 878.50,1184.55C881.80,1183.55 884.95,1182.39 885.50,1181.99C886.05,1181.59 888.98,1180.67 892.00,1179.94C895.02,1179.22 898.78,1178.00 900.35,1177.24C901.91,1176.47 903.98,1175.70 904.94,1175.51C905.91,1175.33 911.47,1172.88 917.32,1170.09C923.16,1167.29 928.38,1165.00 928.90,1165.00C929.43,1165.00 933.83,1162.94 938.68,1160.43C943.53,1157.91 949.30,1154.94 951.50,1153.83C964.54,1147.24 972.11,1143.06 974.08,1141.36C974.95,1140.61 976.18,1140.00 976.82,1140.00C977.46,1140.00 980.00,1138.54 982.46,1136.75C989.34,1131.76 996.88,1127.00 997.91,1127.00C998.42,1127.00 998.98,1126.61 999.17,1126.14C999.35,1125.67 1004.00,1121.91 1009.50,1117.80C1015.00,1113.69 1020.12,1109.57 1020.87,1108.66C1021.63,1107.75 1022.69,1107.00 1023.23,1107.00C1024.31,1107.00 1032.30,1100.97 1032.83,1099.76C1033.02,1099.34 1033.48,1099.00 1033.85,1099.00C1034.79,1099.00 1045.05,1089.87 1052.69,1082.25C1056.13,1078.81 1059.33,1076.00 1059.80,1076.00C1060.27,1076.00 1067.88,1068.01 1076.73,1058.25C1085.57,1048.49 1093.87,1039.58 1095.16,1038.45C1096.45,1037.33 1099.08,1034.25 1101.00,1031.61C1102.92,1028.97 1106.53,1024.48 1109.00,1021.62C1111.47,1018.77 1115.30,1012.94 1117.49,1008.67C1119.69,1004.40 1122.95,999.24 1124.73,997.21C1126.51,995.17 1128.27,992.60 1128.62,991.50C1128.98,990.40 1129.57,989.27 1129.95,989.00C1132.17,987.36 1153.28,945.16 1157.95,933.00C1159.75,928.33 1161.85,923.15 1162.61,921.50C1163.37,919.85 1164.28,916.92 1164.64,915.00C1164.99,913.08 1165.63,911.05 1166.05,910.50C1167.28,908.90 1171.00,898.66 1171.00,896.86C1171.00,895.96 1172.11,891.91 1173.48,887.85C1174.84,883.80 1176.64,877.11 1177.48,872.99C1178.32,868.87 1179.20,864.60 1179.44,863.50C1179.67,862.40 1180.38,857.90 1181.00,853.50C1181.62,849.10 1182.35,844.38 1182.62,843.00C1185.15,829.94 1186.68,813.84 1186.90,797.89C1187.04,788.37 1187.31,780.31 1187.50,779.99C1187.97,779.25 1185.21,733.16 1184.65,732.21C1184.26,731.56 1183.71,727.30 1182.43,715.00C1182.17,712.52 1181.75,709.38 1181.50,708.00C1181.25,706.62 1180.76,703.25 1180.43,700.50C1180.09,697.75 1179.23,691.23 1178.52,686.00C1176.98,674.73 1177.06,660.83 1178.69,658.88C1179.33,658.11 1180.78,653.90 1181.93,649.52C1183.26,644.45 1185.10,640.21 1187.01,637.83C1188.66,635.78 1190.41,633.06 1190.90,631.77C1191.44,630.36 1192.69,629.37 1194.10,629.27C1195.38,629.17 1197.22,628.06 1198.19,626.80C1200.41,623.91 1200.44,623.00 1198.33,623.00C1196.40,623.00 1197.36,621.71 1199.53,621.39C1200.34,621.27 1201.00,621.81 1201.00,622.59C1201.00,623.37 1202.00,624.02 1203.25,624.05C1219.25,624.39 1238.00,626.60 1238.00,628.14C1238.00,628.61 1239.06,629.00 1240.37,629.00C1241.67,629.00 1243.80,629.84 1245.12,630.87C1246.43,631.90 1248.94,633.05 1250.70,633.44C1254.59,634.29 1264.49,644.60 1267.65,651.08C1270.39,656.73 1273.78,667.28 1274.61,672.75C1274.97,675.09 1275.65,677.00 1276.13,677.00C1276.61,677.00 1277.00,678.92 1277.00,681.28C1277.00,683.63 1277.63,686.46 1278.41,687.56C1279.18,688.67 1280.12,691.81 1280.51,694.54C1280.89,697.27 1281.81,702.42 1282.56,706.00C1283.31,709.58 1284.14,714.08 1284.41,716.00C1284.68,717.92 1285.37,722.65 1285.93,726.50C1287.63,738.07 1288.28,752.01 1288.55,782.00C1288.77,807.00 1288.51,812.83 1286.43,829.50C1285.12,839.95 1283.59,850.07 1283.03,851.99C1282.46,853.91 1282.00,857.84 1282.00,860.71C1282.00,863.58 1281.38,867.41 1280.62,869.22C1279.86,871.02 1278.22,877.00 1276.97,882.50C1273.92,895.89 1272.39,901.67 1270.56,906.73C1269.71,909.06 1268.81,912.43 1268.55,914.23C1268.29,916.03 1267.35,919.52 1266.45,922.00C1265.55,924.48 1264.65,927.71 1264.46,929.19C1264.27,930.68 1263.41,933.24 1262.55,934.90C1261.69,936.56 1260.83,939.17 1260.64,940.71C1260.45,942.24 1259.81,944.62 1259.23,946.00C1258.25,948.29 1256.90,951.78 1256.52,953.00C1256.13,954.21 1253.46,960.03 1250.36,966.41C1248.51,970.21 1247.00,973.90 1247.00,974.61C1247.00,975.33 1245.88,977.57 1244.50,979.60C1243.12,981.62 1242.00,984.05 1242.00,984.99C1242.00,985.93 1240.81,988.91 1239.36,991.60C1233.13,1003.15 1224.50,1020.59 1224.49,1021.66C1224.48,1022.30 1223.73,1023.65 1222.83,1024.66C1219.87,1027.98 1212.00,1040.24 1212.00,1041.53C1212.00,1042.22 1211.33,1043.05 1210.50,1043.36C1209.67,1043.68 1209.00,1044.85 1209.00,1045.97C1209.00,1047.09 1208.60,1048.00 1208.11,1048.00C1207.63,1048.00 1206.44,1049.69 1205.47,1051.75C1204.50,1053.81 1203.41,1055.72 1203.06,1056.00C1202.20,1056.67 1193.00,1069.97 1193.00,1070.55C1193.00,1070.80 1192.31,1071.79 1191.46,1072.75C1187.06,1077.76 1185.00,1081.00 1185.00,1082.89C1185.00,1084.05 1184.38,1085.00 1183.63,1085.00C1182.88,1085.00 1181.14,1086.69 1179.76,1088.75C1178.38,1090.81 1174.72,1095.18 1171.62,1098.45C1168.53,1101.73 1166.00,1104.74 1166.00,1105.14C1166.00,1105.79 1163.85,1108.32 1155.20,1117.86C1153.94,1119.25 1152.22,1121.85 1151.37,1123.64C1150.52,1125.42 1148.63,1127.66 1147.16,1128.61C1143.78,1130.81 1130.00,1144.83 1130.00,1146.07C1130.00,1146.58 1129.55,1147.00 1129.00,1147.00C1128.45,1147.00 1126.28,1148.72 1124.17,1150.83C1122.07,1152.93 1119.59,1154.94 1118.67,1155.30C1117.75,1155.65 1117.00,1156.57 1117.00,1157.35C1117.00,1158.12 1115.65,1159.32 1114.00,1160.00C1112.35,1160.68 1111.00,1161.63 1111.00,1162.11C1111.00,1163.07 1105.07,1169.00 1104.10,1169.00C1103.57,1169.01 1098.30,1173.41 1093.92,1177.52C1093.04,1178.33 1091.92,1179.00 1091.41,1179.00C1090.90,1179.00 1089.08,1180.46 1087.36,1182.25C1083.56,1186.19 1077.58,1191.04 1074.37,1192.78C1073.07,1193.49 1072.00,1194.50 1072.00,1195.03C1072.00,1195.56 1071.33,1196.00 1070.50,1196.00C1069.67,1196.00 1069.00,1196.67 1069.00,1197.50C1069.00,1198.33 1068.47,1199.00 1067.82,1199.00C1066.27,1199.00 1056.00,1206.09 1056.00,1207.17C1056.00,1207.62 1055.33,1208.00 1054.50,1208.00C1053.67,1208.00 1052.10,1208.90 1051.00,1210.00C1049.90,1211.10 1048.80,1212.00 1048.55,1212.00C1048.30,1212.00 1047.00,1213.03 1045.64,1214.28C1044.29,1215.53 1042.34,1216.62 1041.31,1216.70C1039.49,1216.84 1031.43,1221.75 1025.63,1226.27C1024.05,1227.50 1020.90,1229.49 1018.63,1230.70C1016.36,1231.91 1014.05,1233.29 1013.50,1233.76C1012.95,1234.22 1011.15,1235.32 1009.50,1236.20C1007.85,1237.07 1004.02,1239.16 1001.00,1240.84C989.24,1247.36 971.89,1256.30 965.50,1259.11C962.75,1260.33 960.27,1261.39 960.00,1261.48C959.73,1261.57 958.38,1262.12 957.00,1262.71C951.05,1265.26 945.53,1267.51 945.03,1267.58C944.74,1267.63 943.15,1268.24 941.50,1268.95C939.85,1269.65 936.48,1270.82 934.00,1271.55C931.52,1272.27 924.57,1274.70 918.55,1276.93C912.53,1279.17 906.62,1281.00 905.43,1281.00C904.23,1281.00 902.68,1281.69 901.98,1282.52C901.28,1283.36 900.50,1283.83 900.23,1283.57C899.97,1283.30 898.04,1283.96 895.95,1285.03C893.85,1286.10 890.20,1287.15 887.82,1287.36C885.44,1287.58 880.58,1288.46 877.00,1289.32C859.29,1293.59 848.91,1295.91 843.00,1296.92C831.75,1298.84 815.71,1301.14 810.00,1301.65C806.98,1301.92 803.15,1302.54 801.50,1303.04C797.50,1304.25 777.08,1305.39 758.17,1305.45C749.74,1305.48 742.76,1305.43 742.67,1305.35ZM1198.50,619.00C1198.84,618.45 1199.32,618.00 1199.56,618.00C1199.80,618.00 1200.00,618.45 1200.00,619.00C1200.00,619.55 1199.52,620.00 1198.94,620.00C1198.36,620.00 1198.16,619.55 1198.50,619.00Z";
let RESET_ICON_PATH2D = null;
const PAUSE_ICON_VIEWBOX = 1536;
const PAUSE_ICON_PATH =
  "M577.00,1148.99C562.36,1148.18 560.05,1147.59 555.16,1143.48C550.87,1139.87 549.39,1136.71 548.64,1129.50C547.50,1118.66 546.58,905.92 547.26,812.50C547.28,810.30 547.22,755.17 547.14,690.00C547.06,624.83 547.04,570.60 547.09,569.50C547.15,568.40 547.14,560.75 547.07,552.50C546.78,518.78 548.20,413.05 549.02,407.05C550.02,399.78 551.83,396.81 557.87,392.54C562.01,389.61 562.26,389.57 579.78,388.86C603.55,387.90 653.56,387.93 674.31,388.91C690.64,389.68 691.24,389.79 695.31,392.61C697.77,394.31 700.42,397.37 701.74,400.01C703.89,404.33 704.01,406.07 704.95,446.00C705.78,480.82 706.30,555.98 705.99,594.50C705.95,600.00 705.98,655.80 706.05,718.50C706.13,781.20 706.18,846.45 706.17,863.50C706.15,880.55 706.16,895.62 706.19,897.00C706.22,898.38 706.21,902.88 706.18,907.00C706.16,911.12 706.10,942.17 706.07,976.00C706.00,1046.03 704.34,1129.70 702.91,1135.20C701.47,1140.75 697.64,1144.62 691.22,1147.02C685.74,1149.07 683.67,1149.16 638.01,1149.45C611.88,1149.61 584.42,1149.40 577.00,1148.99ZM858.47,1149.15C842.90,1148.56 841.02,1148.28 836.51,1145.96C832.72,1144.01 831.01,1142.31 829.11,1138.62C826.65,1133.84 826.64,1133.66 825.85,1093.87C825.42,1071.89 824.83,1053.54 824.55,1053.08C824.27,1052.63 824.06,1039.26 824.08,1023.38C824.10,1007.50 824.05,987.08 823.97,978.00C823.75,953.70 823.53,891.36 823.64,885.00C823.69,881.98 823.65,862.85 823.54,842.50C823.44,822.15 823.60,805.05 823.91,804.50C824.70,803.07 824.84,798.02 824.09,797.56C823.75,797.34 823.57,759.67 823.70,713.83C823.83,668.00 823.96,620.38 823.98,608.00C824.00,595.62 824.08,583.92 824.17,582.00C824.37,577.54 824.37,575.84 824.23,562.50C824.16,556.45 824.28,541.60 824.50,529.50C824.72,517.40 825.19,488.82 825.54,466.00C825.89,443.18 826.51,419.21 826.92,412.75C827.61,401.68 827.83,400.78 830.68,397.25C835.86,390.84 838.46,389.90 853.76,388.91C869.12,387.91 936.34,387.97 956.70,389.00C968.79,389.61 970.24,389.89 973.99,392.37C978.93,395.65 981.78,400.06 982.43,405.47C982.69,407.69 983.16,416.61 983.47,425.31C984.23,447.17 984.16,1093.26 983.39,1115.50C982.86,1130.95 982.47,1134.11 980.66,1137.84C978.11,1143.10 974.59,1145.75 967.70,1147.62C961.70,1149.24 887.88,1150.28 858.47,1149.15Z";
let PAUSE_ICON_PATH2D = null;
const PLAY_ICON_VIEWBOX = 1536;
const PLAY_ICON_PATH =
  "M417.30,1336.95C412.46,1335.99 403.57,1330.60 398.91,1325.80C393.75,1320.47 390.23,1311.74 388.91,1301.00C388.05,1293.94 387.92,1254.83 388.42,1149.00C388.98,1027.94 389.13,955.32 388.83,942.50C388.79,940.85 389.11,906.20 389.53,865.50C389.95,824.80 390.29,790.60 390.28,789.50C390.05,771.62 390.13,744.52 390.47,725.00C390.70,711.52 391.14,666.52 391.45,625.00C391.75,583.48 392.23,523.62 392.50,492.00C392.77,460.38 393.25,402.77 393.57,364.00C393.89,325.23 394.52,285.35 394.96,275.38C395.71,258.65 395.99,256.78 398.55,251.06C401.88,243.65 409.99,235.87 416.83,233.54C422.44,231.63 432.48,231.55 437.62,233.37C443.54,235.47 459.59,245.50 483.50,262.04C485.15,263.18 508.32,278.61 535.00,296.32C561.67,314.03 586.20,330.36 589.50,332.60C596.76,337.54 607.30,344.56 645.38,369.79C661.40,380.41 676.75,390.66 679.50,392.59C682.25,394.51 685.85,396.95 687.50,398.00C690.98,400.21 702.74,408.08 777.94,458.50C808.30,478.85 834.90,496.62 837.06,498.00C839.22,499.38 848.08,505.28 856.75,511.12C865.41,516.96 879.92,526.61 889.00,532.57C898.08,538.52 905.95,543.78 906.50,544.25C907.05,544.72 910.42,546.96 914.00,549.22C919.45,552.68 961.11,580.31 967.50,584.71C968.60,585.47 978.62,592.03 989.77,599.30C1000.91,606.56 1011.49,613.47 1013.27,614.65C1015.05,615.83 1020.55,619.41 1025.50,622.59C1033.65,627.84 1047.69,637.07 1110.50,678.50C1121.50,685.76 1142.65,699.70 1157.50,709.49C1172.35,719.28 1192.30,732.51 1201.82,738.89C1211.35,745.28 1219.90,751.00 1220.82,751.61C1224.00,753.72 1243.20,766.51 1246.93,769.00C1255.02,774.41 1259.85,779.24 1262.91,784.99C1265.62,790.07 1266.10,792.02 1266.12,798.06C1266.16,812.67 1261.07,820.09 1242.87,831.92C1229.34,840.71 1219.47,847.08 1217.15,848.50C1207.68,854.31 1174.37,875.27 1168.00,879.43C1164.42,881.76 1157.90,885.85 1153.50,888.51C1149.10,891.17 1142.35,895.44 1138.50,898.01C1134.65,900.58 1127.12,905.34 1121.76,908.59C1116.40,911.84 1109.43,916.16 1106.26,918.19C1103.09,920.22 1096.29,924.50 1091.14,927.69C1086.00,930.89 1079.92,934.72 1077.64,936.22C1075.36,937.71 1071.92,939.87 1070.00,941.01C1068.08,942.16 1061.10,946.64 1054.50,950.99C1047.90,955.33 1037.78,961.76 1032.00,965.27C1021.22,971.84 1011.01,978.27 993.50,989.53C988.00,993.06 980.24,997.79 976.25,1000.04C972.27,1002.30 968.44,1004.68 967.75,1005.34C967.06,1006.00 964.02,1008.08 961.00,1009.97C951.92,1015.63 941.65,1022.14 939.10,1023.87C934.08,1027.28 932.03,1028.59 927.34,1031.39C923.00,1033.98 901.05,1047.71 892.00,1053.49C873.46,1065.32 863.23,1071.78 842.25,1084.86C835.51,1089.06 824.71,1095.88 818.25,1100.00C811.79,1104.12 805.13,1108.24 803.45,1109.15C801.77,1110.05 798.77,1111.85 796.78,1113.15C792.90,1115.68 774.66,1127.35 766.50,1132.53C763.75,1134.27 757.45,1138.27 752.50,1141.41C747.55,1144.56 738.78,1150.04 733.01,1153.61C727.23,1157.17 721.61,1160.75 720.51,1161.55C718.51,1163.01 716.79,1164.09 698.26,1175.50C692.90,1178.80 685.76,1183.30 682.39,1185.50C679.02,1187.70 674.30,1190.68 671.88,1192.13C664.65,1196.47 648.16,1206.85 637.30,1213.89C631.70,1217.52 624.16,1222.30 620.56,1224.50C611.74,1229.89 592.92,1241.73 579.50,1250.31C553.64,1266.87 553.04,1267.25 539.50,1275.52C533.45,1279.22 528.35,1282.64 528.17,1283.12C527.98,1283.60 527.42,1284.00 526.92,1284.00C526.15,1284.00 517.34,1289.35 503.00,1298.54C501.07,1299.78 491.18,1305.88 481.00,1312.11C470.82,1318.33 461.06,1324.34 459.29,1325.46C449.11,1331.92 446.47,1333.31 440.08,1335.54C432.75,1338.10 425.41,1338.55 417.30,1336.95Z";
let PLAY_ICON_PATH2D = null;
const SETTINGS_ICON_VIEWBOX = 1536;
const SETTINGS_ICON_PATH =
  "M735.50,1385.84C717.16,1384.98 711.75,1384.34 707.37,1382.51C705.38,1381.68 702.94,1381.00 701.94,1381.00C700.93,1381.00 698.63,1380.13 696.81,1379.07C694.99,1378.01 691.70,1376.82 689.50,1376.43C685.59,1375.73 676.00,1370.28 676.00,1368.77C676.00,1368.34 675.34,1368.00 674.53,1368.00C673.71,1368.00 672.30,1366.54 671.39,1364.75C670.47,1362.96 669.41,1361.28 669.03,1361.00C667.31,1359.75 658.79,1338.76 654.84,1326.00C653.22,1320.78 650.81,1311.78 649.48,1306.00C648.16,1300.22 646.16,1291.94 645.04,1287.59C643.92,1283.24 643.00,1278.84 643.00,1277.80C643.00,1276.77 642.38,1274.93 641.61,1273.71C640.85,1272.50 639.93,1269.70 639.56,1267.50C637.85,1257.14 630.91,1242.85 625.24,1238.00C623.73,1236.71 620.31,1233.71 617.64,1231.33C614.97,1228.95 612.18,1227.00 611.43,1227.00C610.69,1227.00 603.15,1223.62 594.66,1219.50C586.18,1215.38 578.92,1212.00 578.52,1212.00C578.13,1212.00 576.50,1211.07 574.90,1209.93C573.31,1208.79 572.00,1208.15 572.00,1208.49C572.00,1208.84 569.41,1207.79 566.25,1206.16C557.40,1201.61 552.08,1199.33 545.11,1197.08C541.60,1195.95 538.21,1194.59 537.58,1194.07C536.07,1192.81 522.47,1190.00 517.92,1190.00C512.19,1190.00 502.81,1192.01 498.86,1194.09C496.86,1195.14 494.68,1196.00 494.02,1196.00C493.35,1196.00 491.61,1196.84 490.15,1197.87C488.69,1198.89 484.37,1201.44 480.55,1203.53C475.02,1206.55 457.87,1218.33 452.45,1222.83C451.88,1223.31 450.96,1223.88 450.41,1224.10C449.86,1224.32 445.48,1226.97 440.68,1230.00C435.87,1233.03 431.10,1235.97 430.08,1236.54C429.05,1237.11 427.60,1238.09 426.85,1238.71C426.11,1239.33 423.02,1240.81 420.00,1242.00C416.97,1243.19 413.82,1244.75 413.00,1245.46C410.76,1247.41 401.47,1249.78 393.00,1250.56C388.88,1250.94 384.44,1251.35 383.15,1251.47C380.36,1251.73 370.77,1248.01 368.17,1245.65C367.16,1244.74 366.03,1244.00 365.64,1244.00C365.26,1244.00 362.66,1242.20 359.88,1240.00C357.10,1237.80 354.22,1236.00 353.48,1236.00C352.75,1236.00 351.54,1235.44 350.81,1234.75C350.08,1234.06 346.33,1230.81 342.49,1227.52C332.28,1218.78 319.92,1206.30 315.24,1200.00C312.99,1196.97 309.05,1192.25 306.48,1189.50C303.91,1186.75 301.07,1183.38 300.16,1182.00C299.26,1180.62 297.05,1177.55 295.26,1175.17C293.47,1172.79 292.00,1170.30 292.00,1169.64C292.00,1168.98 290.42,1165.99 288.50,1163.00C286.57,1160.01 285.00,1156.31 285.00,1154.78C285.00,1153.25 284.55,1152.00 284.00,1152.00C283.45,1152.00 283.00,1149.76 283.00,1147.02C283.00,1141.11 285.12,1128.00 286.08,1128.00C286.44,1128.00 287.04,1126.31 287.41,1124.25C287.77,1122.19 288.92,1118.92 289.97,1117.00C291.02,1115.08 292.59,1111.92 293.45,1110.00C294.32,1108.08 296.13,1104.47 297.47,1102.00C298.82,1099.53 300.78,1095.67 301.84,1093.44C302.90,1091.20 304.39,1088.73 305.16,1087.94C306.73,1086.31 314.63,1073.43 317.54,1067.75C318.59,1065.69 319.80,1064.00 320.23,1064.00C320.65,1064.00 321.00,1063.49 321.00,1062.86C321.00,1062.24 323.07,1058.59 325.59,1054.76C328.11,1050.93 330.99,1045.48 331.99,1042.65C332.98,1039.82 334.64,1035.54 335.68,1033.15C340.48,1022.07 333.11,995.38 313.89,954.31C312.30,950.91 311.00,947.84 311.00,947.50C311.00,945.29 300.82,926.41 296.80,921.15C292.08,914.98 284.76,909.03 279.22,906.86C273.81,904.74 257.61,900.14 253.50,899.56C252.40,899.40 250.38,899.01 249.00,898.67C247.62,898.34 244.93,897.88 243.00,897.65C241.07,897.41 238.38,896.78 237.00,896.24C235.62,895.71 231.87,894.94 228.65,894.55C225.42,894.15 220.70,893.22 218.15,892.48C215.59,891.74 212.15,890.94 210.49,890.69C205.60,889.97 189.58,885.84 188.50,885.02C187.95,884.61 185.03,883.48 182.00,882.52C178.97,881.55 174.47,879.51 172.00,877.97C169.53,876.42 165.81,874.37 163.75,873.40C161.69,872.42 160.00,871.26 160.00,870.81C160.00,870.37 159.32,870.00 158.50,870.00C157.68,870.00 157.00,869.52 157.00,868.94C157.00,868.36 156.61,868.13 156.12,868.42C155.64,868.72 154.96,867.15 154.61,864.94C154.25,862.73 153.30,860.67 152.49,860.36C151.68,860.05 150.34,857.53 149.52,854.77C148.70,852.00 147.65,849.24 147.19,848.62C145.71,846.65 143.10,838.68 142.08,833.00C141.54,829.98 140.39,823.90 139.53,819.50C137.72,810.16 137.36,777.64 138.98,769.10C139.54,766.14 140.03,761.88 140.06,759.61C140.11,756.16 141.74,748.93 144.60,739.50C144.93,738.40 145.45,736.18 145.74,734.56C146.04,732.94 147.02,730.82 147.92,729.86C148.81,728.89 150.43,725.49 151.50,722.30C153.85,715.30 159.40,708.97 165.86,705.94C168.41,704.75 171.62,703.01 173.00,702.09C175.80,700.22 185.17,696.46 189.00,695.67C191.82,695.09 201.29,692.60 211.00,689.90C217.76,688.01 230.52,685.39 240.00,683.94C247.92,682.72 257.32,680.62 258.61,679.77C259.23,679.38 262.38,678.76 265.61,678.41C268.85,678.05 272.40,677.21 273.50,676.54C274.60,675.87 276.85,674.99 278.50,674.59C282.12,673.72 292.88,666.88 295.57,663.75C302.54,655.65 310.49,640.29 316.14,624.03C317.19,621.02 319.83,614.86 322.02,610.34C324.21,605.82 326.00,601.84 326.00,601.50C326.00,600.95 327.75,596.81 331.50,588.50C332.24,586.85 333.40,583.25 334.06,580.50C334.73,577.75 335.66,575.07 336.14,574.55C336.61,574.03 337.00,572.38 337.00,570.88C337.00,569.39 337.49,568.00 338.09,567.80C339.79,567.24 341.86,553.08 340.80,549.25C340.31,547.45 340.18,545.52 340.52,544.97C341.22,543.83 338.49,533.76 336.46,530.00C335.71,528.62 334.19,525.48 333.08,523.00C330.19,516.58 322.62,503.30 320.36,500.70C317.09,496.94 304.13,473.97 297.96,461.00C295.73,456.32 293.26,451.31 292.46,449.85C291.65,448.39 291.00,446.46 291.00,445.56C291.00,444.67 289.87,441.70 288.49,438.97C285.06,432.21 284.33,424.15 286.42,416.00C288.01,409.79 293.44,397.04 294.94,396.00C295.33,395.73 296.90,393.19 298.42,390.37C300.99,385.61 308.54,376.61 321.49,362.88C324.40,359.79 331.06,353.63 336.29,349.18C341.51,344.74 347.07,339.90 348.64,338.43C350.22,336.96 352.90,334.80 354.62,333.63C369.98,323.14 376.09,319.98 386.99,316.86C393.94,314.87 400.00,314.43 400.00,315.90C400.00,316.39 401.91,317.02 404.25,317.30C411.66,318.17 426.40,323.03 428.00,325.14C428.27,325.50 432.07,327.67 436.43,329.97C440.80,332.26 445.47,335.01 446.82,336.07C448.17,337.13 449.81,338.00 450.48,338.00C451.15,338.00 452.50,338.90 453.50,340.00C454.50,341.10 455.92,342.00 456.65,342.00C457.39,342.00 458.00,342.38 458.00,342.84C458.00,343.30 459.01,344.16 460.25,344.75C461.49,345.34 463.62,346.74 465.00,347.86C470.99,352.75 486.90,363.24 491.25,365.16C493.86,366.32 496.00,367.62 496.00,368.06C496.00,368.49 497.69,369.39 499.75,370.05C501.81,370.72 504.07,371.71 504.77,372.27C506.42,373.58 509.69,373.99 519.50,374.14C528.99,374.28 539.28,371.90 546.79,367.84C549.71,366.26 552.86,364.82 553.80,364.63C554.73,364.45 557.17,363.55 559.22,362.65C561.26,361.74 563.48,361.00 564.14,361.00C565.40,361.00 576.15,357.02 581.75,354.47C585.56,352.75 590.48,350.63 594.00,349.19C608.22,343.41 623.93,334.53 623.97,332.25C623.99,331.56 624.39,331.00 624.86,331.00C626.47,331.00 631.27,325.52 632.74,322.00C633.55,320.07 635.22,316.25 636.47,313.50C637.72,310.75 639.07,306.93 639.49,305.00C639.90,303.07 640.52,301.05 640.86,300.50C642.00,298.67 643.97,292.52 643.98,290.74C643.99,289.77 645.09,284.37 646.43,278.74C647.77,273.11 649.12,266.93 649.43,265.00C650.05,261.14 653.96,244.86 656.51,235.50C657.41,232.20 659.07,227.93 660.20,226.00C661.32,224.07 662.86,220.44 663.61,217.93C664.36,215.41 666.78,210.56 668.99,207.14C671.19,203.73 673.00,200.59 673.00,200.16C673.00,198.31 683.00,190.06 688.23,187.58C691.38,186.09 694.24,184.43 694.58,183.88C694.91,183.33 696.50,183.17 698.10,183.52C699.69,183.87 701.00,183.77 701.00,183.29C701.00,182.82 701.79,182.38 702.75,182.33C703.71,182.28 706.75,181.72 709.50,181.09C733.47,175.58 777.95,176.04 803.75,182.06C811.25,183.81 815.66,185.49 817.00,187.11C817.27,187.44 819.08,188.00 821.00,188.35C826.30,189.33 836.41,198.09 839.44,204.34C840.82,207.18 842.34,210.18 842.83,211.00C843.31,211.82 844.40,214.07 845.26,216.00C846.11,217.93 847.75,221.55 848.90,224.07C850.06,226.58 851.00,229.17 851.00,229.83C851.00,230.49 851.45,231.81 851.99,232.76C852.54,233.72 853.68,237.43 854.52,241.00C855.36,244.57 857.17,252.22 858.54,258.00C859.91,263.77 861.20,269.40 861.41,270.50C861.61,271.60 862.73,275.37 863.88,278.89C865.04,282.40 866.25,287.35 866.58,289.89C867.34,295.68 873.92,315.49 876.92,321.00C878.59,324.06 888.49,334.00 889.86,334.00C890.41,334.00 891.46,334.56 892.21,335.25C894.75,337.61 899.92,341.00 900.97,341.00C901.55,341.00 902.81,341.44 903.76,341.98C906.63,343.60 922.99,351.00 923.70,351.00C924.07,351.00 926.20,351.84 928.43,352.86C937.14,356.84 944.62,359.89 947.26,360.54C948.78,360.92 950.27,361.62 950.57,362.11C950.87,362.60 951.90,363.00 952.85,363.00C953.80,363.00 956.34,363.90 958.50,365.00C960.66,366.10 962.78,367.00 963.22,367.00C963.65,367.00 966.34,368.12 969.19,369.50C972.04,370.87 975.53,372.00 976.94,372.00C978.36,372.00 981.09,372.49 983.01,373.08C990.69,375.46 1005.07,373.53 1010.68,369.36C1012.43,368.06 1014.15,367.00 1014.49,367.00C1016.14,367.00 1024.26,362.69 1028.14,359.75C1030.54,357.93 1034.61,355.22 1037.18,353.72C1039.75,352.22 1042.59,350.27 1043.48,349.38C1045.16,347.70 1060.92,337.00 1061.71,337.00C1061.96,337.00 1064.04,335.49 1066.33,333.65C1068.62,331.82 1076.18,327.34 1083.13,323.70C1102.62,313.50 1118.45,311.15 1130.85,316.61C1136.63,319.15 1144.18,323.18 1147.88,325.69C1149.75,326.96 1151.69,328.00 1152.18,328.00C1153.23,328.00 1153.96,328.54 1160.00,333.78C1162.47,335.93 1165.22,338.10 1166.11,338.60C1168.51,339.94 1179.35,349.74 1185.29,355.93C1188.16,358.92 1192.76,363.64 1195.52,366.43C1201.37,372.35 1208.00,380.36 1208.00,381.51C1208.00,381.95 1209.24,383.92 1210.75,385.89C1214.63,390.94 1221.05,401.94 1222.19,405.50C1223.99,411.12 1224.81,421.92 1223.76,426.28C1223.21,428.60 1222.64,431.18 1222.51,432.00C1222.38,432.82 1222.04,434.18 1221.75,435.00C1221.46,435.82 1220.72,438.39 1220.09,440.70C1219.46,443.01 1216.49,449.88 1213.48,455.96C1210.46,462.05 1208.00,467.27 1208.00,467.58C1208.00,467.88 1206.82,469.68 1205.38,471.57C1203.94,473.46 1203.05,475.00 1203.40,475.00C1203.75,475.00 1202.45,477.30 1200.52,480.11C1198.58,482.92 1196.99,485.74 1196.97,486.36C1196.96,486.99 1195.61,488.81 1193.97,490.42C1192.34,492.02 1190.99,494.05 1190.98,494.92C1190.97,495.79 1190.08,497.62 1189.00,499.00C1187.92,500.38 1187.03,502.01 1187.02,502.63C1187.01,503.25 1186.33,504.31 1185.51,504.99C1184.69,505.67 1184.25,506.59 1184.53,507.04C1184.81,507.49 1184.57,508.15 1183.99,508.50C1181.88,509.81 1172.01,530.83 1172.00,534.05C1172.00,534.90 1171.49,536.11 1170.86,536.74C1169.18,538.42 1168.56,555.56 1169.94,562.24C1170.60,565.39 1171.07,568.09 1171.00,568.24C1170.92,568.38 1172.22,571.54 1173.89,575.26C1175.56,578.98 1177.82,584.83 1178.90,588.26C1181.34,595.95 1183.34,601.34 1184.00,602.00C1185.06,603.06 1188.00,610.14 1188.00,611.63C1188.00,612.49 1188.62,614.39 1189.38,615.85C1191.16,619.27 1192.15,621.58 1196.57,632.50C1198.57,637.45 1200.78,642.17 1201.47,643.00C1202.16,643.83 1203.00,645.65 1203.34,647.07C1203.67,648.48 1204.86,650.68 1205.97,651.97C1207.09,653.25 1208.00,654.71 1208.00,655.20C1208.00,655.68 1208.47,656.63 1209.04,657.29C1209.61,657.96 1211.38,660.33 1212.98,662.56C1215.90,666.63 1228.39,675.00 1231.54,675.00C1232.43,675.00 1236.38,676.08 1240.32,677.40C1244.27,678.72 1251.78,680.58 1257.00,681.53C1262.22,682.48 1269.20,683.89 1272.50,684.66C1275.80,685.42 1280.53,686.31 1283.00,686.62C1285.47,686.93 1287.95,687.52 1288.50,687.93C1289.45,688.64 1293.95,690.03 1306.75,693.60C1319.68,697.21 1330.57,701.88 1335.50,705.94C1336.60,706.84 1339.19,708.35 1341.25,709.28C1343.31,710.21 1345.00,711.45 1345.00,712.05C1345.00,712.65 1346.07,714.57 1347.38,716.32C1348.70,718.07 1350.10,720.62 1350.51,722.00C1350.91,723.38 1351.60,724.95 1352.04,725.50C1352.48,726.05 1353.78,728.98 1354.94,732.00C1356.11,735.03 1357.46,738.40 1357.97,739.50C1359.55,742.97 1361.75,752.21 1362.97,760.50C1364.91,773.70 1364.58,813.03 1362.41,825.65C1361.21,832.65 1357.67,843.80 1354.48,850.62C1352.56,854.70 1351.00,858.31 1351.00,858.64C1351.00,860.54 1345.09,868.07 1342.85,869.03C1341.39,869.65 1339.97,871.02 1339.69,872.08C1339.42,873.13 1338.36,874.29 1337.34,874.66C1336.33,875.02 1334.31,876.15 1332.85,877.16C1331.39,878.17 1329.47,879.00 1328.60,879.00C1327.72,879.00 1327.00,879.39 1327.00,879.86C1327.00,881.53 1297.74,889.96 1291.84,889.99C1290.37,889.99 1284.52,891.16 1278.84,892.57C1268.57,895.12 1263.08,896.29 1253.50,897.98C1243.04,899.83 1235.06,902.00 1231.59,903.95C1229.62,905.06 1228.00,905.76 1228.00,905.51C1228.00,905.26 1226.04,906.10 1223.64,907.37C1217.82,910.47 1209.90,918.58 1204.55,926.92C1200.03,933.97 1192.00,950.03 1192.00,952.01C1192.00,952.63 1190.03,957.27 1187.61,962.32C1184.04,969.79 1181.37,976.41 1180.46,980.00C1180.39,980.27 1179.81,981.77 1179.17,983.32C1178.52,984.86 1178.00,986.75 1178.00,987.51C1178.00,988.26 1177.59,989.14 1177.09,989.45C1176.06,990.08 1171.57,1004.08 1170.17,1011.00C1167.92,1022.07 1169.15,1031.74 1174.02,1041.54C1175.66,1044.82 1176.99,1048.21 1177.00,1049.08C1177.00,1049.94 1178.12,1051.71 1179.50,1053.00C1180.88,1054.29 1182.00,1056.25 1182.00,1057.35C1182.00,1058.44 1182.61,1060.05 1183.35,1060.92C1184.09,1061.79 1185.77,1064.53 1187.06,1067.00C1188.36,1069.47 1191.35,1074.49 1193.71,1078.13C1196.07,1081.78 1198.00,1085.12 1198.00,1085.56C1198.00,1085.99 1198.59,1087.05 1199.32,1087.92C1200.05,1088.79 1201.90,1092.42 1203.44,1096.00C1208.24,1107.14 1209.39,1109.45 1211.01,1111.21C1211.87,1112.15 1213.39,1115.30 1214.38,1118.21C1215.37,1121.12 1216.43,1124.17 1216.74,1125.00C1217.05,1125.83 1217.47,1127.38 1217.68,1128.46C1217.88,1129.53 1218.43,1130.66 1218.89,1130.96C1220.78,1132.19 1220.59,1155.74 1218.67,1157.66C1218.30,1158.03 1218.00,1159.14 1218.00,1160.13C1218.00,1161.84 1215.77,1167.74 1213.89,1171.00C1213.42,1171.83 1212.34,1174.04 1211.49,1175.92C1210.65,1177.80 1209.07,1179.96 1207.98,1180.73C1206.89,1181.49 1206.00,1182.99 1206.00,1184.06C1206.00,1185.13 1205.66,1186.01 1205.25,1186.02C1204.84,1186.03 1203.15,1188.27 1201.50,1191.01C1199.85,1193.74 1197.71,1196.24 1196.75,1196.56C1195.79,1196.87 1195.00,1197.51 1195.00,1197.98C1195.00,1198.44 1191.85,1202.08 1188.00,1206.07C1184.15,1210.06 1181.00,1213.44 1181.00,1213.58C1181.00,1214.19 1167.72,1226.54 1166.67,1226.91C1165.21,1227.41 1156.62,1234.23 1156.17,1235.25C1155.98,1235.66 1155.27,1236.00 1154.57,1236.00C1153.88,1236.00 1152.45,1236.96 1151.40,1238.14C1150.36,1239.31 1148.15,1240.92 1146.50,1241.70C1142.07,1243.80 1138.97,1245.63 1137.72,1246.88C1137.10,1247.50 1135.55,1248.00 1134.26,1248.00C1132.98,1248.00 1130.89,1248.68 1129.61,1249.52C1128.31,1250.37 1123.83,1251.30 1119.39,1251.62C1112.32,1252.15 1110.46,1251.87 1101.50,1248.98C1092.05,1245.93 1078.89,1239.64 1078.17,1237.83C1077.98,1237.37 1077.31,1237.00 1076.67,1237.00C1076.03,1237.00 1072.42,1234.97 1068.66,1232.50C1064.89,1230.02 1061.55,1228.00 1061.24,1228.00C1060.92,1228.00 1059.95,1227.38 1059.08,1226.61C1058.21,1225.85 1055.14,1224.00 1052.25,1222.51C1049.36,1221.01 1047.00,1219.49 1047.00,1219.13C1047.00,1218.77 1046.16,1218.03 1045.14,1217.49C1042.53,1216.10 1034.60,1210.83 1034.00,1210.08C1032.85,1208.65 1026.72,1205.17 1014.00,1198.76L1000.50,1191.95L989.29,1192.32C982.81,1192.54 977.48,1193.18 976.68,1193.85C975.91,1194.49 973.48,1195.19 971.27,1195.40C969.06,1195.61 966.19,1196.47 964.88,1197.30C963.57,1198.14 959.38,1199.77 955.58,1200.93C951.77,1202.09 947.99,1203.59 947.17,1204.27C946.36,1204.95 945.65,1205.36 945.60,1205.18C945.54,1205.00 944.23,1205.34 942.68,1205.93C941.14,1206.52 939.50,1207.00 939.05,1207.00C938.60,1207.00 933.79,1209.05 928.36,1211.56C922.94,1214.07 917.15,1216.74 915.50,1217.49C902.79,1223.26 892.05,1228.63 889.66,1230.40C882.44,1235.74 871.09,1248.30 868.54,1253.78C867.07,1256.92 865.45,1260.28 864.94,1261.24C864.42,1262.19 864.00,1263.79 864.00,1264.79C864.00,1265.78 863.61,1267.03 863.13,1267.55C861.82,1268.97 858.21,1282.39 856.01,1294.00C854.80,1300.40 851.12,1312.93 849.73,1315.40C849.08,1316.56 848.02,1319.75 847.38,1322.50C844.86,1333.25 836.51,1354.83 834.03,1357.00C833.71,1357.28 832.61,1358.85 831.57,1360.50C830.53,1362.15 827.93,1365.02 825.79,1366.87C823.65,1368.72 822.15,1370.48 822.44,1370.78C823.47,1371.81 820.74,1374.00 818.44,1374.00C817.16,1374.00 815.87,1374.40 815.56,1374.90C814.70,1376.29 807.14,1380.00 805.16,1380.00C804.18,1380.00 800.03,1380.86 795.94,1381.91C780.96,1385.76 761.17,1387.05 735.50,1385.84ZM780.00,1042.59C788.84,1041.92 812.03,1038.21 813.32,1037.26C813.97,1036.79 816.08,1036.29 818.00,1036.15C819.92,1036.02 822.62,1035.50 824.00,1035.01C825.38,1034.51 829.65,1033.19 833.50,1032.08C837.35,1030.96 844.33,1028.41 849.00,1026.40C853.67,1024.40 860.20,1021.76 863.50,1020.53C869.48,1018.31 880.43,1012.65 891.61,1006.00C894.85,1004.08 897.95,1002.33 898.50,1002.12C899.05,1001.91 901.30,1000.32 903.50,998.59C905.70,996.87 909.41,994.17 911.75,992.59C914.09,991.02 916.00,989.37 916.00,988.93C916.00,988.49 916.88,987.85 917.96,987.51C919.92,986.89 925.39,981.95 940.50,967.15C948.67,959.15 951.02,956.60 959.10,946.98C974.98,928.07 992.44,899.99 999.08,882.65C1000.17,879.82 1001.49,876.60 1002.01,875.50C1002.54,874.40 1003.63,871.02 1004.44,868.00C1005.24,864.98 1007.30,858.45 1009.00,853.50C1012.18,844.28 1015.14,832.04 1014.47,830.95C1014.26,830.62 1014.77,828.13 1015.59,825.42C1017.39,819.49 1017.73,815.52 1018.34,793.50C1018.98,770.14 1016.49,734.68 1013.97,731.50C1013.54,730.95 1012.95,728.48 1012.67,726.00C1012.38,723.52 1011.25,718.80 1010.16,715.50C1009.06,712.20 1007.38,706.80 1006.42,703.50C1003.69,694.13 995.54,674.12 991.97,668.00C991.48,667.17 989.44,663.58 987.43,660.00C985.42,656.42 982.18,651.02 980.23,648.00C971.66,634.67 971.12,633.87 968.49,630.72C967.93,630.05 965.90,627.48 963.99,625.00C956.38,615.17 934.50,592.93 925.14,585.50C912.83,575.75 903.45,568.99 900.00,567.39C898.08,566.50 896.27,565.46 896.00,565.07C894.31,562.70 868.35,548.06 865.74,548.01C865.32,548.01 860.82,546.00 855.74,543.56C850.66,541.12 845.15,538.81 843.50,538.42C841.85,538.04 840.05,537.39 839.50,536.98C838.20,536.01 831.86,534.55 830.25,534.86C829.56,534.98 829.00,534.62 829.00,534.04C829.00,533.47 828.14,533.00 827.08,533.00C826.02,533.00 820.29,531.82 814.33,530.39C808.37,528.95 801.92,527.64 800.00,527.49C798.08,527.33 792.45,526.39 787.50,525.39C780.23,523.93 773.69,523.59 753.50,523.61C728.34,523.63 718.17,524.63 703.50,528.54C700.75,529.28 696.25,530.15 693.50,530.48C688.92,531.04 679.40,533.82 674.50,536.04C673.40,536.53 669.58,537.90 666.00,539.07C662.42,540.24 656.58,542.54 653.00,544.17C643.42,548.56 629.57,555.41 629.00,556.05C628.73,556.36 624.51,558.76 619.64,561.37C614.76,563.99 610.26,566.56 609.64,567.09C609.01,567.62 605.58,570.30 602.00,573.06C598.42,575.82 593.52,579.75 591.11,581.79C588.69,583.83 585.32,586.48 583.61,587.68C579.98,590.22 559.11,611.60 554.00,618.01C552.08,620.43 548.79,624.29 546.69,626.59C544.60,628.90 540.41,634.72 537.39,639.54C534.37,644.35 530.54,650.26 528.88,652.67C525.20,658.02 512.00,684.25 512.00,686.21C512.00,686.98 511.34,688.49 510.53,689.56C509.72,690.63 509.05,692.42 509.03,693.55C509.01,694.68 508.60,696.03 508.11,696.55C507.12,697.60 502.66,710.67 501.55,715.75C501.16,717.54 500.50,719.00 500.09,719.00C499.67,719.00 499.29,719.56 499.24,720.25C499.19,720.94 498.66,723.98 498.07,727.00C492.75,754.25 491.00,771.12 491.54,790.17C492.03,807.83 493.46,823.71 494.97,828.50C495.50,830.15 496.14,833.30 496.40,835.50C497.11,841.55 500.39,854.28 504.26,866.00C508.36,878.40 507.34,876.10 526.25,915.73C526.84,916.96 528.05,918.76 528.95,919.73C529.85,920.70 532.11,923.75 533.97,926.50C538.54,933.25 549.03,946.31 550.67,947.30C551.40,947.74 552.00,948.82 552.00,949.70C552.00,951.44 585.68,985.00 587.44,985.00C588.02,985.01 589.85,986.26 591.50,987.79C593.15,989.31 596.08,991.65 598.00,992.98C599.92,994.31 601.73,995.67 602.00,995.99C602.62,996.71 618.38,1006.87 622.50,1009.20C628.16,1012.39 641.50,1018.85 648.00,1021.53C651.58,1023.00 654.95,1024.55 655.50,1024.97C656.05,1025.39 658.30,1026.28 660.50,1026.94C662.70,1027.60 665.40,1028.53 666.50,1029.00C672.24,1031.48 687.07,1035.97 691.00,1036.42C693.48,1036.71 698.01,1037.60 701.08,1038.41C704.14,1039.22 708.87,1040.15 711.58,1040.47C714.28,1040.78 717.39,1041.32 718.47,1041.66C723.98,1043.38 762.18,1043.96 780.00,1042.59Z";
let SETTINGS_ICON_PATH2D = null;

const COLORS = {
  I: "rgb(85,214,255)",
  J: "rgb(86,105,255)",
  L: "rgb(255,167,71)",
  O: "rgb(255,231,87)",
  S: "rgb(122,235,132)",
  T: "rgb(187,128,255)",
  Z: "rgb(255,118,118)",
  X: "rgb(50,52,62)",
  Text: "rgb(235,235,235)",
  Overlay: "rgba(0,0,0,0.55)",
};

const THEME_PRESETS = {
  glass: {
    panel_bg: "rgba(20,24,32,0.55)",
    panel_border: "rgba(255,255,255,0.18)",
    panel_shadow: "rgba(0,0,0,0.35)",
    button: "rgba(255,255,255,0.9)",
    accent: "rgba(120,200,255,0.9)",
    text: "#F2F5F8",
    button_bg: "rgba(255,255,255,0.08)",
    button_hover: "rgba(255,255,255,0.18)",
  },
  flat: {
    panel_bg: "rgba(30,30,34,0.92)",
    panel_border: "rgba(255,255,255,0.12)",
    panel_shadow: "rgba(0,0,0,0.25)",
    button: "#F2F2F2",
    accent: "#5BD7FF",
    text: "#F2F2F2",
    button_bg: "rgba(255,255,255,0.06)",
    button_hover: "rgba(255,255,255,0.16)",
  },
  neon: {
    panel_bg: "rgba(12,12,18,0.82)",
    panel_border: "rgba(120,255,200,0.35)",
    panel_shadow: "rgba(0,0,0,0.35)",
    button: "#E9FFF4",
    accent: "#7CFFB0",
    text: "#E9FFF4",
    button_bg: "rgba(124,255,176,0.08)",
    button_hover: "rgba(124,255,176,0.2)",
  },
  minimal: {
    panel_bg: "rgba(24,26,28,0.9)",
    panel_border: "rgba(255,255,255,0.08)",
    panel_shadow: "rgba(0,0,0,0.2)",
    button: "#F4F4F4",
    accent: "#A6B0FF",
    text: "#F4F4F4",
    button_bg: "rgba(255,255,255,0.05)",
    button_hover: "rgba(255,255,255,0.12)",
  },
};

const DEFAULT_CONFIG = {
  theme: "glass",
  theme_colors: JSON.parse(JSON.stringify(THEME_PRESETS)),
  theme_settings: {
    glass_radius: 6,
    neon_glow: 8,
    neon_radius: 6,
  },
  bindings: {
    move_left: ["arrowleft", "numpad4"],
    move_right: ["arrowright", "numpad6"],
    rotate_cw: ["arrowup", "numpad5", "x", "numpad1", "numpad9"],
    rotate_ccw: ["control", "numpad3", "z", "numpad7"],
    soft_drop: ["arrowdown", "numpad2"],
    hard_drop: [" ", "numpad8"],
    hold: ["shift", "numpad0", "c"],
    reset: ["r"],
    pause: ["escape", "f1"],
  },
  colors: {
    color_i: "#55D6FF",
    color_j: "#5669FF",
    color_l: "#FFA74F",
    color_o: "#FFE757",
    color_s: "#7AEB84",
    color_t: "#BB80FF",
    color_z: "#FF7676",
    background_color: "#32343E",
  },
  ghost_piece: true,
  next_piece: true,
  hold_queue: true,
  show_controls: true,
  lock_down_mode: "extended",
  start_level: 1,
  level_progression: "fixed",
  queue_size: 6,
  grid_enabled: true,
  grid_color: "rgba(255,255,255,0.2)",
};

const ALLOWED_KEYS = new Set([
  "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p",
  "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
  "arrowleft", "arrowright", "arrowup", "arrowdown",
  " ", "enter", "tab", "escape", "backspace", "delete", "insert",
  "home", "end", "pageup", "pagedown",
  "control", "shift",
  "numpad0", "numpad1", "numpad2", "numpad3", "numpad4",
  "numpad5", "numpad6", "numpad7", "numpad8", "numpad9",
  "numpadadd", "numpadsubtract", "numpadmultiply", "numpaddivide", "numpaddecimal", "numpadenter",
  "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12",
  "-", "=", "[", "]", "\\", ";", "'", ",", ".", "/", "`",
]);

const SHAPES = {
  I: [
    [[0, 1], [1, 1], [2, 1], [3, 1]],
    [[2, 0], [2, 1], [2, 2], [2, 3]],
    [[0, 2], [1, 2], [2, 2], [3, 2]],
    [[1, 0], [1, 1], [1, 2], [1, 3]],
  ],
  J: [
    [[0, 0], [0, 1], [1, 1], [2, 1]],
    [[1, 0], [2, 0], [1, 1], [1, 2]],
    [[0, 1], [1, 1], [2, 1], [2, 2]],
    [[1, 0], [1, 1], [0, 2], [1, 2]],
  ],
  L: [
    [[2, 0], [0, 1], [1, 1], [2, 1]],
    [[1, 0], [1, 1], [1, 2], [2, 2]],
    [[0, 1], [1, 1], [2, 1], [0, 2]],
    [[0, 0], [1, 0], [1, 1], [1, 2]],
  ],
  O: [
    [[1, 0], [2, 0], [1, 1], [2, 1]],
    [[1, 0], [2, 0], [1, 1], [2, 1]],
    [[1, 0], [2, 0], [1, 1], [2, 1]],
    [[1, 0], [2, 0], [1, 1], [2, 1]],
  ],
  S: [
    [[1, 0], [2, 0], [0, 1], [1, 1]],
    [[1, 0], [1, 1], [2, 1], [2, 2]],
    [[1, 1], [2, 1], [0, 2], [1, 2]],
    [[0, 0], [0, 1], [1, 1], [1, 2]],
  ],
  T: [
    [[1, 0], [0, 1], [1, 1], [2, 1]],
    [[1, 0], [1, 1], [2, 1], [1, 2]],
    [[0, 1], [1, 1], [2, 1], [1, 2]],
    [[1, 0], [0, 1], [1, 1], [1, 2]],
  ],
  Z: [
    [[0, 0], [1, 0], [1, 1], [2, 1]],
    [[2, 0], [1, 1], [2, 1], [1, 2]],
    [[0, 1], [1, 1], [1, 2], [2, 2]],
    [[1, 0], [0, 1], [1, 1], [0, 2]],
  ],
};

function createRng(seed, stateOverride = null) {
  let state = stateOverride != null ? stateOverride : seed % 2147483647;
  if (state <= 0) state += 2147483646;
  return {
    next: () => {
      state = (state * 16807) % 2147483647;
      return (state - 1) / 2147483646;
    },
    getState: () => state,
    setState: (value) => {
      state = value;
    },
  };
}

function shuffledBag(rng) {
  const bag = Object.keys(SHAPES);
  for (let i = bag.length - 1; i > 0; i -= 1) {
    const j = Math.floor(rng.next() * (i + 1));
    const tmp = bag[i];
    bag[i] = bag[j];
    bag[j] = tmp;
  }
  return bag;
}

function newPiece(shape) {
  return { shape, rot: 0, x: 3, y: SPAWN_Y };
}

function pieceBottomY(piece) {
  return Math.max(...pieceCells(piece).map(([, y]) => y));
}

function emptyBoard() {
  const board = [];
  for (let y = 0; y < GRID_H_TOTAL; y += 1) {
    const row = new Array(GRID_W).fill(0);
    board.push(row);
  }
  return board;
}

function pieceCells(piece) {
  const shape = SHAPES[piece.shape][piece.rot % 4];
  return shape.map(([dx, dy]) => [piece.x + dx, piece.y + dy]);
}

function collides(board, piece) {
  for (const [x, y] of pieceCells(piece)) {
    if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H_TOTAL) return true;
    if (board[y][x]) return true;
  }
  return false;
}

function lockPiece(board, piece) {
  for (const [x, y] of pieceCells(piece)) {
    if (y >= 0 && y < GRID_H_TOTAL && x >= 0 && x < GRID_W) {
      board[y][x] = piece.shape;
    }
  }
}

function clearLines(board) {
  const remaining = board.filter((row) => row.some((cell) => cell === 0));
  const cleared = GRID_H_TOTAL - remaining.length;
  while (remaining.length < GRID_H_TOTAL) {
    remaining.unshift(new Array(GRID_W).fill(0));
  }
  return { board: remaining, cleared };
}

function createState(seed, startLevel = 1, levelProgression = "fixed") {
  const rng = createRng(seed);
  const bag = shuffledBag(rng);
  const piece = newPiece(bag.shift());
  const nextShape = bag.shift();
  const start = clampLevel(startLevel);
  const level = start;
  const progression = levelProgression === "variable" ? "variable" : "fixed";
  const baseDropMs = Math.max(1, Math.round(fallSpeedSeconds(level) * 1000));
  return {
    seed,
    rng,
    bag,
    bagCount: 0,
    piece,
    nextShape,
    holdShape: null,
    holdUsed: false,
    board: emptyBoard(),
    score: 0,
    timeMs: 0,
    lines: 0,
    tetrises: 0,
    tspins: 0,
    comboStreak: 0,
    comboTotal: 0,
    startLevel: start,
    level,
    levelProgression: progression,
    goalLinesTotal: 0,
    goalRemaining: progression === "fixed" ? 10 : 5 * start,
    b2bActive: false,
    running: false,
    started: false,
    gameOver: false,
    baseDropMs,
    dropMs: baseDropMs,
    elapsed: 0,
    lockDelayMs: 500,
    lockElapsed: 0,
    locking: false,
    softDrop: false,
    lastAction: null,
    lastRotateKick: null,
    tspin: "none",
    lockMoves: 0,
    lowestY: pieceBottomY(piece),
    moveDir: null,
    moveHeldLeft: false,
    moveHeldRight: false,
    moveDasElapsed: 0,
    moveArrElapsed: 0,
    timer: null,
  };
}

function hydrateState(serialized, fallbackSeed, startLevel = 1) {
  if (!serialized || typeof serialized !== "string") return null;
  let data = null;
  try {
    data = JSON.parse(serialized);
  } catch {
    return null;
  }
  if (!data || typeof data !== "object") return null;
  const seed = Number.isInteger(data.seed) ? data.seed : fallbackSeed ?? 0;
  const progression = data.level_progression === "variable" ? "variable" : "fixed";
  const base = createState(seed, data.start_level || startLevel, progression);
  if (Array.isArray(data.board)) {
    base.board = data.board;
  }
  if (Array.isArray(data.bag)) {
    base.bag = data.bag.slice();
  }
  if (Number.isInteger(data.bag_count)) base.bagCount = data.bag_count;
  if (data.piece && typeof data.piece === "object") {
    base.piece = {
      shape: data.piece.shape,
      rot: data.piece.rot,
      x: data.piece.x,
      y: data.piece.y,
    };
  }
  if (data.next_piece_shape) base.nextShape = data.next_piece_shape;
  if (data.hold_piece_shape !== undefined) base.holdShape = data.hold_piece_shape;
  if (typeof data.hold_used === "boolean") base.holdUsed = data.hold_used;
  if (Number.isInteger(data.score)) base.score = data.score;
  if (Number.isFinite(data.time_ms)) base.timeMs = data.time_ms;
  if (Number.isInteger(data.lines_cleared_total)) base.lines = data.lines_cleared_total;
  if (Number.isFinite(data.goal_lines_total)) base.goalLinesTotal = data.goal_lines_total;
  if (Number.isInteger(data.level)) base.level = data.level;
  if (Number.isInteger(data.start_level)) base.startLevel = data.start_level;
  base.levelProgression = progression;
  if (typeof data.b2b_active === "boolean") base.b2bActive = data.b2b_active;
  if (typeof data.game_over === "boolean") base.gameOver = data.game_over;
  if (data.tspin) base.tspin = data.tspin;
  if (Number.isInteger(data.tetrises)) base.tetrises = data.tetrises;
  if (Number.isInteger(data.tspins)) base.tspins = data.tspins;
  if (Number.isInteger(data.combo_total)) base.comboTotal = data.combo_total;
  if (Number.isInteger(data.combo_streak)) base.comboStreak = data.combo_streak;
  updateLevel(base);
  base.running = false;
  base.started = false;
  return base;
}

function fallSpeedSeconds(level) {
  const lvl = Math.max(1, Math.min(15, Math.floor(level || 1)));
  const base = 0.8 - (lvl - 1) * 0.007;
  return Math.pow(base, lvl - 1);
}

function clampLevel(value) {
  const parsed = Number.parseInt(`${value}`, 10);
  if (!Number.isFinite(parsed)) return 1;
  return Math.max(1, Math.min(15, parsed));
}

function updateLevel(state) {
  let target = state.startLevel;
  const progression = state.levelProgression === "variable" ? "variable" : "fixed";
  if (progression === "fixed") {
    state.goalLinesTotal = state.lines;
    target = clampLevel(state.startLevel + Math.floor(state.lines / 10));
  } else {
    let remaining = state.goalLinesTotal;
    let lvl = state.startLevel;
    while (lvl < 15) {
      const goal = 5 * lvl;
      if (remaining < goal) break;
      remaining -= goal;
      lvl += 1;
    }
    target = clampLevel(lvl);
  }
  if (state.level !== target) {
    state.level = target;
  }
  if (progression === "fixed") {
    if (state.level >= 15) {
      state.goalRemaining = 0;
    } else {
      const linesIntoLevel = state.lines - (state.level - state.startLevel) * 10;
      state.goalRemaining = Math.max(0, 10 - linesIntoLevel);
    }
  } else {
    let remaining = state.goalLinesTotal;
    let lvl = state.startLevel;
    while (lvl < 15 && remaining >= 5 * lvl) {
      remaining -= 5 * lvl;
      lvl += 1;
    }
    state.goalRemaining = lvl >= 15 ? 0 : Math.max(0, 5 * lvl - remaining);
  }
  state.baseDropMs = Math.max(1, Math.round(fallSpeedSeconds(state.level) * 1000));
  state.dropMs = state.softDrop
    ? Math.max(1, Math.floor(state.baseDropMs / 20))
    : state.baseDropMs;
}

function awardedGoalLines(lines, tspinType, b2bActive) {
  let base = 0;
  let qualifies = false;
  if (tspinType === "tspin") {
    if (lines === 0) base = 4;
    else if (lines === 1) {
      base = 8;
      qualifies = true;
    } else if (lines === 2) {
      base = 12;
      qualifies = true;
    } else if (lines === 3) {
      base = 16;
      qualifies = true;
    }
  } else if (tspinType === "mini") {
    if (lines === 0) base = 1;
    else {
      base = 2;
      qualifies = true;
    }
  } else {
    if (lines === 1) base = 1;
    else if (lines === 2) base = 3;
    else if (lines === 3) base = 5;
    else if (lines === 4) {
      base = 8;
      qualifies = true;
    }
  }
  if (qualifies && b2bActive && base > 0) {
    base += base * 0.5;
  }
  return base;
}

function scoreForClear(level, lines, tspinType, b2bActive) {
  let base = 0;
  let qualifies = false;
  if (tspinType === "tspin") {
    if (lines === 0) {
      base = 400 * level;
    } else if (lines === 1) {
      base = 800 * level;
      qualifies = true;
    } else if (lines === 2) {
      base = 1200 * level;
      qualifies = true;
    } else if (lines === 3) {
      base = 1600 * level;
      qualifies = true;
    }
  } else if (tspinType === "mini") {
    if (lines === 0) {
      base = 100 * level;
    } else {
      base = 200 * level;
      qualifies = true;
    }
  } else {
    if (lines === 1) {
      base = 100 * level;
    } else if (lines === 2) {
      base = 300 * level;
    } else if (lines === 3) {
      base = 500 * level;
    } else if (lines === 4) {
      base = 800 * level;
      qualifies = true;
    }
  }

  let bonus = 0;
  let nextB2b = b2bActive;
  if (qualifies) {
    if (b2bActive) {
      bonus = Math.floor(base * 0.5);
    }
    nextB2b = true;
  } else if (lines >= 1 && lines <= 3) {
    nextB2b = false;
  }

  return { points: base + bonus, b2bActive: nextB2b };
}

function ensureBag(state) {
  if (state.bag.length === 0) {
    state.bag = shuffledBag(state.rng);
    state.bagCount += 1;
  }
}

function getUpcomingShapes(state, count) {
  if (count <= 0) return [];
  const upcoming = [state.nextShape, ...state.bag];
  if (upcoming.length >= count) return upcoming.slice(0, count);
  const rngClone = createRng(state.seed, state.rng.getState());
  while (upcoming.length < count) {
    const bag = shuffledBag(rngClone);
    for (const shape of bag) {
      upcoming.push(shape);
      if (upcoming.length >= count) break;
    }
  }
  return upcoming.slice(0, count);
}

function spawnNext(state) {
  state.piece = newPiece(state.nextShape);
  ensureBag(state);
  state.nextShape = state.bag.shift();
  state.holdUsed = false;
  state.lockMoves = 0;
  state.lowestY = pieceBottomY(state.piece);
  state.locking = false;
  state.lockElapsed = 0;
  updateLevel(state);
  if (collides(state.board, state.piece)) {
    state.gameOver = true;
    state.running = false;
  }
}

function updateLowestY(state) {
  const bottom = pieceBottomY(state.piece);
  if (state.lowestY == null || bottom > state.lowestY) {
    state.lowestY = bottom;
    state.lockMoves = 0;
    if (state.locking) {
      state.lockElapsed = 0;
    }
    return true;
  }
  return false;
}

function stepDown(state) {
  const moved = { ...state.piece, y: state.piece.y + 1 };
  if (!collides(state.board, moved)) {
    state.piece = moved;
    state.locking = false;
    state.lockElapsed = 0;
    updateLowestY(state);
    state.lastAction = "move";
    if (state.softDrop) {
      state.score += 1;
    }
    return;
  }
  if (!state.locking) {
    state.locking = true;
    state.lockElapsed = 0;
  }
}

function cornerOccupied(board, x, y) {
  if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H_TOTAL) return true;
  return board[y][x] !== 0;
}

function tspinType(state) {
  const piece = state.piece;
  if (piece.shape !== "T" || state.lastAction !== "rotate") return "none";
  const cx = piece.x + 1;
  const cy = piece.y + 1;
  const corners = {
    A: [cx - 1, cy - 1],
    B: [cx + 1, cy - 1],
    C: [cx - 1, cy + 1],
    D: [cx + 1, cy + 1],
  };
  const rot = piece.rot % 4;
  let front = ["A", "B"];
  let back = ["C", "D"];
  if (rot === 1) {
    front = ["B", "D"];
    back = ["A", "C"];
  } else if (rot === 2) {
    front = ["C", "D"];
    back = ["A", "B"];
  } else if (rot === 3) {
    front = ["A", "C"];
    back = ["B", "D"];
  }
  const frontHits = front.reduce((acc, k) => acc + (cornerOccupied(state.board, ...corners[k]) ? 1 : 0), 0);
  const backHits = back.reduce((acc, k) => acc + (cornerOccupied(state.board, ...corners[k]) ? 1 : 0), 0);
  if (state.lastRotateKick === 4) return "tspin";
  if (frontHits + backHits < 3) return "none";
  if (frontHits === 2 && backHits === 2) return "tspin";
  if (frontHits === 2 && backHits >= 1) return "tspin";
  if (backHits === 2 && frontHits >= 1) return "mini";
  return "none";
}

function settlePiece(state) {
  lockPiece(state.board, state.piece);
  state.tspin = tspinType(state);
  const levelBefore = state.level;
  const prevB2b = state.b2bActive;
  const result = clearLines(state.board);
  state.board = result.board;
  if (result.cleared > 0) {
    state.lines += result.cleared;
    state.comboStreak = (state.comboStreak || 0) + 1;
    if (state.comboStreak === 2) {
      state.comboTotal = (state.comboTotal || 0) + 1;
    }
    if (result.cleared === 4) {
      state.tetrises = (state.tetrises || 0) + 1;
    }
    if (state.tspin !== "none") {
      state.tspins = (state.tspins || 0) + 1;
    }
  } else {
    state.comboStreak = 0;
  }
  const scored = scoreForClear(levelBefore, result.cleared, state.tspin, state.b2bActive);
  state.score += scored.points;
  state.b2bActive = scored.b2bActive;
  if (state.levelProgression === "variable") {
    state.goalLinesTotal += awardedGoalLines(result.cleared, state.tspin, prevB2b);
  }
  updateLevel(state);
  state.locking = false;
  state.lockElapsed = 0;
  spawnNext(state);
}

function serializeState(state) {
  return JSON.stringify({
    version: 1,
    board: state.board,
    bag: state.bag.slice(),
    bag_count: state.bagCount,
    seed: state.seed,
    start_level: state.startLevel,
    level: state.level,
    level_progression: state.levelProgression,
    b2b_active: state.b2bActive,
    goal_lines_total: state.goalLinesTotal,
    piece: { ...state.piece },
    next_piece_shape: state.nextShape,
    hold_piece_shape: state.holdShape,
    hold_used: state.holdUsed,
    score: state.score,
    time_ms: state.timeMs,
    lines_cleared_total: state.lines,
    tetrises: state.tetrises,
    tspins: state.tspins,
    combo_streak: state.comboStreak,
    combo_total: state.comboTotal,
    game_over: state.gameOver,
    tspin: state.tspin,
    options: state.options || {},
  });
}

function updateBackendState(node) {
  if (!node?.widgets) return;
  const stateWidget = node.widgets.find((w) => w.name === "state");
  const actionWidget = node.widgets.find((w) => w.name === "action");
  const stateIndex = node.widgets.indexOf(stateWidget);
  const actionIndex = node.widgets.indexOf(actionWidget);
  if (!node.widgets_values) {
    node.widgets_values = [];
  }
  if (stateWidget) {
    node.__tetrisLive.state.options = getOptionsForState(node);
    const stateValue = serializeState(node.__tetrisLive.state);
    stateWidget.value = stateValue;
    if (stateIndex >= 0) node.widgets_values[stateIndex] = stateValue;
  }
  if (actionWidget) {
    actionWidget.value = "sync";
    if (actionIndex >= 0) node.widgets_values[actionIndex] = "sync";
  }
  if (node.widgets?.length) {
    node.widgets_values = node.widgets.map((w) => w.value);
  }
}

function move(state, dx, dy, opts = {}) {
  const moved = { ...state.piece, x: state.piece.x + dx, y: state.piece.y + dy };
  if (!collides(state.board, moved)) {
    state.piece = moved;
    if (!opts.skipLastAction) {
      state.lastAction = "move";
    }
    updateLowestY(state);
    return true;
  }
  return false;
}

function rotate(state, delta) {
  const rotated = rotateWithKick(state.board, state.piece, delta);
  if (rotated) {
    state.piece = rotated.piece;
    state.lastAction = "rotate";
    state.lastRotateKick = rotated.kick;
    updateLowestY(state);
    return true;
  }
  return false;
}

function kickTable(shape, fromRot, toRot) {
  if (shape === "O") return [[0, 0]];
  if (shape === "I") {
    const table = {
      "0>1": [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]],
      "1>0": [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]],
      "1>2": [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]],
      "2>1": [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]],
      "2>3": [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]],
      "3>2": [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]],
      "3>0": [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]],
      "0>3": [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]],
    };
    return table[`${fromRot}>${toRot}`] || [[0, 0]];
  }
  const table = {
    "0>1": [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
    "1>0": [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],
    "1>2": [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],
    "2>1": [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
    "2>3": [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
    "3>2": [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
    "3>0": [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
    "0>3": [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
  };
  return table[`${fromRot}>${toRot}`] || [[0, 0]];
}

function rotateWithKick(board, piece, delta) {
  const fromRot = piece.rot % 4;
  const toRot = (fromRot + delta + 4) % 4;
  const kicks = kickTable(piece.shape, fromRot, toRot);
  for (let i = 0; i < kicks.length; i += 1) {
    const [dx, dy] = kicks[i];
    const candidate = { ...piece, rot: toRot, x: piece.x + dx, y: piece.y + dy };
    if (!collides(board, candidate)) return { piece: candidate, kick: i };
  }
  return null;
}

function hardDrop(state) {
  let moved = 0;
  while (move(state, 0, 1, { skipLastAction: true })) {
    moved += 1;
    // keep dropping
  }
  if (moved > 0) {
    state.score += moved * 2;
  }
  settlePiece(state);
}

function holdPiece(state) {
  if (state.holdUsed || state.gameOver) return false;
  const currentShape = state.piece.shape;
  if (state.holdShape) {
    const swapShape = state.holdShape;
    state.holdShape = currentShape;
    state.piece = newPiece(swapShape);
  } else {
    state.holdShape = currentShape;
    ensureBag(state);
    state.piece = newPiece(state.nextShape);
    state.nextShape = state.bag.shift();
  }
  state.holdUsed = true;
  state.lockMoves = 0;
  state.lowestY = pieceBottomY(state.piece);
  state.locking = false;
  state.lockElapsed = 0;
  state.lastAction = "hold";
  state.lastRotateKick = null;
  state.tspin = "none";
  updateLevel(state);
  if (collides(state.board, state.piece)) {
    state.gameOver = true;
    state.running = false;
  }
  return true;
}

function getLayout(node) {
  const pauseBottom = null;
  const minTop = HEADER_H + PADDING + TOOLBAR_H + CONTROL_MIN;
  const topY = Math.max(minTop, HEADER_H + PADDING + TOOLBAR_H + CONTROL_GAP);
  const bottomY = Math.max(topY, node.size[1] - PADDING);
  const innerH = Math.max(0, bottomY - topY);
  const innerW = Math.max(0, node.size[0] - PADDING * 2);

  const showHold = getHoldEnabled(node);
  const showNext = getNextPieceEnabled(node);
  const sideSlots = 2;

  let sideW = 120;
  let blockSize = BLOCK;
  const effectiveRows = GRID_H_VISIBLE + EXTRA_VISIBLE_ROWS;
  for (let i = 0; i < 2; i += 1) {
    const boardW = Math.max(0, innerW - sideW * sideSlots - PADDING * sideSlots);
    blockSize = Math.floor(Math.min(boardW / GRID_W, innerH / effectiveRows));
    blockSize = Math.max(6, blockSize);
    sideW = Math.max(PREVIEW_GRID * blockSize + PADDING * 2, 120);
  }

  const boardW = blockSize * GRID_W;
  const extraPx = Math.round(blockSize * EXTRA_VISIBLE_ROWS);
  const boardH = blockSize * GRID_H_VISIBLE + extraPx;
  const boardX = Math.max(PADDING, Math.round((node.size[0] - boardW) / 2));
  const boardY = Math.round(topY);
  const sideX = Math.round(boardX + boardW + PADDING);
  const sideY = boardY;

  node.__tetrisLastLayout = {
    boardY,
    pauseBottom,
  };

  return {
    boardX,
    boardY,
    boardW,
    boardH,
    sideX,
    sideY,
    sideW,
    blockSize,
    extraPx,
    showHold,
    showNext,
  };
}

function getLockMode(node) {
  const defaultMode = "extended";
  const raw = `${getConfig(node).lock_down_mode || ""}`.trim().toLowerCase();
  if (["extended", "infinite", "classic"].includes(raw)) return raw;
  return defaultMode;
}

function applyLockModeAfterAction(state, mode) {
  const onSurface = collides(state.board, { ...state.piece, y: state.piece.y + 1 });
  if (!onSurface) {
    state.locking = false;
    state.lockElapsed = 0;
    return;
  }
  state.locking = true;
  if (mode === "classic") {
    return;
  }
  if (mode === "infinite") {
    state.lockElapsed = 0;
    return;
  }
  if (state.lockMoves < 15) {
    state.lockMoves += 1;
    state.lockElapsed = 0;
  } else {
    state.lockElapsed = state.lockDelayMs;
  }
}

function setMoveDirection(state, dir) {
  if (state.moveDir === dir) return;
  state.moveDir = dir;
  state.moveDasElapsed = 0;
  state.moveArrElapsed = 0;
}

function clearMoveDirection(state) {
  state.moveDir = null;
  state.moveDasElapsed = 0;
  state.moveArrElapsed = 0;
}

function updateAutoRepeat(state, node, deltaMs) {
  if (!state.moveDir) return;
  state.moveDasElapsed += deltaMs;
  if (state.moveDasElapsed < DAS_MS) return;
  state.moveArrElapsed += deltaMs;
  while (state.moveArrElapsed >= ARR_MS) {
    state.moveArrElapsed -= ARR_MS;
    const dx = state.moveDir === "left" ? -1 : 1;
    if (move(state, dx, 0)) {
      applyLockModeAfterAction(state, getLockMode(node));
    }
  }
}

function drawBlockSized(ctx, x, y, size, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, size - 1, size - 1);
}

function ghostLandingY(state) {
  const ghost = { ...state.piece };
  while (!collides(state.board, { ...ghost, y: ghost.y + 1 })) {
    ghost.y += 1;
  }
  return ghost.y;
}

function drawGhostPiece(ctx, state, boardX, boardY, blockSize, color, outlineColor) {
  const ghostY = ghostLandingY(state);
  const ghost = { ...state.piece, y: ghostY };
  const cells = pieceCells(ghost);
  ctx.globalAlpha = 0.33;
  for (const [x, y] of cells) {
    if (y >= HIDDEN_ROWS - 1 && y < GRID_H_TOTAL) {
      ctx.fillStyle = color;
      ctx.fillRect(
        boardX + x * blockSize,
        boardY + (y - HIDDEN_ROWS) * blockSize,
        blockSize - 1,
        blockSize - 1
      );
    }
  }
  ctx.globalAlpha = 0.67;
  ctx.strokeStyle = outlineColor;
  ctx.lineWidth = 1;
  for (const [x, y] of cells) {
    if (y >= HIDDEN_ROWS - 1 && y < GRID_H_TOTAL) {
      ctx.strokeRect(
        boardX + x * blockSize + 0.5,
        boardY + (y - HIDDEN_ROWS) * blockSize + 0.5,
        blockSize - 2,
        blockSize - 2
      );
    }
  }
  ctx.globalAlpha = 1;
}

function getInputDataByName(node, name) {
  const idx = node?.inputs?.findIndex((inp) => inp?.name === name);
  if (idx == null || idx < 0) return null;
  if (typeof node.getInputData !== "function") return null;
  return node.getInputData(idx);
}

function coerceImageSource(value) {
  if (!value) return null;
  if (
    value instanceof HTMLImageElement ||
    value instanceof HTMLCanvasElement ||
    value instanceof ImageBitmap ||
    value instanceof OffscreenCanvas ||
    value instanceof HTMLVideoElement
  ) {
    return value;
  }
  if (value.image) {
    const img = value.image;
    if (
      img instanceof HTMLImageElement ||
      img instanceof HTMLCanvasElement ||
      img instanceof ImageBitmap ||
      img instanceof OffscreenCanvas
    ) {
      return img;
    }
  }
  return null;
}

function toByteArray(data) {
  if (!data) return null;
  if (data instanceof Uint8ClampedArray) return data;
  let array = data;
  if (data instanceof Uint8Array) {
    return new Uint8ClampedArray(data.buffer, data.byteOffset, data.byteLength);
  }
  if (data instanceof Float32Array || data instanceof Float64Array) {
    array = Array.from(data);
  }
  if (Array.isArray(array)) {
    let max = 0;
    for (let i = 0; i < array.length; i += 1) {
      const v = array[i];
      if (Number.isFinite(v) && v > max) max = v;
    }
    const scale = max <= 1 ? 255 : 1;
    const out = new Uint8ClampedArray(array.length);
    for (let i = 0; i < array.length; i += 1) {
      const v = array[i];
      const value = Number.isFinite(v) ? v * scale : 0;
      out[i] = Math.max(0, Math.min(255, Math.round(value)));
    }
    return out;
  }
  return null;
}

function buildCanvasFromData(value) {
  if (!value || !value.data || !value.width || !value.height) return null;
  const width = Math.max(1, Math.floor(value.width));
  const height = Math.max(1, Math.floor(value.height));
  const bytes = toByteArray(value.data);
  if (!bytes) return null;
  const expected3 = width * height * 3;
  const expected4 = width * height * 4;
  let pixels = bytes;
  if (bytes.length === expected3) {
    pixels = new Uint8ClampedArray(expected4);
    for (let i = 0; i < width * height; i += 1) {
      const src = i * 3;
      const dst = i * 4;
      pixels[dst] = bytes[src];
      pixels[dst + 1] = bytes[src + 1];
      pixels[dst + 2] = bytes[src + 2];
      pixels[dst + 3] = 255;
    }
  } else if (bytes.length !== expected4) {
    return null;
  }
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  if (!ctx) return null;
  const imgData = new ImageData(pixels, width, height);
  ctx.putImageData(imgData, 0, 0);
  return canvas;
}

function buildCanvasFromTensor(value) {
  if (!value || !value.data || !value.shape) return null;
  const shape = Array.isArray(value.shape) ? value.shape : null;
  if (!shape || shape.length < 2) return null;
  let height = null;
  let width = null;
  let channels = null;
  if (shape.length >= 4) {
    channels = shape[shape.length - 1];
    width = shape[shape.length - 2];
    height = shape[shape.length - 3];
  } else if (shape.length === 3) {
    channels = shape[2];
    width = shape[1];
    height = shape[0];
  }
  if (!width || !height || !channels) return null;
  if (channels !== 3 && channels !== 4) return null;
  const frameSize = width * height * channels;
  let data = value.data;
  if (Array.isArray(data)) {
    data = data.slice(0, frameSize);
  } else if (data && typeof data.subarray === "function" && data.length > frameSize) {
    data = data.subarray(0, frameSize);
  }
  return buildCanvasFromData({ data, width, height });
}

function getImageInfo(value) {
  if (!value) return null;
  if (Array.isArray(value)) return value[0] || null;
  if (Array.isArray(value.tetrinode_background)) return value.tetrinode_background[0] || null;
  if (Array.isArray(value.ui?.tetrinode_background)) return value.ui.tetrinode_background[0] || null;
  if (Array.isArray(value.images)) return value.images[0] || null;
  if (Array.isArray(value.image)) return value.image[0] || null;
  if (Array.isArray(value.result)) return value.result[0] || null;
  return value;
}

function imageInfoUrl(info) {
  if (!info) return null;
  if (typeof info === "string") return info;
  if (info.url) return info.url;
  const filename = info.filename || info.name;
  if (!filename) return null;
  const type = info.type || "temp";
  const subfolder = info.subfolder || "";
  return `./view?filename=${encodeURIComponent(filename)}&type=${encodeURIComponent(type)}&subfolder=${encodeURIComponent(subfolder)}`;
}

function getImageFromInfo(node, info) {
  const url = imageInfoUrl(info);
  if (!url) return null;
  if (IMAGE_CACHE.has(url)) {
    return IMAGE_CACHE.get(url);
  }
  const img = new Image();
  img.src = url;
  img.addEventListener("load", () => {
    node?.setDirtyCanvas(true, true);
  });
  IMAGE_CACHE.set(url, img);
  return img;
}

function getLinkedImageInfo(node, name) {
  const resolved = getInputLink(node, name);
  if (!resolved) return null;
  const { origin, link } = resolved;
  if (!origin) return null;
  const slot = link?.origin_slot ?? 0;
  const outputKey = origin.outputs?.[slot]?.name;
  const outputs = app?.nodeOutputs?.[origin.id] || app?.nodeOutputs?.[`${origin.id}`];
  if (outputs) {
    const candidates = [
      outputKey ? outputs[outputKey] : null,
      outputs.tetrinode_background,
      outputs.ui?.tetrinode_background,
      outputs.images,
      outputs.image,
      outputs.result,
      outputs.output,
    ];
    for (const candidate of candidates) {
      const info = getImageInfo(candidate);
      if (info) return info;
    }
  }
  const linked = origin.outputs?.[slot]?.links || [];
  for (const linkId of linked) {
    const linkInfo = node?.graph?.links?.[linkId];
    if (!linkInfo) continue;
    const targetId = linkInfo.target_id;
    const targetOutputs = app?.nodeOutputs?.[targetId] || app?.nodeOutputs?.[`${targetId}`];
    if (!targetOutputs) continue;
    const previewCandidates = [
      targetOutputs.images,
      targetOutputs.image,
      targetOutputs.result,
      targetOutputs.output,
    ];
    for (const candidate of previewCandidates) {
      const info = getImageInfo(candidate);
      if (info) return info;
    }
  }
  return null;
}

function getLinkedImageSource(node, name) {
  const resolved = getInputLink(node, name);
  if (!resolved) return null;
  const { origin, link } = resolved;
  const slot = link?.origin_slot ?? 0;
  if (!origin) return null;
  if (Array.isArray(origin.imgs)) {
    const candidate = origin.imgs[slot] || origin.imgs[0];
    const source = coerceImageSource(candidate);
    if (source) return source;
  }
  if (Array.isArray(origin.images)) {
    const candidate = origin.images[slot] || origin.images[0];
    const source = coerceImageSource(candidate);
    if (source) return source;
  }
  const direct = coerceImageSource(origin.image || origin.img || origin._img || origin._image);
  if (direct) return direct;
  return null;
}

function getBackgroundSource(node) {
  const raw = getInputDataByName(node, "background_image");
  let value = Array.isArray(raw) ? raw[0] : raw;
  let source = null;
  let info = null;
  if (!value) {
    source = getLinkedImageSource(node, "background_image");
    value = source;
  }
  if (!value && !source) {
    info = getLinkedImageInfo(node, "background_image");
    if (!info) {
      const selfOutputs = app?.nodeOutputs?.[node?.id] || app?.nodeOutputs?.[`${node?.id}`];
      info = getImageInfo(
        selfOutputs?.tetrinode_background
        || selfOutputs?.ui?.tetrinode_background
        || selfOutputs?.images
        || selfOutputs?.image
        || selfOutputs?.result,
      );
    }
    if (!info) return null;
    value = info;
  }
  if (!node.__tetrisBg) node.__tetrisBg = {};
  if (node.__tetrisBg.value === value && node.__tetrisBg.source) {
    return node.__tetrisBg.source;
  }
  if (!source) {
    source = coerceImageSource(value);
  }
  if (!source) {
    info = info || getImageInfo(value) || getLinkedImageInfo(node, "background_image");
    if (info) value = info;
    source = getImageFromInfo(node, info);
  }
  if (!source) {
    source = buildCanvasFromData(value);
  }
  if (!source) {
    source = buildCanvasFromTensor(value);
  }
  node.__tetrisBg = { value, source };
  return source || null;
}

function drawBoardBackground(ctx, source, boardX, boardY, boardW, boardH, fallbackColor) {
  if (!source) {
    ctx.fillStyle = fallbackColor || COLORS.X;
    ctx.fillRect(boardX, boardY, boardW, boardH);
    return;
  }
  const srcW =
    source.videoWidth ||
    source.naturalWidth ||
    source.width ||
    source.displayWidth ||
    0;
  const srcH =
    source.videoHeight ||
    source.naturalHeight ||
    source.height ||
    source.displayHeight ||
    0;
  if (!srcW || !srcH) {
    ctx.fillStyle = fallbackColor || COLORS.X;
    ctx.fillRect(boardX, boardY, boardW, boardH);
    return;
  }
  const scale = Math.max(boardW / srcW, boardH / srcH);
  const cropW = boardW / scale;
  const cropH = boardH / scale;
  const sx = Math.max(0, (srcW - cropW) / 2);
  const sy = Math.max(0, (srcH - cropH) / 2);
  ctx.drawImage(source, sx, sy, cropW, cropH, boardX, boardY, boardW, boardH);
}

function drawBoardGrid(ctx, boardX, boardY, boardW, boardH, blockSize, color, extraPx) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let x = 1; x < GRID_W; x += 1) {
    const lineX = boardX + x * blockSize - 0.5;
    ctx.moveTo(lineX, boardY - 0.5);
    ctx.lineTo(lineX, boardY + boardH + 0.5);
  }
  const yOffset = extraPx || 0;
  for (let y = 0; y < GRID_H_VISIBLE; y += 1) {
    const lineY = boardY + yOffset + y * blockSize - 0.5;
    ctx.moveTo(boardX - 0.5, lineY);
    ctx.lineTo(boardX + boardW + 0.5, lineY);
  }
  ctx.stroke();
}

const THEME_USED_KEYS = new Set([
  "panel_bg",
  "panel_border",
  "panel_shadow",
  "button",
  "text",
  "button_bg",
  "button_hover",
]);

function drawNode(node, ctx) {
  const live = node.__tetrisLive;
  if (!live) return;
  if (!node.__tetrisWidgetsHidden) {
    applyWidgetHiding(node);
  }
  syncStartLevel(live.state, node);
  syncSeed(live.state, node);
  const { state } = live;
  const {
    boardX,
    boardY,
    boardW,
    boardH,
    sideX,
    sideY,
    sideW,
    blockSize,
    extraPx,
    showHold,
    showNext,
  } = getLayout(node);
  const theme = getThemeColors(node);
  const palette = getColorPalette(node);
  const ghostEnabled = isGhostEnabled(node);
  const showPreviews = state.started && state.running;
  const showBoardContents = showPreviews || state.gameOver;
  const showControls = getShowControls(node);
  const gridEnabled = getGridEnabled(node);
  const gridColor = getGridColor(node);

  const bgSource = getBackgroundSource(node);
  drawBoardBackground(ctx, bgSource, boardX, boardY, boardW, boardH, palette.X);
  if (gridEnabled && gridColor) {
    drawBoardGrid(ctx, boardX, boardY, boardW, boardH, blockSize, gridColor, extraPx);
  }
  ctx.strokeStyle = theme.panel_border;
  ctx.lineWidth = 1;
  applyBorderGlow(ctx, node);
  ctx.strokeRect(boardX - 0.5, boardY - 0.5, boardW + 1, boardH + 1);
  clearBorderGlow(ctx);

  const hideBoard = !state.gameOver && state.started && !state.running && !state.showBoardWhilePaused;
  if (!hideBoard) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(boardX, boardY, boardW, boardH);
    ctx.clip();
    if (HIDDEN_ROWS > 0 && showBoardContents) {
      const hiddenRow = HIDDEN_ROWS - 1;
      for (let x = 0; x < GRID_W; x += 1) {
        const cell = state.board[hiddenRow][x];
        if (cell) {
          drawBlockSized(
            ctx,
            boardX + x * blockSize,
            boardY - blockSize + extraPx,
            blockSize,
            palette[cell],
          );
        }
      }
    }
    for (let y = 0; y < GRID_H_VISIBLE; y += 1) {
      const boardYIndex = y + HIDDEN_ROWS;
      for (let x = 0; x < GRID_W; x += 1) {
        const cell = state.board[boardYIndex][x];
        if (cell) {
          drawBlockSized(
            ctx,
            boardX + x * blockSize,
            boardY + y * blockSize + extraPx,
            blockSize,
            palette[cell],
          );
        }
      }
    }

    if (!state.gameOver && ghostEnabled && showPreviews) {
      drawGhostPiece(ctx, state, boardX, boardY + extraPx, blockSize, palette[state.piece.shape], COLORS.Text);
    }

    if (showBoardContents) {
      for (const [x, y] of pieceCells(state.piece)) {
        if (y >= HIDDEN_ROWS - 1 && y < GRID_H_TOTAL) {
          drawBlockSized(
            ctx,
            boardX + x * blockSize,
            boardY + (y - HIDDEN_ROWS) * blockSize + extraPx,
            blockSize,
            palette[state.piece.shape],
          );
        }
      }
    }
    ctx.restore();
  }

  const previewBox = Math.max(4, Math.floor(PREVIEW_GRID * blockSize * PREVIEW_SCALE));
  const rightInset = Math.max(0, Math.floor((sideW - previewBox) / 2));
  const columnShift = Math.max(4, Math.floor(blockSize * 0.2));
  const baseLeftX = showHold ? boardX - PADDING - sideW + rightInset : PADDING;
  const leftX = baseLeftX + columnShift;
  const rightX = sideX + rightInset + columnShift;
  const maxWidthRight = Math.max(0, node.size[0] - rightX - PADDING);
  const leftColumnW = showHold ? previewBox : Math.max(0, boardX - PADDING * 2);
  const maxWidthLeft = Math.max(0, leftColumnW);
  const measureFits = (size, lines, maxWidth) => {
    ctx.font = `bold ${size}px sans-serif`;
    let widest = ctx.measureText(lines[0]).width;
    ctx.font = `${size}px sans-serif`;
    for (let i = 1; i < lines.length; i += 1) {
      widest = Math.max(widest, ctx.measureText(lines[i]).width);
    }
    return widest <= maxWidth;
  };
  let hudFontSize = Math.max(8, Math.floor(blockSize * 0.5));
  while (hudFontSize > 8) {
    if (measureFits(hudFontSize, ["Lines:", "Score:", "Time:", "Level:", "Goal:", "Tetrises:", "T-Spins:", "Combos:", "TPM:", "LPM:"], maxWidthLeft)) break;
    hudFontSize -= 1;
  }
  const scoreFontSize = Math.max(7, hudFontSize - 1);
  const innerPad = Math.max(2, Math.floor(blockSize * 0.2));
  const titleFontSize = Math.max(6, scoreFontSize - 1);
  const titlePad = Math.max(6, Math.floor(titleFontSize * 0.6));
  const titleHeight = titleFontSize + titlePad;
  const nextBoxY = boardY;
  ctx.fillStyle = theme.text;
  const lineGap = Math.floor(scoreFontSize * 0.6);
  const leftHudTopY = showHold ? nextBoxY + previewBox + PADDING * 1.2 : sideY;
  const scoreLabelY = leftHudTopY + scoreFontSize + 1;
  const scoreValueY = scoreLabelY + scoreFontSize + 2;
  const timeLabelY = scoreValueY + lineGap + scoreFontSize;
  const timeValueY = timeLabelY + scoreFontSize + 2;
  const linesLabelY = timeValueY + lineGap + scoreFontSize + 6;
  const linesValueY = linesLabelY;
  const levelLabelY = linesLabelY + lineGap + scoreFontSize;
  const levelValueY = levelLabelY;
  const goalLabelY = levelLabelY + lineGap + scoreFontSize;
  const goalValueY = goalLabelY;
  const statsTopY = goalLabelY + lineGap + scoreFontSize + 6;
  const tetrisLabelY = statsTopY + scoreFontSize;
  const tetrisValueY = tetrisLabelY;
  const tspinLabelY = tetrisLabelY + lineGap + scoreFontSize;
  const tspinValueY = tspinLabelY;
  const comboLabelY = tspinLabelY + lineGap + scoreFontSize;
  const comboValueY = comboLabelY;
  const tpmLabelY = comboLabelY + lineGap + scoreFontSize;
  const tpmValueY = tpmLabelY;
  const lpmLabelY = tpmLabelY + lineGap + scoreFontSize;
  const lpmValueY = lpmLabelY;
  ctx.font = `bold ${scoreFontSize}px sans-serif`;
  ctx.textAlign = "left";
  ctx.fillText("Score:", leftX, scoreLabelY);
  ctx.fillText("Time:", leftX, timeLabelY);
  ctx.fillText("Lines:", leftX, linesLabelY);
  ctx.fillText("Level:", leftX, levelLabelY);
  ctx.fillText("Goal:", leftX, goalLabelY);
  ctx.fillText("Tetrises:", leftX, tetrisLabelY);
  ctx.fillText("T-Spins:", leftX, tspinLabelY);
  ctx.fillText("Combos:", leftX, comboLabelY);
  ctx.fillText("TPM:", leftX, tpmLabelY);
  ctx.fillText("LPM:", leftX, lpmLabelY);
  ctx.font = `${scoreFontSize}px sans-serif`;
  const linesValue = state.levelProgression === "variable" ? state.goalLinesTotal : state.lines;
  const linesText =
    Number.isFinite(linesValue) && Math.abs(linesValue % 1) > 0.001
      ? linesValue.toFixed(1)
      : `${Math.round(linesValue)}`;
  const remaining = state.goalRemaining ?? 0;
  const remainingText =
    Number.isFinite(remaining) && Math.abs(remaining % 1) > 0.001
      ? remaining.toFixed(1)
      : `${Math.round(remaining)}`;
  const minutes = state.timeMs > 0 ? state.timeMs / 60000 : 0;
  const tpm = minutes > 0 ? (state.tetrises || 0) / minutes : 0;
  const lpm = minutes > 0 ? (state.lines || 0) / minutes : 0;
  const tpmText = minutes > 0 ? tpm.toFixed(1) : "0";
  const lpmText = minutes > 0 ? lpm.toFixed(1) : "0";
  const valueX = leftX + previewBox - 2;
  ctx.textAlign = "right";
  ctx.fillText(`${state.score}`, valueX, scoreValueY);
  ctx.fillText(formatTimeMs(state.timeMs), valueX, timeValueY);
  ctx.fillText(linesText, valueX, linesValueY);
  ctx.fillText(`${state.level}`, valueX, levelValueY);
  ctx.fillText(remainingText, valueX, goalValueY);
  ctx.fillText(`${state.tetrises || 0}`, valueX, tetrisValueY);
  ctx.fillText(`${state.tspins || 0}`, valueX, tspinValueY);
  ctx.fillText(`${state.comboTotal || 0}`, valueX, comboValueY);
  ctx.fillText(tpmText, valueX, tpmValueY);
  ctx.fillText(lpmText, valueX, lpmValueY);
  ctx.textAlign = "left";
  const bindings = getControlBindings(node);
  const controlEntries = showControls
    ? [
      { label: "Move Left:", value: formatKeyLabel(bindings.moveLeft?.[0]) },
      { label: "Move Right:", value: formatKeyLabel(bindings.moveRight?.[0]) },
      { label: "Rotate CW:", value: formatKeyLabel(bindings.rotateCw?.[0]) },
      { label: "Rotate CCW:", value: formatKeyLabel(bindings.rotateCcw?.[0]) },
      { label: "Soft Drop:", value: formatKeyLabel(bindings.softDrop?.[0]) },
      { label: "Hard Drop:", value: formatKeyLabel(bindings.hardDrop?.[0]) },
      { label: "Hold:", value: formatKeyLabel(bindings.hold?.[0]) },
      { label: "Reset:", value: formatKeyLabel(bindings.reset?.[0]) },
      { label: "Pause:", value: formatKeyLabel(bindings.pause?.[0]) },
    ]
    : [];
  let fontSize = Math.max(4, Math.floor(blockSize * 0.3));
  if (controlEntries.length) {
    while (fontSize > 8) {
      const labels = controlEntries.map((entry) => entry.label);
      if (measureFits(fontSize, labels, maxWidthRight)) break;
      fontSize -= 1;
    }
  }
  const lineHeight = fontSize + 3;
  const tablePad = Math.max(6, Math.floor(fontSize * 0.6));
  const tableGap = Math.max(6, Math.floor(fontSize * 0.6));
  const tableWForControls = Math.max(0, maxWidthLeft);
  let controlsHeight = 0;
  let leftColWidth = 0;
  let rightColWidth = 0;
  let controlRows = [];
  if (controlEntries.length) {
    ctx.font = `bold ${fontSize}px sans-serif`;
    leftColWidth = Math.max(...controlEntries.map((entry) => ctx.measureText(entry.label).width));
    leftColWidth = Math.min(leftColWidth, Math.max(40, Math.floor(tableWForControls * 0.45)));
    rightColWidth = Math.max(0, tableWForControls - tablePad * 2 - leftColWidth - tableGap);
    ctx.font = `${fontSize}px sans-serif`;
    const wrapValue = (value) => {
      if (!value) return [""];
      const parts = value.split(", ");
      const lines = [];
      let current = "";
      for (const part of parts) {
        const chunk = current ? `${current} / ${part}` : part;
        if (ctx.measureText(chunk).width <= rightColWidth || !current) {
          current = chunk;
        } else {
          lines.push(current);
          current = part;
        }
      }
      if (current) lines.push(current);
      return lines;
    };
    controlRows = controlEntries.map((entry) => ({
      label: entry.label,
      lines: wrapValue(entry.value),
    }));
    controlsHeight = controlRows.reduce((sum, row) => sum + row.lines.length * lineHeight, 0);
  }
  const infoBlockHeight = controlEntries.length
    ? controlsHeight + tablePad * 2 + lineHeight
    : 0;

  const holdNextTitleY = nextBoxY + titleFontSize + 4;
  const titleInset = Math.max(4, Math.floor(titleFontSize * 0.5));
  ctx.font = `bold ${titleFontSize}px sans-serif`;
  const drawPreviewShape = (shape, originX, boxY, cellSize, areaH) => {
    if (!shape || !SHAPES[shape]) return;
    const preview = SHAPES[shape][0];
    let minX = 99;
    let minY = 99;
    let maxX = -99;
    let maxY = -99;
    for (const [px, py] of preview) {
      if (px < minX) minX = px;
      if (py < minY) minY = py;
      if (px > maxX) maxX = px;
      if (py > maxY) maxY = py;
    }
    const shapeW = maxX - minX + 1;
    const shapeH = maxY - minY + 1;
    const areaW = previewBox - innerPad * 2;
    const contentH = Math.max(0, areaH - innerPad * 2);
    const offX = Math.round((areaW - shapeW * cellSize) / 2);
    const offY = Math.round((contentH - shapeH * cellSize) / 2);
    for (const [px, py] of preview) {
      const gx = px - minX;
      const gy = py - minY;
      drawBlockSized(
        ctx,
        originX + innerPad + offX + gx * cellSize,
        boxY + innerPad + offY + gy * cellSize,
        cellSize,
        palette[shape],
      );
    }
  };

  const previewContentH = Math.max(4, previewBox - titleHeight);
  const nextCellSize = Math.max(4, Math.floor((previewContentH - innerPad * 2) / PREVIEW_GRID));
  if (showHold) {
    drawPanelBox(ctx, node, leftX, nextBoxY, previewBox, previewBox, theme.panel_bg, theme.panel_border);
    if (showPreviews) {
      drawPreviewShape(state.holdShape, leftX, nextBoxY + titleHeight, nextCellSize, previewContentH);
    }
    ctx.fillStyle = theme.text;
    ctx.font = `bold ${titleFontSize}px sans-serif`;
    ctx.fillText("Hold", leftX + titleInset, holdNextTitleY);
  }
  if (showNext) {
    drawPanelBox(ctx, node, rightX, nextBoxY, previewBox, previewBox, theme.panel_bg, theme.panel_border);
    if (showPreviews) {
      drawPreviewShape(state.nextShape, rightX, nextBoxY + titleHeight, nextCellSize, previewContentH);
    }
    ctx.fillStyle = theme.text;
    ctx.font = `bold ${titleFontSize}px sans-serif`;
    ctx.fillText("Next", rightX + titleInset, holdNextTitleY);
  }

  const queueCountTarget = showNext ? getQueueSize(node) : 0;
  const showQueue = queueCountTarget > 0;
  const queueBoxY = nextBoxY + previewBox + PADDING * 1.2;
  const queueBoxW = previewBox;
  const queueBoxX = rightX;
  const queueTitleY = queueBoxY + titleFontSize + 4;
  const upcoming = getUpcomingShapes(state, queueCountTarget + 1);
  const queue = upcoming.slice(1, queueCountTarget + 1);
  const queueGapCells = 1;
  const queueContentY = queueBoxY + titleHeight;
  const availableQueueHeight = Math.max(0, boardY + boardH - queueBoxY);
  const queueCount = Math.min(queue.length, queueCountTarget);
  const getShapeBounds = (shape) => {
    const cells = SHAPES[shape]?.[0] || [];
    if (!cells.length) return null;
    let minX = 99;
    let minY = 99;
    let maxX = -99;
    let maxY = -99;
    for (const [px, py] of cells) {
      if (px < minX) minX = px;
      if (py < minY) minY = py;
      if (px > maxX) maxX = px;
      if (py > maxY) maxY = py;
    }
    return {
      minX,
      minY,
      width: maxX - minX + 1,
      height: maxY - minY + 1,
    };
  };
  const boundsList = queue
    .slice(0, queueCount)
    .map((shape) => getShapeBounds(shape))
    .filter(Boolean);
  const shapeHeights = boundsList.map((bounds) => bounds.height);
  const shapeWidths = boundsList.map((bounds) => bounds.width);
  const totalCells =
    shapeHeights.reduce((sum, h) => sum + h, 0) + Math.max(0, queueCount - 1) * queueGapCells;
  const maxShapeWidth = shapeWidths.length ? Math.max(...shapeWidths) : PREVIEW_GRID;
  const availableInnerH = Math.max(0, availableQueueHeight - titleHeight - innerPad * 2);
  const maxCellByHeight = totalCells > 0 ? Math.floor(availableInnerH / totalCells) : 0;
  const maxCellByWidth = Math.floor((queueBoxW - innerPad * 2) / maxShapeWidth);
  const queueCellSize = Math.max(4, Math.min(maxCellByHeight, maxCellByWidth));
  const drawQueueCount = queueCellSize > 0 ? boundsList.length : 0;
  const previewBottom = nextBoxY + previewBox;
  let queueBottom =
    showQueue && drawQueueCount > 0
      ? queueBoxY + availableQueueHeight
      : previewBottom;
  const minInfoY = queueBottom + PADDING * 1.6 + 22;
  const maxInfoY = boardY + boardH - infoBlockHeight;
  const infoY = maxInfoY < minInfoY ? maxInfoY : Math.max(minInfoY, maxInfoY);
  const baseInfoY = infoY;
  if (showQueue && drawQueueCount > 0) {
    queueBottom = baseInfoY;
  }
  const outlineHeight = showQueue && drawQueueCount > 0
    ? Math.max(0, queueBottom - queueBoxY)
    : 0;
  if (showQueue && drawQueueCount > 0) {
    drawPanelBox(ctx, node, queueBoxX, queueBoxY, queueBoxW, outlineHeight, theme.panel_bg, theme.panel_border);
    ctx.fillStyle = theme.text;
    ctx.font = `bold ${titleFontSize}px sans-serif`;
    ctx.fillText("Queue", rightX + titleInset, queueTitleY);
  }
  let cursorY = queueContentY + innerPad;
  boundsList.slice(0, drawQueueCount).forEach((bounds, idx) => {
    const shape = queue[idx];
    if (!shape || !SHAPES[shape]) return;
    if (!showPreviews) return;
    const shapeOffsetX = Math.max(
      0,
      Math.floor(
        (queueBoxW - innerPad * 2 - bounds.width * queueCellSize) / 2,
      ),
    );
    for (const [px, py] of SHAPES[shape][0]) {
      const gx = px - bounds.minX;
      const gy = py - bounds.minY;
      drawBlockSized(
        ctx,
        queueBoxX + innerPad + shapeOffsetX + gx * queueCellSize,
        cursorY + gy * queueCellSize,
        queueCellSize,
        palette[shape],
      );
    }
    cursorY += bounds.height * queueCellSize;
    if (idx < drawQueueCount - 1) {
      cursorY += queueGapCells * queueCellSize;
    }
  });

  if (controlEntries.length) {
    ctx.fillStyle = theme.text;
    ctx.font = `bold ${titleFontSize}px sans-serif`;
    const tableY = baseInfoY;
    const tableX = leftX;
    const tableW = tableWForControls;
    const tableH = Math.max(0, boardY + boardH - tableY);
    drawPanelBox(ctx, node, tableX, tableY, tableW, tableH, theme.panel_bg, theme.panel_border);
    ctx.fillStyle = theme.text;
    ctx.fillText("Controls", tableX + titleInset, tableY + titleFontSize + 4);
    ctx.font = `${fontSize}px sans-serif`;
    let rowY = tableY + titleHeight + tablePad + Math.floor(fontSize * 0.25);
    for (const row of controlRows) {
      const labelX = tableX + tablePad + leftColWidth;
      ctx.textAlign = "right";
      ctx.fillText(row.label, labelX, rowY);
      ctx.textAlign = "left";
      const valueX = tableX + tablePad + leftColWidth + tableGap;
      for (let i = 0; i < row.lines.length; i += 1) {
        const lineY = rowY + i * lineHeight;
        ctx.fillText(row.lines[i], valueX, lineY);
      }
      rowY += row.lines.length * lineHeight;
    }
    ctx.textAlign = "left";
  }

  if (state.gameOver) {
    drawPauseOverlay(ctx, node, boardX, boardY, boardW, boardH, blockSize, bindings, {
      label: "Game Over",
      sublabel: `Press Reset or ${formatPauseHint(bindings)} to play`,
      centerOffsetY: 0,
    });
  } else if (!state.running && state.showBoardWhilePaused) {
    drawPauseOverlay(ctx, node, boardX, boardY, boardW, boardH, blockSize, bindings, {
      label: "Paused",
      sublabel: `Press ${formatPauseHint(bindings)} to resume`,
      centerOffsetY: 0,
    });
  } else if (!state.running && !state.showBoardWhilePaused) {
    const label = state.started ? "Paused" : "Start a new game";
    const sublabel = state.started
      ? `Press ${formatPauseHint(bindings)} to resume`
      : "Press Reset or Pause to play";
    drawPauseOverlay(ctx, node, boardX, boardY, boardW, boardH, blockSize, bindings, {
      label,
      sublabel,
      centerOffsetY: 0,
    });
  }

  drawStatusMessage(node, ctx, { boardX, boardY, boardW, boardH, blockSize, bindings });
  drawToolbar(node, ctx, boardY);
}

function formatPauseHint(bindings) {
  const pauseLabel = formatKeyLabel(bindings.pause?.[0]) || "Pause";
  const pauseAlt = formatKeyLabel(bindings.pause?.[1]);
  return pauseAlt ? `${pauseLabel} (or ${pauseAlt})` : pauseLabel;
}

function drawPauseOverlay(ctx, node, boardX, boardY, boardW, boardH, blockSize, bindings, opts) {
  const { label, sublabel, centerOffsetY } = opts;
  ctx.fillStyle = COLORS.Overlay;
  ctx.fillRect(boardX, boardY, boardW, boardH);
  ctx.fillStyle = getThemeColors(node).text;
  const statusFont = Math.max(12, Math.floor(blockSize * 0.8));
  const subFont = Math.max(10, Math.floor(blockSize * 0.55));
  const centerY = boardY + boardH / 2 + (centerOffsetY || 0);
  ctx.font = `${statusFont}px sans-serif`;
  ctx.fillText(label, boardX + 28, centerY - Math.floor(subFont));
  ctx.font = `${subFont}px sans-serif`;
  ctx.fillText(sublabel, boardX + 28, centerY + subFont);
}

function formatThemeName(theme) {
  if (!theme) return "";
  return theme.charAt(0).toUpperCase() + theme.slice(1);
}

function formatThemeKeyLabel(key) {
  if (!key) return "";
  const renamed = key.replace("bg", "background");
  return renamed
    .split("_")
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
}

function colorToHex8(value) {
  const parsed = parseColorComponents(value || "");
  if (!parsed) return "";
  return rgbToHex8(parsed.r, parsed.g, parsed.b, parsed.a);
}

function getContrastTextColor(value) {
  const parsed = parseColorComponents(value || "");
  if (!parsed) return "#fff";
  const r = parsed.r / 255;
  const g = parsed.g / 255;
  const b = parsed.b / 255;
  const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
  return luminance > 0.6 ? "#000" : "#fff";
}

function toOpaqueColor(value) {
  const parsed = parseColorComponents(value || "");
  if (!parsed) return "#000";
  return rgbaString({ ...parsed, a: 1 }, true);
}

function applySwatchBackground(element, value, showCheckerboard) {
  const parsed = parseColorComponents(value || "");
  const alpha = parsed?.a ?? 1;
  const checkerboardBg =
    "linear-gradient(45deg, rgba(255,255,255,0.25) 25%, transparent 25%)," +
    "linear-gradient(-45deg, rgba(255,255,255,0.25) 25%, transparent 25%)," +
    "linear-gradient(45deg, transparent 75%, rgba(255,255,255,0.25) 75%)," +
    "linear-gradient(-45deg, transparent 75%, rgba(255,255,255,0.25) 75%)";
  element.style.backgroundSize = "10px 10px";
  element.style.backgroundPosition = "0 0, 0 5px, 5px -5px, -5px 0px";
  element.style.backgroundImage = showCheckerboard && alpha < 1 ? checkerboardBg : "none";
  element.style.backgroundColor = rgbaString(parsed, true);
}

function getThemeCornerRadius(node) {
  const config = getConfig(node);
  const settings = config.theme_settings || DEFAULT_CONFIG.theme_settings;
  if (config.theme === "glass") return settings.glass_radius ?? 6;
  if (config.theme === "neon") return settings.neon_radius ?? 6;
  if (config.theme === "flat" || config.theme === "minimal") return 0;
  return 6;
}

function drawPanelBox(ctx, node, x, y, w, h, fillColor, strokeColor) {
  const radius = getThemeCornerRadius(node);
  ctx.fillStyle = fillColor;
  ctx.strokeStyle = strokeColor;
  ctx.lineWidth = 1;
  applyBorderGlow(ctx, node);
  if (radius > 0 && typeof ctx.roundRect === "function") {
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, radius);
    ctx.fill();
    ctx.stroke();
  } else {
    ctx.fillRect(x, y, w, h);
    ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);
  }
  clearBorderGlow(ctx);
}

function applyGlassButtonStyle(node, container) {
  if (!container) return;
  const config = getConfig(node);
  if (config.theme !== "glass") return;
  const themeSettings = config.theme_settings || DEFAULT_CONFIG.theme_settings;
  const radius = themeSettings.glass_radius ?? 6;
  container.querySelectorAll("button").forEach((btn) => {
    btn.style.background =
      "linear-gradient(180deg, rgba(255,255,255,0.35) 0%, rgba(255,255,255,0.15) 55%, rgba(255,255,255,0.08) 100%)";
    btn.style.border = "1px solid rgba(255,255,255,0.35)";
    btn.style.borderRadius = `${radius}px`;
    btn.style.boxShadow = "inset 0 1px 0 rgba(255,255,255,0.45)";
    btn.style.color = getThemeColors(node).text;
    btn.style.opacity = btn.disabled ? "0.7" : "1";
    btn.style.filter = "none";
    btn.style.webkitTextFillColor = getThemeColors(node).text;
  });
}

function applyModalThemeStyles(node, container) {
  if (!container) return;
  const config = getConfig(node);
  const theme = getThemeColors(node);
  const isFlat = config.theme === "flat";
  const isMinimal = config.theme === "minimal";
  const isNeon = config.theme === "neon";
  const themeSettings = config.theme_settings || DEFAULT_CONFIG.theme_settings;
  const radius = getThemeCornerRadius(node);
  const useBorders = !isFlat && !isMinimal;
  const applyButtonStyle = (btn, variant) => {
    const isGlass = config.theme === "glass";
    const isActive = btn.dataset.tnActive === "true";
    const isHover = variant === "hover";
    const isTab = btn.dataset.tnTab === "true";
    if (isTab) {
      const bg = isActive ? theme.button_hover : theme.button_bg;
      btn.style.setProperty("background", bg, "important");
      btn.style.setProperty(
        "border",
        useBorders ? `1px solid ${theme.panel_border}` : "none",
        "important",
      );
      if (useBorders) {
        btn.style.setProperty("border-bottom-color", theme.panel_bg, "important");
      }
      btn.style.setProperty(
        "box-shadow",
        isNeon ? `0 0 ${themeSettings.neon_glow ?? 8}px ${theme.panel_border}` : "none",
        "important",
      );
      btn.style.setProperty("color", theme.text, "important");
      btn.style.setProperty("webkit-text-fill-color", theme.text, "important");
      const radiusValue = `${radius}px ${radius}px 0 0`;
      btn.style.setProperty("border-radius", radiusValue, "important");
      btn.style.setProperty("display", "inline-flex", "important");
      btn.style.setProperty("align-items", "center", "important");
      btn.style.setProperty("justify-content", "center", "important");
      btn.style.setProperty("gap", "6px", "important");
      btn.style.setProperty("height", "26px", "important");
      btn.style.setProperty("padding", "0 12px", "important");
      btn.style.setProperty("font-size", "11px", "important");
      btn.style.setProperty("line-height", "1", "important");
      btn.style.setProperty("cursor", "pointer", "important");
      btn.style.setProperty("opacity", "1", "important");
      btn.style.setProperty("margin-bottom", isActive ? "-1px" : "0", "important");
      return;
    }
    if (isGlass) {
      const gradBase =
        "linear-gradient(180deg, rgba(255,255,255,0.45) 0%, rgba(255,255,255,0.22) 45%, rgba(255,255,255,0.08) 100%)";
      const gradHover =
        "linear-gradient(180deg, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0.3) 45%, rgba(255,255,255,0.12) 100%)";
      const gradActive =
        "linear-gradient(180deg, rgba(255,255,255,0.7) 0%, rgba(255,255,255,0.35) 45%, rgba(255,255,255,0.16) 100%)";
      const gradient = isActive ? gradActive : isHover ? gradHover : gradBase;
      const border = isActive ? "1px solid rgba(255,255,255,0.7)" : "1px solid rgba(255,255,255,0.45)";
      const glow = isActive ? "0 0 8px rgba(255,255,255,0.35)" : "0 2px 6px rgba(0,0,0,0.25)";
      btn.style.setProperty("background", gradient, "important");
      btn.style.setProperty("border", border, "important");
      btn.style.setProperty(
        "box-shadow",
        `inset 0 1px 0 rgba(255,255,255,0.65), ${glow}`,
        "important",
      );
      btn.style.setProperty("background-clip", "padding-box", "important");
    } else {
      const bg = isActive ? theme.button_hover : isHover ? theme.button_hover : theme.button_bg;
      btn.style.setProperty("background", bg, "important");
      btn.style.setProperty(
        "border",
        useBorders ? `1px solid ${theme.panel_border}` : "none",
        "important",
      );
      btn.style.setProperty(
        "box-shadow",
        isNeon ? `0 0 ${themeSettings.neon_glow ?? 8}px ${theme.panel_border}` : "none",
        "important",
      );
    }
    btn.style.setProperty("color", theme.text, "important");
    btn.style.setProperty("webkit-text-fill-color", theme.text, "important");
    btn.style.setProperty("border-radius", `${radius}px`, "important");
    btn.style.setProperty("display", "inline-flex", "important");
    btn.style.setProperty("align-items", "center", "important");
    btn.style.setProperty("justify-content", "center", "important");
    btn.style.setProperty("gap", "6px", "important");
    btn.style.setProperty("height", "24px", "important");
    btn.style.setProperty("padding", "0 10px", "important");
    btn.style.setProperty("font-size", "11px", "important");
    btn.style.setProperty("line-height", "1", "important");
    btn.style.setProperty("cursor", "pointer", "important");
    btn.style.setProperty("opacity", "1", "important");
  };
  container.querySelectorAll("button").forEach((btn) => {
    applyButtonStyle(btn, "base");
    if (!btn.dataset.tnHoverBound) {
      btn.dataset.tnHoverBound = "true";
      btn.addEventListener("mouseenter", () => {
        if (btn.dataset.tnActive === "true") return;
        applyButtonStyle(btn, "hover");
      });
      btn.addEventListener("mouseleave", () => {
        applyButtonStyle(btn, "base");
      });
    }
  });
  container.querySelectorAll("input, select, textarea").forEach((input) => {
    input.style.background = theme.button_bg;
    input.style.color = theme.text;
    input.style.border = useBorders ? `1px solid ${theme.panel_border}` : "none";
    input.style.borderRadius = "6px";
  });
}

function getLoadIconPath() {
  if (LOAD_ICON_PATH2D) return LOAD_ICON_PATH2D;
  if (!window.Path2D) return null;
  try {
    LOAD_ICON_PATH2D = new Path2D(LOAD_ICON_PATH);
  } catch {
    LOAD_ICON_PATH2D = null;
  }
  return LOAD_ICON_PATH2D;
}

function drawLoadIcon(ctx, x, y, size, color) {
  const path = getLoadIconPath();
  if (!path) return false;
  ctx.save();
  ctx.translate(x, y);
  const scale = size / LOAD_ICON_VIEWBOX;
  ctx.scale(scale, scale);
  ctx.fillStyle = color;
  ctx.fill(path);
  ctx.restore();
  return true;
}

function getResetIconPath() {
  if (RESET_ICON_PATH2D) return RESET_ICON_PATH2D;
  if (!window.Path2D) return null;
  try {
    RESET_ICON_PATH2D = new Path2D(RESET_ICON_PATH);
  } catch {
    RESET_ICON_PATH2D = null;
  }
  return RESET_ICON_PATH2D;
}

function drawResetIcon(ctx, x, y, size, color) {
  const path = getResetIconPath();
  if (!path) return false;
  ctx.save();
  ctx.translate(x, y);
  const scale = size / RESET_ICON_VIEWBOX;
  ctx.scale(scale, scale);
  ctx.fillStyle = color;
  ctx.fill(path);
  ctx.restore();
  return true;
}

function getPauseIconPath() {
  if (PAUSE_ICON_PATH2D) return PAUSE_ICON_PATH2D;
  if (!window.Path2D) return null;
  try {
    PAUSE_ICON_PATH2D = new Path2D(PAUSE_ICON_PATH);
  } catch {
    PAUSE_ICON_PATH2D = null;
  }
  return PAUSE_ICON_PATH2D;
}

function drawPauseIcon(ctx, x, y, size, color) {
  const path = getPauseIconPath();
  if (!path) return false;
  ctx.save();
  ctx.translate(x, y);
  const scale = size / PAUSE_ICON_VIEWBOX;
  ctx.scale(scale, scale);
  ctx.fillStyle = color;
  ctx.fill(path);
  ctx.restore();
  return true;
}

function getPlayIconPath() {
  if (PLAY_ICON_PATH2D) return PLAY_ICON_PATH2D;
  if (!window.Path2D) return null;
  try {
    PLAY_ICON_PATH2D = new Path2D(PLAY_ICON_PATH);
  } catch {
    PLAY_ICON_PATH2D = null;
  }
  return PLAY_ICON_PATH2D;
}

function drawPlayIcon(ctx, x, y, size, color) {
  const path = getPlayIconPath();
  if (!path) return false;
  ctx.save();
  ctx.translate(x, y);
  const scale = size / PLAY_ICON_VIEWBOX;
  ctx.scale(scale, scale);
  ctx.fillStyle = color;
  ctx.fill(path);
  ctx.restore();
  return true;
}

function getSettingsIconPath() {
  if (SETTINGS_ICON_PATH2D) return SETTINGS_ICON_PATH2D;
  if (!window.Path2D) return null;
  try {
    SETTINGS_ICON_PATH2D = new Path2D(SETTINGS_ICON_PATH);
  } catch {
    SETTINGS_ICON_PATH2D = null;
  }
  return SETTINGS_ICON_PATH2D;
}

function drawSettingsIcon(ctx, x, y, size, color) {
  const path = getSettingsIconPath();
  if (!path) return false;
  ctx.save();
  ctx.translate(x, y);
  const scale = size / SETTINGS_ICON_VIEWBOX;
  ctx.scale(scale, scale);
  ctx.fillStyle = color;
  ctx.fill(path);
  ctx.restore();
  return true;
}

function applyBorderGlow(ctx, node) {
  const config = getConfig(node);
  if (config.theme !== "neon") return;
  const theme = getThemeColors(node);
  const settings = config.theme_settings || DEFAULT_CONFIG.theme_settings;
  ctx.shadowColor = theme.panel_border;
  ctx.shadowBlur = settings.neon_glow || 8;
}

function clearBorderGlow(ctx) {
  ctx.shadowColor = "transparent";
  ctx.shadowBlur = 0;
}

function drawStatusMessage(node, ctx, layout) {
  const msg = node.__tetrisStatusMessage;
  if (!msg) return;
  if (performance.now() > msg.until) {
    node.__tetrisStatusMessage = null;
    return;
  }
  const { boardX, boardY, boardW, boardH, blockSize, bindings } = layout;
  const pauseHint = formatPauseHint(bindings);
  drawPauseOverlay(ctx, node, boardX, boardY, boardW, boardH, blockSize, bindings, {
    label: "Paused",
    sublabel: `Press ${pauseHint} to resume`,
    centerOffsetY: 0,
  });
  const text = msg.text || "";
  if (!text) return;
  ctx.save();
  ctx.font = "12px sans-serif";
  const paddingX = 10;
  const paddingY = 6;
  const width = ctx.measureText(text).width + paddingX * 2;
  const height = 20 + paddingY;
  const x = boardX + (boardW - width) / 2;
  const y = boardY + 100 - height / 2;
  ctx.fillStyle = msg.kind === "error" ? "rgba(180,60,60,0.85)" : "rgba(30,120,60,0.85)";
  ctx.fillRect(x, y, width, height);
  ctx.fillStyle = "#fff";
  ctx.fillText(text, x + paddingX, y + height - 8);
  ctx.restore();
}

function getThemeColors(node) {
  const config = getConfig(node);
  const theme = config.theme && config.theme_colors?.[config.theme] ? config.theme : "glass";
  return config.theme_colors?.[theme] || THEME_PRESETS[theme];
}

function ensureUiState(node) {
  if (!node.__tetrisUi) {
    node.__tetrisUi = {
      toolbarButtons: [],
      hoverButton: null,
      modal: null,
      captureAction: null,
    };
  }
  return node.__tetrisUi;
}

function buildToolbarButtons(node, toolbarY, barH) {
  const btnSize = 24;
  const gap = 8;
  const top = toolbarY + (barH - btnSize) / 2;
  const leftStart = PADDING + 6;
  const rightStart = node.size[0] - PADDING - 6;
  const leftButtons = [
    { id: "load", label: "L", tooltip: "Load State" },
    { id: "reset", label: "R", tooltip: "Reset" },
    { id: "pause", label: "P", tooltip: "Pause/Play" },
  ];
  const rightButtons = [
    { id: "settings", label: "S", tooltip: "Settings" },
  ];
  const buttons = [];
  let x = leftStart;
  for (const btn of leftButtons) {
    buttons.push({ ...btn, x, y: top, w: btnSize, h: btnSize });
    x += btnSize + gap;
  }
  let rightX = rightStart;
  for (const btn of rightButtons) {
    rightX -= btnSize;
    buttons.push({ ...btn, x: rightX, y: top, w: btnSize, h: btnSize });
    rightX -= gap;
  }
  return { buttons, height: TOOLBAR_H, top };
}

function drawToolbar(node, ctx, boardY) {
  const ui = ensureUiState(node);
  const config = getConfig(node);
  const theme = getThemeColors(node);
  const themeSettings = config.theme_settings || DEFAULT_CONFIG.theme_settings;
  const live = node.__tetrisLive;
  const state = live?.state;
  const isPlaying = !!(state && state.running && state.started && !state.gameOver);
  const pauseTooltip = isPlaying ? "Pause" : "Play";
  const desiredY = boardY - TOOLBAR_H - 10;
  const barY = Math.max(HEADER_H + 2, Math.round(desiredY));
  const barX = PADDING;
  const barW = node.size[0] - PADDING * 2;
  const barH = TOOLBAR_H - 6;
  const { buttons } = buildToolbarButtons(node, barY, barH);
  ui.toolbarButtons = buttons;
  ui.toolbarRect = { x: barX, y: barY, w: barW, h: barH };
  ctx.save();
  ctx.fillStyle = theme.panel_bg;
  ctx.strokeStyle = theme.panel_border;
  ctx.lineWidth = 1;
  if (config.theme === "neon") {
    ctx.shadowColor = theme.panel_border;
    ctx.shadowBlur = themeSettings.neon_glow || 8;
  }
  if ((config.theme === "glass" || config.theme === "neon") && typeof ctx.roundRect === "function") {
    const radius = getThemeCornerRadius(node);
    ctx.beginPath();
    ctx.roundRect(barX, barY, barW, barH, radius);
    ctx.fill();
    if (config.theme !== "flat" && config.theme !== "minimal") {
      ctx.stroke();
    }
  } else if (config.theme !== "minimal") {
    ctx.fillRect(barX, barY, barW, barH);
    if (config.theme !== "flat") {
      ctx.strokeRect(barX + 0.5, barY + 0.5, barW - 1, barH - 1);
    }
  }
  ctx.font = "12px sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  for (const btn of buttons) {
    if (btn.id === "pause") {
      btn.tooltip = pauseTooltip;
    }
    const hovered = ui.hoverButton && ui.hoverButton.id === btn.id;
    const iconColor = theme.button || theme.text;
    if (config.theme === "glass") {
      const radius = themeSettings.glass_radius ?? 6;
      const grad = ctx.createLinearGradient(0, btn.y, 0, btn.y + btn.h);
      const gradBase =
        "linear-gradient(180deg, rgba(255,255,255,0.45) 0%, rgba(255,255,255,0.22) 45%, rgba(255,255,255,0.08) 100%)";
      const gradHover =
        "linear-gradient(180deg, rgba(255,255,255,0.7) 0%, rgba(255,255,255,0.35) 45%, rgba(255,255,255,0.16) 100%)";
      const stops = (hovered ? gradHover : gradBase).match(/rgba\([^)]+\)/g) || [];
      grad.addColorStop(0, stops[0] || "rgba(255,255,255,0.45)");
      grad.addColorStop(0.45, stops[1] || "rgba(255,255,255,0.22)");
      grad.addColorStop(1, stops[2] || "rgba(255,255,255,0.08)");
      ctx.fillStyle = grad;
      if (typeof ctx.roundRect === "function") {
        ctx.beginPath();
        ctx.roundRect(btn.x, btn.y, btn.w, btn.h, radius);
        ctx.fill();
      } else {
        ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
      }
      if (typeof ctx.roundRect === "function") {
        const borderWidth = 1;
        const lightStroke = "rgba(255,255,255,0.7)";
        const baseStroke = "rgba(255,255,255,0.7)";
        const outerX = btn.x + 0.5;
        const outerY = btn.y + 0.5;
        const outerW = btn.w - 1;
        const outerH = btn.h - 1;
        const innerX = btn.x + 0.5;
        const innerY = outerY + borderWidth;
        const innerW = outerW;
        const innerH = outerH - borderWidth;
        const innerRadius = Math.max(0, radius - borderWidth);
        ctx.lineWidth = borderWidth;
        ctx.strokeStyle = lightStroke;
        ctx.beginPath();
        ctx.roundRect(innerX, innerY, innerW, innerH, innerRadius);
        ctx.stroke();
        ctx.strokeStyle = baseStroke;
        ctx.beginPath();
        ctx.roundRect(outerX, outerY, outerW, outerH, radius);
        ctx.stroke();
      } else {
        ctx.strokeStyle = hovered ? "rgba(255,255,255,0.7)" : "rgba(255,255,255,0.45)";
        ctx.strokeRect(btn.x + 0.5, btn.y + 0.5, btn.w - 1, btn.h - 1);
      }
    } else if (config.theme === "neon") {
      const radius = getThemeCornerRadius(node);
      ctx.fillStyle = hovered ? theme.button_hover : theme.button_bg;
      if (typeof ctx.roundRect === "function") {
        ctx.beginPath();
        ctx.roundRect(btn.x, btn.y, btn.w, btn.h, radius);
        ctx.fill();
      } else {
        ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
      }
    } else {
      ctx.fillStyle = hovered ? theme.button_hover : theme.button_bg;
      ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
    }
    if (config.theme !== "flat") {
      ctx.strokeStyle = theme.panel_border;
      if ((config.theme === "glass" || config.theme === "neon") && typeof ctx.roundRect === "function") {
        const radius = getThemeCornerRadius(node);
        ctx.beginPath();
        ctx.roundRect(btn.x + 0.5, btn.y + 0.5, btn.w - 1, btn.h - 1, radius);
        ctx.stroke();
      } else {
        ctx.strokeRect(btn.x + 0.5, btn.y + 0.5, btn.w - 1, btn.h - 1);
      }
    }
    ctx.fillStyle = theme.text;
    if (btn.id === "load") {
      const iconSize = Math.floor(btn.w * 0.7);
      const iconX = btn.x + (btn.w - iconSize) / 2;
      const iconY = btn.y + (btn.h - iconSize) / 2;
      if (!drawLoadIcon(ctx, iconX, iconY, iconSize, iconColor)) {
        ctx.fillText(btn.label, btn.x + btn.w / 2, btn.y + btn.h / 2 + 0.5);
      }
    } else if (btn.id === "reset") {
      const iconSize = Math.floor(btn.w * 0.82);
      const iconX = btn.x + (btn.w - iconSize) / 2;
      const iconY = btn.y + (btn.h - iconSize) / 2;
      if (!drawResetIcon(ctx, iconX, iconY, iconSize, iconColor)) {
        ctx.fillText(btn.label, btn.x + btn.w / 2, btn.y + btn.h / 2 + 0.5);
      }
    } else if (btn.id === "pause") {
      const iconSize = Math.floor(btn.w * 0.75);
      const iconX = btn.x + (btn.w - iconSize) / 2;
      const iconY = btn.y + (btn.h - iconSize) / 2;
      const drew = isPlaying
        ? drawPauseIcon(ctx, iconX, iconY, iconSize, iconColor)
        : drawPlayIcon(ctx, iconX, iconY, iconSize, iconColor);
      if (!drew) {
        ctx.fillText(btn.label, btn.x + btn.w / 2, btn.y + btn.h / 2 + 0.5);
      }
    } else if (btn.id === "settings") {
      const iconSize = Math.floor(btn.w * 0.7);
      const iconX = btn.x + (btn.w - iconSize) / 2;
      const iconY = btn.y + (btn.h - iconSize) / 2;
      if (!drawSettingsIcon(ctx, iconX, iconY, iconSize, iconColor)) {
        ctx.fillText(btn.label, btn.x + btn.w / 2, btn.y + btn.h / 2 + 0.5);
      }
    } else {
      ctx.fillText(btn.label, btn.x + btn.w / 2, btn.y + btn.h / 2 + 0.5);
    }
  }
  if (ui.hoverButton?.tooltip) {
    const tooltip = ui.hoverButton.tooltip;
    ctx.font = "11px sans-serif";
    const padding = 6;
    const width = ctx.measureText(tooltip).width + padding * 2;
    const height = 20;
    const tipX = Math.min(node.size[0] - width - 8, ui.hoverButton.x + ui.hoverButton.w / 2 - width / 2);
    const tipY = barY + barH + 6;
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(tipX, tipY, width, height);
    ctx.fillStyle = "#fff";
    ctx.fillText(tooltip, tipX + width / 2, tipY + height / 2 + 0.5);
  }
  ctx.restore();
}

function hitToolbarButton(node, pos, boardY = null) {
  const ui = ensureUiState(node);
  if (!ui.toolbarButtons?.length) {
    const fallbackY = boardY ?? node.__tetrisLastLayout?.boardY ?? (HEADER_H + TOOLBAR_H + 10);
    const barY = Math.max(HEADER_H + 2, fallbackY - TOOLBAR_H - 10);
    const metrics = buildToolbarButtons(node, barY, TOOLBAR_H - 6);
    ui.toolbarButtons = metrics.buttons;
  }
  const [x, y] = pos;
  return ui.toolbarButtons.find(
    (btn) => x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h,
  );
}

function handleToolbarClick(node, pos) {
  const btn = hitToolbarButton(node, pos, node.__tetrisLastLayout?.boardY);
  if (!btn) return false;
  if (btn.id === "reset") {
    resetNode(node);
    return true;
  }
  if (btn.id === "pause") {
    togglePause(node);
    return true;
  }
  if (btn.id === "load") {
    openLoadStateModal(node);
    return true;
  }
  if (btn.id === "settings") {
    openSettingsModal(node);
    return true;
  }
  return false;
}

function closeModal(node) {
  const ui = ensureUiState(node);
  if (ui.modal?.el) {
    ui.modal.el.remove();
  }
  ui.modal = null;
  ui.captureAction = null;
}

function pauseForModal(node) {
  const live = node.__tetrisLive;
  if (!live) return;
  live.state.running = false;
  live.state.showBoardWhilePaused = true;
  node.setDirtyCanvas(true, true);
}

function createModalBase(node, title) {
  closeModal(node);
  pauseForModal(node);
  const config = getConfig(node);
  const theme = getThemeColors(node);
  const themeSettings = config.theme_settings || DEFAULT_CONFIG.theme_settings;
  const modal = document.createElement("div");
  modal.style.position = "fixed";
  modal.style.left = "50%";
  modal.style.top = "50%";
  modal.style.transform = "translate(-50%, -50%)";
  modal.style.minWidth = "360px";
  modal.style.maxWidth = "70vw";
  modal.style.maxHeight = "70vh";
  const modalBg = toOpaqueColor(theme.panel_bg);
  modal.style.background = modalBg;
  const showBorder = title === "Theme" || (config.theme !== "flat" && config.theme !== "minimal");
  modal.style.border = showBorder ? `1px solid ${theme.panel_border}` : "none";
  if (config.theme === "neon") {
    const glow = themeSettings.neon_glow || 8;
    modal.style.boxShadow = `0 0 ${glow}px ${theme.panel_border}, 0 10px 30px ${theme.panel_shadow}`;
  } else {
    modal.style.boxShadow = `0 10px 30px ${theme.panel_shadow}`;
  }
  modal.style.color = theme.text;
  modal.style.backdropFilter = "none";
  modal.style.padding = "12px";
  modal.style.borderRadius = `${getThemeCornerRadius(node)}px`;
  modal.style.zIndex = "9999";
  modal.style.display = "flex";
  modal.style.flexDirection = "column";
  modal.style.gap = "10px";

  const header = document.createElement("div");
  header.style.display = "flex";
  header.style.justifyContent = "space-between";
  header.style.alignItems = "center";
  header.style.cursor = "move";
  header.style.fontWeight = "600";
  header.textContent = title;

  const closeBtn = document.createElement("button");
  closeBtn.textContent = "X";
  closeBtn.style.marginLeft = "12px";
  closeBtn.style.border = "none";
  closeBtn.style.background = "transparent";
  closeBtn.style.color = theme.text;
  closeBtn.style.cursor = "pointer";
  closeBtn.addEventListener("click", () => closeModal(node));
  header.appendChild(closeBtn);

  const body = document.createElement("div");
  body.style.overflow = "auto";
  body.style.display = "flex";
  body.style.flexDirection = "column";
  body.style.gap = "8px";

  modal.appendChild(header);
  modal.appendChild(body);
  document.body.appendChild(modal);

  let drag = null;
  header.addEventListener("mousedown", (event) => {
    drag = {
      startX: event.clientX,
      startY: event.clientY,
      rect: modal.getBoundingClientRect(),
    };
    event.preventDefault();
  });
  window.addEventListener("mousemove", (event) => {
    if (!drag) return;
    const dx = event.clientX - drag.startX;
    const dy = event.clientY - drag.startY;
    modal.style.left = `${drag.rect.left + dx}px`;
    modal.style.top = `${drag.rect.top + dy}px`;
    modal.style.transform = "translate(0, 0)";
  });
  window.addEventListener("mouseup", () => {
    drag = null;
  });

  ensureUiState(node).modal = { el: modal, body, title };
  return { modal, body };
}

function openLoadStateModal(node) {
  const { body } = createModalBase(node, "Load State");
  const textarea = document.createElement("textarea");
  textarea.style.width = "100%";
  textarea.style.minHeight = "140px";
  textarea.placeholder = "Paste state JSON here...";
  const actions = document.createElement("div");
  actions.style.display = "flex";
  actions.style.gap = "8px";
  const loadBtn = document.createElement("button");
  loadBtn.textContent = "Load";
  loadBtn.addEventListener("click", () => {
    loadStateFromText(node, textarea.value);
  });
  const closeBtn = document.createElement("button");
  closeBtn.textContent = "Close";
  closeBtn.addEventListener("click", () => closeModal(node));
  actions.append(loadBtn, closeBtn);
  body.append(textarea, actions);
}

function openSettingsModal(node) {
  const { body } = createModalBase(node, "Settings");
  renderSettingsModal(node, body, "settings");
}

function renderSettingsModal(node, body, activeTab = "settings") {
  body.innerHTML = "";
  const tabs = [
    { id: "settings", label: "Settings" },
    { id: "controls", label: "Controls" },
    { id: "colors", label: "Tetrominos" },
    { id: "theme", label: "UI Themes" },
  ];
  const tabRow = document.createElement("div");
  tabRow.style.display = "flex";
  tabRow.style.flexWrap = "wrap";
  tabRow.style.gap = "8px";
  tabRow.style.borderBottom = `1px solid ${getThemeColors(node).panel_border}`;
  tabRow.style.borderBottomColor = getThemeColors(node).panel_border;
  tabRow.style.paddingBottom = "0";
  tabRow.style.marginBottom = "0";
  tabs.forEach((tab) => {
    const btn = document.createElement("button");
    btn.textContent = tab.label;
    btn.dataset.tnTab = "true";
    btn.dataset.tnActive = tab.id === activeTab ? "true" : "false";
    btn.addEventListener("click", () => {
      renderSettingsModal(node, body, tab.id);
    });
    tabRow.appendChild(btn);
  });
  const panel = document.createElement("div");
  panel.style.display = "flex";
  panel.style.flexDirection = "column";
  panel.style.gap = "8px";
  body.append(tabRow, panel);
  if (activeTab === "controls") {
    renderControlsModal(node, panel);
  } else if (activeTab === "colors") {
    renderColorsModal(node, panel);
  } else if (activeTab === "theme") {
    renderThemeModal(node, panel);
  } else {
    renderGameplayModal(node, panel);
  }
  const modalEl = body.parentElement || body;
  applyModalThemeStyles(node, modalEl);
}

function openControlsModal(node) {
  const { body } = createModalBase(node, "Controls");
  renderControlsModal(node, body);
}

function renderControlsModal(node, body) {
  body.innerHTML = "";
  const ui = ensureUiState(node);
  const config = getConfig(node);
  const theme = getThemeColors(node);
  const showBorders = config.theme !== "flat" && config.theme !== "minimal";
  const actions = [
    { id: "move_left", label: "Move Left" },
    { id: "move_right", label: "Move Right" },
    { id: "rotate_cw", label: "Rotate CW" },
    { id: "rotate_ccw", label: "Rotate CCW" },
    { id: "soft_drop", label: "Soft Drop" },
    { id: "hard_drop", label: "Hard Drop" },
    { id: "hold", label: "Hold" },
    { id: "reset", label: "Reset" },
    { id: "pause", label: "Pause" },
  ];
  const hint = document.createElement("div");
  hint.style.fontSize = "12px";
  hint.style.opacity = "0.8";
  hint.textContent = ui.captureAction
    ? `Press a key for ${actions.find((a) => a.id === ui.captureAction)?.label || ""} (Esc to cancel)`
    : "Click Add to capture a key binding.";
  body.appendChild(hint);
  if (ui.captureAction) {
    const cancel = document.createElement("button");
    cancel.textContent = "Cancel Capture";
    cancel.addEventListener("click", () => {
      ui.captureAction = null;
      renderControlsModal(node, body);
    });
    body.appendChild(cancel);
  }

  actions.forEach((action) => {
    const row = document.createElement("div");
    row.style.display = "grid";
    row.style.gridTemplateColumns = "120px 1fr auto auto";
    row.style.gap = "8px";
    row.style.alignItems = "center";
    const label = document.createElement("div");
    label.textContent = action.label;
    const keys = document.createElement("div");
    keys.style.display = "flex";
    keys.style.gap = "6px";
    keys.style.flexWrap = "wrap";
    const values = Array.isArray(config.bindings[action.id]) ? config.bindings[action.id] : [];
    values.forEach((value) => {
      const chip = document.createElement("div");
      chip.style.display = "flex";
      chip.style.alignItems = "center";
      chip.style.gap = "4px";
      chip.style.padding = "2px 6px";
      chip.style.borderRadius = "10px";
      chip.style.background = "rgba(255,255,255,0.08)";
      if (showBorders) {
        chip.style.border = `1px solid ${theme.panel_border}`;
      } else {
        chip.style.border = "none";
      }
      const text = document.createElement("span");
      text.textContent = formatKeyLabel(value);
      const remove = document.createElement("button");
      remove.textContent = "X";
      remove.style.border = "none";
      remove.style.background = "transparent";
      remove.style.cursor = "pointer";
      remove.addEventListener("click", () => {
        updateConfig(node, (next) => {
          next.bindings[action.id] = next.bindings[action.id].filter((k) => k !== value);
          return next;
        });
        updateBackendState(node);
        renderControlsModal(node, body);
      });
      chip.append(text, remove);
      keys.appendChild(chip);
    });
    const addBtn = document.createElement("button");
    addBtn.textContent = "Add";
    addBtn.addEventListener("click", () => {
      ui.captureAction = action.id;
      renderControlsModal(node, body);
    });
    const resetBtn = document.createElement("button");
    resetBtn.textContent = "Reset";
    resetBtn.addEventListener("click", () => {
      updateConfig(node, (next) => {
        next.bindings[action.id] = cloneDeep(DEFAULT_CONFIG.bindings[action.id]);
        return next;
      });
      updateBackendState(node);
      renderControlsModal(node, body);
    });
    row.append(label, keys, addBtn, resetBtn);
    body.appendChild(row);
    const divider = document.createElement("div");
    divider.style.height = "1px";
    divider.style.margin = "6px 0";
    divider.style.background = theme.panel_border;
    divider.style.opacity = "0.3";
    body.appendChild(divider);
  });
  const modalEl = body.parentElement || body;
  applyModalThemeStyles(node, modalEl);
}

function openColorsModal(node) {
  const { body } = createModalBase(node, "Colors");
  renderColorsModal(node, body);
}

function renderColorsModal(node, body) {
  body.innerHTML = "";
  const config = getConfig(node);
  const items = [
    { id: "color_i", label: "I" },
    { id: "color_j", label: "J" },
    { id: "color_l", label: "L" },
    { id: "color_o", label: "O" },
    { id: "color_s", label: "S" },
    { id: "color_t", label: "T" },
    { id: "color_z", label: "Z" },
    { id: "background_color", label: "Background", alpha: false },
    { id: "grid_color", label: "Grid", alpha: true, target: "grid_color" },
  ];
  items.forEach((item) => {
    const row = document.createElement("div");
    row.style.display = "grid";
    row.style.gridTemplateColumns = "120px 1fr auto";
    row.style.gap = "8px";
    row.style.alignItems = "center";
    const label = document.createElement("div");
    label.textContent = item.label;
    const swatch = document.createElement("div");
    const value =
      item.id === "grid_color" ? config.grid_color : config.colors[item.id];
    swatch.style.width = "100%";
    swatch.style.height = "18px";
    swatch.style.border = "1px solid rgba(255,255,255,0.2)";
    applySwatchBackground(swatch, value, true);
    swatch.style.display = "flex";
    swatch.style.alignItems = "center";
    swatch.style.justifyContent = "center";
    swatch.style.fontSize = "10px";
    swatch.style.fontFamily = "sans-serif";
    const hexText = colorToHex8(value);
    swatch.textContent = hexText || "";
    swatch.style.color = getContrastTextColor(value);
    swatch.style.cursor = "pointer";
    swatch.addEventListener("click", () => {
      const fallback =
        item.id === "grid_color" ? DEFAULT_CONFIG.grid_color : DEFAULT_CONFIG.colors[item.id];
      openColorPicker(node, value, item.alpha !== false, fallback, (nextValue) => {
        updateConfig(node, (next) => {
          if (item.id === "grid_color") {
            next.grid_color = nextValue;
          } else {
            next.colors[item.id] = nextValue;
          }
          return next;
        });
        updateBackendState(node);
        renderColorsModal(node, body);
      });
    });
    const resetBtn = document.createElement("button");
    resetBtn.textContent = "Reset";
    resetBtn.addEventListener("click", () => {
      updateConfig(node, (next) => {
        if (item.id === "grid_color") {
          next.grid_color = DEFAULT_CONFIG.grid_color;
        } else {
          next.colors[item.id] = DEFAULT_CONFIG.colors[item.id];
        }
        return next;
      });
      updateBackendState(node);
      renderColorsModal(node, body);
    });
    row.append(label, swatch, resetBtn);
    body.appendChild(row);
  });
  const modalEl = body.parentElement || body;
  applyModalThemeStyles(node, modalEl);
}

function openThemeModal(node) {
  const { body } = createModalBase(node, "Theme");
  renderThemeModal(node, body);
}

function renderThemeModal(node, body) {
  body.innerHTML = "";
  const config = getConfig(node);
  const themeRow = document.createElement("div");
  themeRow.style.display = "flex";
  themeRow.style.gap = "8px";
  ["glass", "flat", "neon", "minimal"].forEach((theme) => {
    const btn = document.createElement("button");
    btn.textContent = formatThemeName(theme);
    btn.disabled = config.theme === theme;
    btn.dataset.tnActive = btn.disabled ? "true" : "false";
    btn.addEventListener("click", () => {
      updateConfig(node, (next) => {
        next.theme = theme;
        return next;
      });
      renderThemeModal(node, body);
      node.setDirtyCanvas(true, true);
    });
    themeRow.appendChild(btn);
  });
  const resetBtn = document.createElement("button");
  resetBtn.textContent = "Reset Theme Colors";
  resetBtn.addEventListener("click", () => {
    updateConfig(node, (next) => {
      next.theme_colors[config.theme] = cloneDeep(DEFAULT_CONFIG.theme_colors[config.theme]);
      return next;
    });
    renderThemeModal(node, body);
    node.setDirtyCanvas(true, true);
  });
  body.append(themeRow, resetBtn);

  const settings = config.theme_settings || DEFAULT_CONFIG.theme_settings;
  if (config.theme === "glass") {
    const row = document.createElement("div");
    row.style.display = "grid";
    row.style.gridTemplateColumns = "150px 1fr auto";
    row.style.gap = "8px";
    const label = document.createElement("div");
    label.textContent = "Corner Radius";
    const slider = document.createElement("input");
    slider.type = "range";
    slider.min = "0";
    slider.max = "16";
    slider.step = "1";
    slider.value = `${settings.glass_radius}`;
    slider.addEventListener("input", () => {
      updateConfig(node, (next) => {
        next.theme_settings.glass_radius = Number.parseInt(slider.value, 10);
        return next;
      });
      node.setDirtyCanvas(true, true);
    });
    const resetBtn = document.createElement("button");
    resetBtn.textContent = "Reset";
    resetBtn.addEventListener("click", () => {
      updateConfig(node, (next) => {
        next.theme_settings.glass_radius = DEFAULT_CONFIG.theme_settings.glass_radius;
        return next;
      });
      renderThemeModal(node, body);
      node.setDirtyCanvas(true, true);
    });
    row.append(label, slider, resetBtn);
    body.appendChild(row);
  }

  if (config.theme === "neon") {
    const glowRow = document.createElement("div");
    glowRow.style.display = "grid";
    glowRow.style.gridTemplateColumns = "150px 1fr auto";
    glowRow.style.gap = "8px";
    const glowLabel = document.createElement("div");
    glowLabel.textContent = "Glow Strength";
    const glowSlider = document.createElement("input");
    glowSlider.type = "range";
    glowSlider.min = "0";
    glowSlider.max = "24";
    glowSlider.step = "1";
    glowSlider.value = `${settings.neon_glow}`;
    glowSlider.addEventListener("input", () => {
      updateConfig(node, (next) => {
        next.theme_settings.neon_glow = Number.parseInt(glowSlider.value, 10);
        return next;
      });
      node.setDirtyCanvas(true, true);
    });
    const glowReset = document.createElement("button");
    glowReset.textContent = "Reset";
    glowReset.addEventListener("click", () => {
      updateConfig(node, (next) => {
        next.theme_settings.neon_glow = DEFAULT_CONFIG.theme_settings.neon_glow;
        return next;
      });
      renderThemeModal(node, body);
      node.setDirtyCanvas(true, true);
    });
    glowRow.append(glowLabel, glowSlider, glowReset);
    body.appendChild(glowRow);

    const radiusRow = document.createElement("div");
    radiusRow.style.display = "grid";
    radiusRow.style.gridTemplateColumns = "150px 1fr auto";
    radiusRow.style.gap = "8px";
    const radiusLabel = document.createElement("div");
    radiusLabel.textContent = "Corner Radius";
    const radiusSlider = document.createElement("input");
    radiusSlider.type = "range";
    radiusSlider.min = "0";
    radiusSlider.max = "16";
    radiusSlider.step = "1";
    radiusSlider.value = `${settings.neon_radius ?? settings.glass_radius ?? 6}`;
    radiusSlider.addEventListener("input", () => {
      updateConfig(node, (next) => {
        next.theme_settings.neon_radius = Number.parseInt(radiusSlider.value, 10);
        return next;
      });
      node.setDirtyCanvas(true, true);
    });
    const radiusReset = document.createElement("button");
    radiusReset.textContent = "Reset";
    radiusReset.addEventListener("click", () => {
      updateConfig(node, (next) => {
        next.theme_settings.neon_radius = DEFAULT_CONFIG.theme_settings.neon_radius;
        return next;
      });
      renderThemeModal(node, body);
      node.setDirtyCanvas(true, true);
    });
    radiusRow.append(radiusLabel, radiusSlider, radiusReset);
    body.appendChild(radiusRow);
  }

  const themeColors = config.theme_colors?.[config.theme] || THEME_PRESETS[config.theme];
  Object.entries(themeColors)
    .filter(([key]) => THEME_USED_KEYS.has(key))
    .forEach(([key, value]) => {
      const row = document.createElement("div");
      row.style.display = "grid";
      row.style.gridTemplateColumns = "150px 1fr auto";
      row.style.gap = "8px";
      row.style.alignItems = "center";
      const label = document.createElement("div");
      label.textContent = formatThemeKeyLabel(key);
      const swatch = document.createElement("div");
    swatch.style.width = "100%";
    swatch.style.height = "18px";
    swatch.style.border = "1px solid rgba(255,255,255,0.2)";
    applySwatchBackground(swatch, value, true);
    swatch.style.display = "flex";
    swatch.style.alignItems = "center";
    swatch.style.justifyContent = "center";
    swatch.style.fontSize = "11px";
    swatch.style.fontFamily = "sans-serif";
    swatch.style.fontWeight = "bold";
    const hexText = colorToHex8(value);
    swatch.textContent = hexText || "";
    swatch.style.color = getContrastTextColor(value);
      swatch.style.cursor = "pointer";
      swatch.addEventListener("click", () => {
        const fallback = THEME_PRESETS[config.theme][key];
        openColorPicker(node, value, true, fallback, (nextValue) => {
          updateConfig(node, (next) => {
            next.theme_colors[config.theme][key] = nextValue;
            return next;
          });
          renderThemeModal(node, body);
          node.setDirtyCanvas(true, true);
        });
      });
      const resetBtn = document.createElement("button");
      resetBtn.textContent = "Reset";
      resetBtn.addEventListener("click", () => {
        updateConfig(node, (next) => {
          next.theme_colors[config.theme][key] = THEME_PRESETS[config.theme][key];
          return next;
        });
        renderThemeModal(node, body);
        node.setDirtyCanvas(true, true);
      });
      row.append(label, swatch, resetBtn);
      body.appendChild(row);
    });
  const modalEl = body.parentElement || body;
  applyModalThemeStyles(node, modalEl);
}

function openGameplayModal(node) {
  const { body } = createModalBase(node, "Settings");
  renderGameplayModal(node, body);
}

function renderGameplayModal(node, body) {
  body.innerHTML = "";
  const config = getConfig(node);
  const checkbox = (labelText, key, attach = true) => {
    const row = document.createElement("label");
    row.style.display = "flex";
    row.style.gap = "8px";
    row.style.alignItems = "center";
    const input = document.createElement("input");
    input.type = "checkbox";
    input.checked = !!config[key];
    input.addEventListener("change", () => {
      updateConfig(node, (next) => {
        next[key] = input.checked;
        return next;
      });
      updateBackendState(node);
      node.setDirtyCanvas(true, true);
    });
    row.append(input, document.createTextNode(labelText));
    if (attach) {
      body.appendChild(row);
    }
    return row;
  };
  const showControlsRow = checkbox("Show Controls", "show_controls", false);
  const versionLabel = document.createElement("div");
  versionLabel.textContent = `v${TETRINODE_VERSION}`;
  versionLabel.style.marginLeft = "auto";
  versionLabel.style.fontSize = "12px";
  versionLabel.style.opacity = "0.8";
  const topRow = document.createElement("div");
  topRow.style.display = "flex";
  topRow.style.alignItems = "center";
  topRow.style.justifyContent = "space-between";
  topRow.append(showControlsRow, versionLabel);
  body.appendChild(topRow);
  checkbox("Ghost Piece", "ghost_piece");
  checkbox("Next Piece", "next_piece");
  checkbox("Hold Queue", "hold_queue");
  checkbox("Grid", "grid_enabled");

  const selectRow = (labelText, key, options) => {
    const row = document.createElement("div");
    row.style.display = "grid";
    row.style.gridTemplateColumns = "140px 1fr";
    row.style.gap = "8px";
    const label = document.createElement("div");
    label.textContent = labelText;
    const select = document.createElement("select");
    options.forEach((value) => {
      const opt = document.createElement("option");
      const optionValue = typeof value === "string" ? value : value.value;
      const optionLabel = typeof value === "string" ? value : value.label;
      opt.value = optionValue;
      opt.textContent = optionLabel;
      if (`${config[key]}` === optionValue) opt.selected = true;
      select.appendChild(opt);
    });
    select.addEventListener("change", () => {
      updateConfig(node, (next) => {
        next[key] = select.value;
        return next;
      });
      updateBackendState(node);
    });
    row.append(label, select);
    body.appendChild(row);
  };

  selectRow("Lock Down", "lock_down_mode", [
    { value: "extended", label: "Extended" },
    { value: "infinite", label: "Infinite" },
    { value: "classic", label: "Classic" },
  ]);
  selectRow("Level Progression", "level_progression", [
    { value: "fixed", label: "Fixed" },
    { value: "variable", label: "Variable" },
  ]);

  const numberRow = (labelText, key, min, max) => {
    const row = document.createElement("div");
    row.style.display = "grid";
    row.style.gridTemplateColumns = "140px 1fr";
    row.style.gap = "8px";
    const label = document.createElement("div");
    label.textContent = labelText;
    const input = document.createElement("input");
    input.type = "number";
    input.min = min;
    input.max = max;
    input.value = config[key];
    input.addEventListener("change", () => {
      updateConfig(node, (next) => {
        next[key] = Number.parseInt(input.value, 10);
        return next;
      });
      updateBackendState(node);
    });
    row.append(label, input);
    body.appendChild(row);
  };

  numberRow("Start Level", "start_level", 1, 15);
  numberRow("Queue Size", "queue_size", 0, 6);
}

function openColorPicker(node, value, allowAlpha, defaultValue, onApply) {
  const overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.inset = "0";
  overlay.style.background = "rgba(0,0,0,0.4)";
  overlay.style.zIndex = "10000";
  const dialog = document.createElement("div");
  dialog.style.position = "fixed";
  dialog.style.left = "50%";
  dialog.style.top = "50%";
  dialog.style.transform = "translate(-50%, -50%)";
  dialog.style.padding = "12px";
  dialog.style.borderRadius = "10px";
  const theme = getThemeColors(node);
  dialog.style.background = toOpaqueColor(theme.panel_bg);
  dialog.style.border = `1px solid ${theme.panel_border}`;
  dialog.style.color = theme.text;
  dialog.style.display = "flex";
  dialog.style.flexDirection = "column";
  dialog.style.gap = "8px";
  dialog.style.width = "max-content";
  dialog.style.maxWidth = "360px";
  const components = parseColorComponents(value);
  const defaultColor = defaultValue ?? value;
  const hsl = rgbToHsl(components.r, components.g, components.b);
  let hsv = rgbToHsv(components.r, components.g, components.b);
  const preview = document.createElement("div");
  preview.style.width = "100%";
  preview.style.height = "24px";
  preview.style.border = "1px solid rgba(255,255,255,0.2)";
  const checkerboardBg =
    "linear-gradient(45deg, rgba(255,255,255,0.25) 25%, transparent 25%)," +
    "linear-gradient(-45deg, rgba(255,255,255,0.25) 25%, transparent 25%)," +
    "linear-gradient(45deg, transparent 75%, rgba(255,255,255,0.25) 75%)," +
    "linear-gradient(-45deg, transparent 75%, rgba(255,255,255,0.25) 75%)";
  preview.style.backgroundSize = "12px 12px";
  preview.style.backgroundPosition = "0 0, 0 6px, 6px -6px, -6px 0px";
  preview.style.backgroundImage = allowAlpha && components.a < 1 ? checkerboardBg : "none";
  preview.style.backgroundColor = rgbaString(components, allowAlpha);

  const pickerWrap = document.createElement("div");
  pickerWrap.style.display = "flex";
  pickerWrap.style.flexDirection = "column";
  pickerWrap.style.gap = "6px";
  pickerWrap.style.alignItems = "center";

  const svCanvas = document.createElement("canvas");
  svCanvas.width = 200;
  svCanvas.height = 120;
  svCanvas.style.width = "200px";
  svCanvas.style.height = "120px";
  svCanvas.style.border = "1px solid rgba(255,255,255,0.18)";
  svCanvas.style.borderRadius = "6px";
  svCanvas.style.cursor = "crosshair";

  const hueRow = document.createElement("div");
  hueRow.style.display = "flex";
  hueRow.style.gap = "8px";
  hueRow.style.alignItems = "center";
  hueRow.style.width = "100%";
  hueRow.style.justifyContent = "center";

  const hueCanvas = document.createElement("canvas");
  hueCanvas.width = 200;
  hueCanvas.height = 14;
  hueCanvas.style.width = "200px";
  hueCanvas.style.height = "14px";
  hueCanvas.style.border = "1px solid rgba(255,255,255,0.18)";
  hueCanvas.style.borderRadius = "8px";
  hueCanvas.style.cursor = "pointer";

  hueRow.append(hueCanvas);
  pickerWrap.append(svCanvas, hueRow);

  const rgbaRow = document.createElement("div");
  rgbaRow.style.display = "grid";
  rgbaRow.style.gridTemplateColumns = "60px repeat(4, 1fr)";
  rgbaRow.style.gap = "6px";
  const rgbaLabel = document.createElement("div");
  rgbaLabel.textContent = "RGBA";
  const rgbaInputs = ["r", "g", "b", "a"].map((key) => {
    const input = document.createElement("input");
    input.type = "number";
    input.min = "0";
    input.max = key === "a" ? "1" : "255";
    input.step = key === "a" ? "0.01" : "1";
    input.style.width = key === "a" ? "calc(7ch + 2px)" : "calc(6ch + 4px)";
    input.value = key === "a" ? `${components.a}` : `${components[key]}`;
    input.dataset.key = key;
    if (!allowAlpha && key === "a") {
      input.disabled = true;
      input.value = "1";
    }
    return input;
  });
  rgbaRow.append(rgbaLabel, ...rgbaInputs);

  const hslaRow = document.createElement("div");
  hslaRow.style.display = "grid";
  hslaRow.style.gridTemplateColumns = "60px repeat(4, 1fr)";
  hslaRow.style.gap = "6px";
  const hslaLabel = document.createElement("div");
  hslaLabel.textContent = "HSLA";
  const hslaInputs = [
    { key: "h", min: 0, max: 360, step: 1, value: Math.round(hsl.h) },
    { key: "s", min: 0, max: 100, step: 1, value: Math.round(hsl.s) },
    { key: "l", min: 0, max: 100, step: 1, value: Math.round(hsl.l) },
    { key: "a", min: 0, max: 1, step: 0.01, value: components.a },
  ].map((meta) => {
    const input = document.createElement("input");
    input.type = "number";
    input.min = `${meta.min}`;
    input.max = `${meta.max}`;
    input.step = `${meta.step}`;
    input.style.width = meta.key === "a" ? "calc(7ch + 2px)" : "calc(6ch + 4px)";
    input.value = `${meta.value}`;
    input.dataset.key = meta.key;
    if (!allowAlpha && meta.key === "a") {
      input.disabled = true;
      input.value = "1";
    }
    return input;
  });
  hslaRow.append(hslaLabel, ...hslaInputs);

  const hexRow = document.createElement("div");
  hexRow.style.display = "grid";
  hexRow.style.gridTemplateColumns = "60px 1fr";
  hexRow.style.gap = "6px";
  const hexLabel = document.createElement("div");
  hexLabel.textContent = "HEX";
  const hexInput = document.createElement("input");
  hexInput.type = "text";
  hexInput.style.width = "10ch";
  hexInput.value = rgbToHex8(components.r, components.g, components.b, allowAlpha ? components.a : 1);
  hexRow.append(hexLabel, hexInput);

  const alphaRow = document.createElement("div");
  alphaRow.style.display = "grid";
  alphaRow.style.gridTemplateColumns = "60px 1fr";
  alphaRow.style.gap = "6px";
  const alphaLabel = document.createElement("div");
  alphaLabel.textContent = "Alpha";
  const alphaInput = document.createElement("input");
  alphaInput.type = "range";
  alphaInput.min = "0";
  alphaInput.max = "1";
  alphaInput.step = "0.01";
  alphaInput.value = `${components.a}`;
  alphaInput.disabled = !allowAlpha;
  alphaRow.append(alphaLabel, alphaInput);

  const actions = document.createElement("div");
  actions.style.display = "flex";
  actions.style.gap = "8px";
  const reset = document.createElement("button");
  reset.textContent = "Reset";
  const apply = document.createElement("button");
  apply.textContent = "Apply";
  const cancel = document.createElement("button");
  cancel.textContent = "Cancel";
  actions.append(reset, apply, cancel);

  dialog.append(preview, pickerWrap, rgbaRow, hslaRow, hexRow, alphaRow, actions);
  overlay.appendChild(dialog);
  document.body.appendChild(overlay);
  applyModalThemeStyles(node, dialog);

  const readRgbaInputs = () => {
    const values = {};
    rgbaInputs.forEach((input) => {
      values[input.dataset.key] = Number.parseFloat(input.value);
    });
    if ([values.r, values.g, values.b].some((v) => !Number.isFinite(v))) return null;
    const a = allowAlpha ? clamp01(values.a ?? components.a) : 1;
    return { r: clamp255(values.r), g: clamp255(values.g), b: clamp255(values.b), a };
  };

  const readHslaInputs = () => {
    const values = {};
    hslaInputs.forEach((input) => {
      values[input.dataset.key] = Number.parseFloat(input.value);
    });
    if ([values.h, values.s, values.l].some((v) => !Number.isFinite(v))) return null;
    const a = allowAlpha ? clamp01(values.a ?? components.a) : 1;
    const rgb = hslToRgb(values.h, values.s, values.l);
    return { r: rgb.r, g: rgb.g, b: rgb.b, a };
  };

  const readHexInput = () => {
    const parsed = parseHexToRgba(hexInput.value);
    if (!parsed) return null;
    if (!allowAlpha) parsed.a = 1;
    return parsed;
  };

  const drawSvPicker = () => {
    const ctx = svCanvas.getContext("2d");
    if (!ctx) return;
    const { width, height } = svCanvas;
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = `hsl(${hsv.h}, 100%, 50%)`;
    ctx.fillRect(0, 0, width, height);
    const whiteGrad = ctx.createLinearGradient(0, 0, width, 0);
    whiteGrad.addColorStop(0, "rgba(255,255,255,1)");
    whiteGrad.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = whiteGrad;
    ctx.fillRect(0, 0, width, height);
    const blackGrad = ctx.createLinearGradient(0, 0, 0, height);
    blackGrad.addColorStop(0, "rgba(0,0,0,0)");
    blackGrad.addColorStop(1, "rgba(0,0,0,1)");
    ctx.fillStyle = blackGrad;
    ctx.fillRect(0, 0, width, height);
    const x = hsv.s * width;
    const y = (1 - hsv.v) * height;
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.stroke();
  };

  const drawHuePicker = () => {
    const ctx = hueCanvas.getContext("2d");
    if (!ctx) return;
    const { width, height } = hueCanvas;
    const grad = ctx.createLinearGradient(0, 0, width, 0);
    for (let i = 0; i <= 360; i += 60) {
      grad.addColorStop(i / 360, `hsl(${i}, 100%, 50%)`);
    }
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, width, height);
    const x = (hsv.h / 360) * width;
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, height / 2, 6, 0, Math.PI * 2);
    ctx.stroke();
  };

  const updateFromRgba = (rgba) => {
    const next = {
      r: clamp255(rgba.r),
      g: clamp255(rgba.g),
      b: clamp255(rgba.b),
      a: allowAlpha ? clamp01(rgba.a) : 1,
    };
    rgbaInputs.find((input) => input.dataset.key === "r").value = `${next.r}`;
    rgbaInputs.find((input) => input.dataset.key === "g").value = `${next.g}`;
    rgbaInputs.find((input) => input.dataset.key === "b").value = `${next.b}`;
    if (allowAlpha) {
      rgbaInputs.find((input) => input.dataset.key === "a").value = `${next.a}`;
    }
    const nextHsl = rgbToHsl(next.r, next.g, next.b);
    hslaInputs.find((input) => input.dataset.key === "h").value = `${Math.round(nextHsl.h)}`;
    hslaInputs.find((input) => input.dataset.key === "s").value = `${Math.round(nextHsl.s)}`;
    hslaInputs.find((input) => input.dataset.key === "l").value = `${Math.round(nextHsl.l)}`;
    if (allowAlpha) {
      hslaInputs.find((input) => input.dataset.key === "a").value = `${next.a}`;
    }
    hexInput.value = rgbToHex8(next.r, next.g, next.b, allowAlpha ? next.a : 1);
    preview.style.backgroundColor = rgbaString(next, allowAlpha);
    preview.style.backgroundImage =
      allowAlpha && next.a < 1 ? checkerboardBg : "none";
    preview.style.backgroundImage =
      allowAlpha && next.a < 1 ? checkerboardBg : "none";
    if (allowAlpha) {
      alphaInput.value = `${next.a}`;
    }
    hsv = rgbToHsv(next.r, next.g, next.b);
    drawSvPicker();
    drawHuePicker();
  };

  const updatePreview = () => {
    const rgba = readRgbaInputs() || readHslaInputs() || readHexInput();
    if (!rgba) return;
    updateFromRgba(rgba);
  };

  [...rgbaInputs, ...hslaInputs, hexInput].forEach((input) => {
    input.addEventListener("input", updatePreview);
  });
  alphaInput.addEventListener("input", () => {
    if (!allowAlpha) return;
    const val = clamp01(Number.parseFloat(alphaInput.value));
    rgbaInputs.find((input) => input.dataset.key === "a").value = `${val}`;
    hslaInputs.find((input) => input.dataset.key === "a").value = `${val}`;
    updatePreview();
  });
  const handleSvPointer = (event) => {
    const rect = svCanvas.getBoundingClientRect();
    const x = Math.max(0, Math.min(rect.width, event.clientX - rect.left));
    const y = Math.max(0, Math.min(rect.height, event.clientY - rect.top));
    hsv.s = rect.width ? x / rect.width : 0;
    hsv.v = rect.height ? 1 - y / rect.height : 0;
    const rgb = hsvToRgb(hsv.h, hsv.s, hsv.v);
    const alpha = allowAlpha ? clamp01(Number.parseFloat(alphaInput.value)) : 1;
    updateFromRgba({ r: rgb.r, g: rgb.g, b: rgb.b, a: alpha });
  };
  const handleHuePointer = (event) => {
    const rect = hueCanvas.getBoundingClientRect();
    const x = Math.max(0, Math.min(rect.width, event.clientX - rect.left));
    hsv.h = rect.width ? (x / rect.width) * 360 : 0;
    const rgb = hsvToRgb(hsv.h, hsv.s, hsv.v);
    const alpha = allowAlpha ? clamp01(Number.parseFloat(alphaInput.value)) : 1;
    updateFromRgba({ r: rgb.r, g: rgb.g, b: rgb.b, a: alpha });
  };
  const bindDrag = (element, handler) => {
    let active = false;
    const onMove = (event) => {
      if (!active) return;
      handler(event);
    };
    const onUp = () => {
      active = false;
      window.removeEventListener("mousemove", onMove);
      window.removeEventListener("mouseup", onUp);
    };
    element.addEventListener("mousedown", (event) => {
      active = true;
      handler(event);
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp);
    });
  };
  bindDrag(svCanvas, handleSvPointer);
  bindDrag(hueCanvas, handleHuePointer);
  updatePreview();
  reset.addEventListener("click", () => {
    const parsed = parseColorComponents(defaultColor);
    updateFromRgba(parsed);
  });
  cancel.addEventListener("click", () => overlay.remove());
  apply.addEventListener("click", () => {
    const rgba = readRgbaInputs() || readHslaInputs() || readHexInput();
    if (!rgba) {
      overlay.remove();
      return;
    }
    const next = rgbToHex8(rgba.r, rgba.g, rgba.b, allowAlpha ? rgba.a : 1);
    onApply(next);
    overlay.remove();
  });
}

function parseColorComponents(value) {
  const rgba = parseRgbaString(value || "");
  if (rgba) {
    const parts = rgba
      .replace(/rgba?\(|\)/g, "")
      .split(",")
      .map((v) => Number.parseFloat(v.trim()));
    return { r: parts[0] || 0, g: parts[1] || 0, b: parts[2] || 0, a: parts[3] ?? 1 };
  }
  const hexParsed = parseHexToRgba(value);
  if (hexParsed) return hexParsed;
  return { r: 255, g: 255, b: 255, a: 1 };
}

function parseHexToRgba(value) {
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  const hex = trimmed.startsWith("#") ? trimmed.slice(1) : trimmed;
  if (!/^[0-9a-fA-F]{6}([0-9a-fA-F]{2})?$/.test(hex)) return null;
  const r = Number.parseInt(hex.slice(0, 2), 16);
  const g = Number.parseInt(hex.slice(2, 4), 16);
  const b = Number.parseInt(hex.slice(4, 6), 16);
  const a = hex.length === 8 ? Number.parseInt(hex.slice(6, 8), 16) / 255 : 1;
  return { r, g, b, a: Number.isFinite(a) ? a : 1 };
}

function rgbToHex8(r, g, b, a = 1) {
  const alpha = Math.round(clamp01(a) * 255);
  const toHex = (value) => value.toString(16).padStart(2, "0");
  return `#${toHex(clamp255(r))}${toHex(clamp255(g))}${toHex(clamp255(b))}${toHex(alpha)}`;
}

function clamp255(value) {
  const v = Number.isFinite(value) ? Math.round(value) : 0;
  return Math.min(255, Math.max(0, v));
}

function clamp01(value) {
  const v = Number.isFinite(value) ? value : 1;
  return Math.min(1, Math.max(0, v));
}

function rgbaString({ r, g, b, a }, allowAlpha) {
  const alpha = allowAlpha ? clamp01(a) : 1;
  return `rgba(${clamp255(r)},${clamp255(g)},${clamp255(b)},${alpha})`;
}

function rgbToHsl(r, g, b) {
  const rn = r / 255;
  const gn = g / 255;
  const bn = b / 255;
  const max = Math.max(rn, gn, bn);
  const min = Math.min(rn, gn, bn);
  let h = 0;
  let s = 0;
  const l = (max + min) / 2;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case rn:
        h = (gn - bn) / d + (gn < bn ? 6 : 0);
        break;
      case gn:
        h = (bn - rn) / d + 2;
        break;
      default:
        h = (rn - gn) / d + 4;
        break;
    }
    h *= 60;
  }
  return { h, s: s * 100, l: l * 100 };
}

function hslToRgb(h, s, l) {
  const hn = (Number.isFinite(h) ? h : 0) / 360;
  const sn = (Number.isFinite(s) ? s : 0) / 100;
  const ln = (Number.isFinite(l) ? l : 0) / 100;
  if (sn === 0) {
    const gray = Math.round(ln * 255);
    return { r: gray, g: gray, b: gray };
  }
  const q = ln < 0.5 ? ln * (1 + sn) : ln + sn - ln * sn;
  const p = 2 * ln - q;
  const hue2rgb = (pVal, qVal, t) => {
    let tt = t;
    if (tt < 0) tt += 1;
    if (tt > 1) tt -= 1;
    if (tt < 1 / 6) return pVal + (qVal - pVal) * 6 * tt;
    if (tt < 1 / 2) return qVal;
    if (tt < 2 / 3) return pVal + (qVal - pVal) * (2 / 3 - tt) * 6;
    return pVal;
  };
  const r = hue2rgb(p, q, hn + 1 / 3);
  const g = hue2rgb(p, q, hn);
  const b = hue2rgb(p, q, hn - 1 / 3);
  return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
}

function rgbToHsv(r, g, b) {
  const rn = r / 255;
  const gn = g / 255;
  const bn = b / 255;
  const max = Math.max(rn, gn, bn);
  const min = Math.min(rn, gn, bn);
  const d = max - min;
  let h = 0;
  if (d !== 0) {
    switch (max) {
      case rn:
        h = (gn - bn) / d + (gn < bn ? 6 : 0);
        break;
      case gn:
        h = (bn - rn) / d + 2;
        break;
      default:
        h = (rn - gn) / d + 4;
        break;
    }
    h *= 60;
  }
  const s = max === 0 ? 0 : d / max;
  const v = max;
  return { h, s, v };
}

function hsvToRgb(h, s, v) {
  const hh = ((Number.isFinite(h) ? h : 0) % 360 + 360) % 360;
  const ss = Number.isFinite(s) ? s : 0;
  const vv = Number.isFinite(v) ? v : 0;
  const c = vv * ss;
  const x = c * (1 - Math.abs(((hh / 60) % 2) - 1));
  const m = vv - c;
  let r1 = 0;
  let g1 = 0;
  let b1 = 0;
  if (hh < 60) {
    r1 = c;
    g1 = x;
  } else if (hh < 120) {
    r1 = x;
    g1 = c;
  } else if (hh < 180) {
    g1 = c;
    b1 = x;
  } else if (hh < 240) {
    g1 = x;
    b1 = c;
  } else if (hh < 300) {
    r1 = x;
    b1 = c;
  } else {
    r1 = c;
    b1 = x;
  }
  return {
    r: Math.round((r1 + m) * 255),
    g: Math.round((g1 + m) * 255),
    b: Math.round((b1 + m) * 255),
  };
}

function ensureBackgroundUpdater(node) {
  const live = node.__tetrisLive;
  if (!live || live.bgTimer) return;
  live.bgTimer = setInterval(() => {
    const bg = getBackgroundSource(node);
    if (bg && live.bgSource !== bg) {
      live.bgSource = bg;
      node.setDirtyCanvas(true, true);
    }
  }, 250);
}

function loadStateFromText(node, text) {
  const live = node.__tetrisLive;
  if (!live) return;
  if (!text || !text.trim()) {
    setStatusMessage(node, "No state input found.", "error");
    return;
  }
  let parsed = null;
  try {
    parsed = JSON.parse(text);
  } catch {
    setStatusMessage(node, "Invalid state JSON.", "error");
    return;
  }
  const validationError = validateStatePayload(parsed);
  if (validationError) {
    setStatusMessage(node, validationError, "error");
    return;
  }
  const seed = getSeedValue(node, { allowRandomize: false });
  const startLevel = getStartLevel(node);
  const progression = getLevelProgression(node);
  const hydrated = hydrateState(text, seed ?? 0, startLevel, progression);
  if (!hydrated) {
    setStatusMessage(node, "Failed to load state.", "error");
    return;
  }
  node.__tetrisLive.state = hydrated;
  node.__tetrisLive.state.started = true;
  node.__tetrisLive.state.running = false;
  node.__tetrisLive.state.showBoardWhilePaused = true;
  resetInputState(node.__tetrisLive.state);
  stopTimer(node);
  ensureTimer(node);
  updateBackendState(node);
  node.setDirtyCanvas(true, true);
  setStatusMessage(node, "State loaded.", "success");
}

function validateStatePayload(payload) {
  if (!payload || typeof payload !== "object") return "Invalid state payload.";
  if (!Array.isArray(payload.board)) return "State missing board.";
  if (payload.board.length !== GRID_H_TOTAL) return "Board must be 40 rows.";
  for (const row of payload.board) {
    if (!Array.isArray(row) || row.length !== GRID_W) return "Board rows must be 10 columns.";
  }
  const piece = payload.piece;
  if (!piece || typeof piece !== "object") return "State missing piece.";
  if (typeof piece.shape !== "string") return "Piece shape missing.";
  if (!Number.isInteger(piece.rot)) return "Piece rotation invalid.";
  if (!Number.isInteger(piece.x) || !Number.isInteger(piece.y)) return "Piece position invalid.";
  return null;
}

function setStatusMessage(node, text, kind = "info") {
  node.__tetrisStatusMessage = {
    text,
    kind,
    until: performance.now() + 2500,
  };
  node.setDirtyCanvas(true, true);
}

function resetInputState(state) {
  state.moveDir = null;
  state.moveHeldLeft = false;
  state.moveHeldRight = false;
  state.moveDasElapsed = 0;
  state.moveArrElapsed = 0;
  state.softDrop = false;
  state.dropMs = state.baseDropMs;
}

function syncSeed(state, node) {
  const nextSeed = getSeedValue(node, { allowRandomize: false });
  if (Number.isInteger(nextSeed)) {
    if (nextSeed !== state.seed) {
      if (state.started) {
        return;
      }
      stopTimer(node);
      const nextState = createState(nextSeed, state.startLevel);
      nextState.running = false;
      nextState.started = false;
      node.__tetrisLive.state = nextState;
      updateBackendState(node);
      ensureTimer(node);
      node.setDirtyCanvas(true, true);
      return;
    }
    state.seed = nextSeed;
  }
}

function getStartLevel(node) {
  const defaultValue = 1;
  const parsed = Number.parseInt(`${getConfig(node).start_level}`, 10);
  if (!Number.isFinite(parsed)) return defaultValue;
  return clampLevel(parsed);
}

function getLevelProgression(node) {
  const raw = `${getConfig(node).level_progression || ""}`.trim().toLowerCase();
  if (raw === "variable") return "variable";
  return "fixed";
}

function syncStartLevel(state, node) {
  const startLevel = getStartLevel(node);
  const progression = getLevelProgression(node);
  if (startLevel !== state.startLevel || progression !== state.levelProgression) {
    if (state.started) {
      return;
    }
    stopTimer(node);
    const nextState = createState(state.seed, startLevel, progression);
    nextState.running = false;
    nextState.started = false;
    node.__tetrisLive.state = nextState;
    updateBackendState(node);
    ensureTimer(node);
    node.setDirtyCanvas(true, true);
  } else {
    state.levelProgression = progression;
    updateLevel(state);
  }
}

function resetNode(node) {
  const live = node.__tetrisLive;
  if (!live) return;
  const seed = getSeedValue(node, { allowRandomize: true });
  const startLevel = getStartLevel(node);
  const progression = getLevelProgression(node);
  live.state = createState(seed ?? live.state.seed, startLevel, progression);
  node.size = [750, 950];
  node.__tetrisSizeInitialized = true;
  live.state.started = true;
  live.state.running = true;
  live.state.showBoardWhilePaused = false;
  updateBackendState(node);
  node.setDirtyCanvas(true, true);
}

function togglePause(node) {
  const live = node.__tetrisLive;
  if (!live) return;
  if (!live.state.started && !live.state.gameOver) {
    live.state.started = true;
    live.state.running = true;
  } else {
    live.state.running = !live.state.running;
  }
  live.state.showBoardWhilePaused = false;
  updateBackendState(node);
  node.setDirtyCanvas(true, true);
}

function ensureTimer(node) {
  const live = node.__tetrisLive;
  if (!live || live.state.timer) return;
  live.state.timer = setInterval(() => {
    if (live.state.running && live.state.started && !live.state.gameOver && !isNodeSelected(node)) {
      live.state.running = false;
      updateBackendState(node);
      node.setDirtyCanvas(true, true);
      return;
    }
    if (!live.state.running || live.state.gameOver) return;
    const lockMode = getLockMode(node);
    updateAutoRepeat(live.state, node, 50);
    live.state.elapsed += 50;
    live.state.timeMs += 50;
    if (live.state.locking) {
      if (lockMode === "extended" && live.state.lockMoves >= 15) {
        settlePiece(live.state);
        updateBackendState(node);
        node.setDirtyCanvas(true, true);
        return;
      }
      live.state.lockElapsed += 50;
      if (live.state.lockElapsed >= live.state.lockDelayMs) {
        settlePiece(live.state);
        updateBackendState(node);
        node.setDirtyCanvas(true, true);
        return;
      }
    }
    if (live.state.elapsed >= live.state.dropMs) {
      live.state.elapsed = 0;
      stepDown(live.state);
      if (lockMode === "extended" && live.state.lockMoves >= 15 && live.state.locking) {
        settlePiece(live.state);
        updateBackendState(node);
        node.setDirtyCanvas(true, true);
        return;
      }
      updateBackendState(node);
      node.setDirtyCanvas(true, true);
    }
  }, 50);
}

function stopTimer(node) {
  const live = node.__tetrisLive;
  if (live?.state?.timer) {
    clearInterval(live.state.timer);
    live.state.timer = null;
  }
  if (live?.bgTimer) {
    clearInterval(live.bgTimer);
    live.bgTimer = null;
  }
}

function getSelectedLiveNode(allowFallback = false) {
  const selected = app.canvas?.selected_nodes;
  let fallback = null;
  if (allowFallback) {
    const nodes = app.graph?._nodes || [];
    for (const node of nodes) {
      if (node?.comfyClass === NODE_CLASS && node.__tetrisLive) {
        fallback = node;
        break;
      }
    }
  }
  if (!selected) return fallback;
  for (const key of Object.keys(selected)) {
    const node = selected[key];
    if (node?.comfyClass === NODE_CLASS && node.__tetrisLive) return node;
  }
  return fallback;
}

function isNodeSelected(node) {
  const selected = app.canvas?.selected_nodes;
  if (!selected) return false;
  for (const key of Object.keys(selected)) {
    if (selected[key] === node) return true;
  }
  return false;
}

function handleKey(event) {
  if (event.target && ["INPUT", "TEXTAREA"].includes(event.target.tagName)) return;
  const node = getSelectedLiveNode(false);
  if (!node) return;
  const live = node.__tetrisLive;
  if (!live) return;
  const ui = node.__tetrisUi;
  if (ui?.captureAction) {
    if (event.key && event.key.toLowerCase() === "escape") {
      ui.captureAction = null;
      if (ui.modal?.body) {
        renderControlsModal(node, ui.modal.body);
      }
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    const binding = bindingFromEvent(event);
    if (!binding) {
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    updateConfig(node, (next) => {
      const list = Array.isArray(next.bindings[ui.captureAction])
        ? next.bindings[ui.captureAction]
        : [];
      if (!list.includes(binding)) {
        list.push(binding);
      }
      next.bindings[ui.captureAction] = list.slice(0, 5);
      return next;
    });
    updateBackendState(node);
    ui.captureAction = null;
    if (ui.modal?.body) {
      renderControlsModal(node, ui.modal.body);
    }
    event.preventDefault();
    event.stopPropagation();
    return;
  }
  if (ui?.modal) {
    if (event.key && event.key.toLowerCase() === "escape") {
      closeModal(node);
      event.preventDefault();
      event.stopPropagation();
    }
    return;
  }

  const state = live.state;
  const bindings = getControlBindings(node);
  const matches = (binding) => keyMatches(event, binding);
  const resetPressed = matches(bindings.reset);
  const pausePressed = matches(bindings.pause);
  if (state.gameOver) {
    if (resetPressed || pausePressed) {
      resetNode(node);
      event.preventDefault();
      event.stopPropagation();
    }
    return;
  }
  if (
    event.repeat
    && (matches(bindings.rotateCw)
      || matches(bindings.rotateCcw)
      || matches(bindings.moveLeft)
      || matches(bindings.moveRight)
      || matches(bindings.softDrop)
      || matches(bindings.hardDrop)
      || matches(bindings.hold)
      || matches(bindings.reset)
      || matches(bindings.pause))
  ) {
    event.preventDefault();
    event.stopPropagation();
    return;
  }
  const canAct =
    state.running ||
    matches(bindings.pause) ||
    matches(bindings.reset);
  if (!canAct) return;
  let handled = true;
  if (matches(bindings.moveLeft)) {
    state.moveHeldLeft = true;
    setMoveDirection(state, "left");
    if (move(state, -1, 0)) applyLockModeAfterAction(state, getLockMode(node));
  } else if (matches(bindings.moveRight)) {
    state.moveHeldRight = true;
    setMoveDirection(state, "right");
    if (move(state, 1, 0)) applyLockModeAfterAction(state, getLockMode(node));
  } else if (matches(bindings.rotateCw)) {
    if (rotate(state, 1)) {
      applyLockModeAfterAction(state, getLockMode(node));
    }
  } else if (matches(bindings.rotateCcw)) {
    if (rotate(state, -1)) {
      applyLockModeAfterAction(state, getLockMode(node));
    }
  } else if (matches(bindings.softDrop)) {
    state.softDrop = true;
    state.dropMs = Math.max(1, Math.floor(state.baseDropMs / 20));
  } else if (matches(bindings.hardDrop)) {
    hardDrop(state);
  } else if (matches(bindings.hold)) {
    holdPiece(state);
  } else if (matches(bindings.reset)) {
    resetNode(node);
  } else if (matches(bindings.pause)) {
    togglePause(node);
  } else {
    handled = false;
  }

  if (handled) {
    event.preventDefault();
    event.stopPropagation();
    updateBackendState(node);
    node.setDirtyCanvas(true, true);
  }
}

function handleKeyUp(event) {
  if (event.target && ["INPUT", "TEXTAREA"].includes(event.target.tagName)) return;
  const node = getSelectedLiveNode(false);
  if (!node) return;
  const live = node.__tetrisLive;
  if (!live || live.state.gameOver) return;
  if (node.__tetrisUi?.modal) return;
  const bindings = getControlBindings(node);
  const matches = (binding) => keyMatches(event, binding);
  if (matches(bindings.moveLeft)) {
    live.state.moveHeldLeft = false;
    if (live.state.moveHeldRight) {
      setMoveDirection(live.state, "right");
    } else {
      clearMoveDirection(live.state);
    }
  }
  if (matches(bindings.moveRight)) {
    live.state.moveHeldRight = false;
    if (live.state.moveHeldLeft) {
      setMoveDirection(live.state, "left");
    } else {
      clearMoveDirection(live.state);
    }
  }
  if (!matches(bindings.softDrop)) return;
  live.state.softDrop = false;
  live.state.dropMs = live.state.baseDropMs;
}

function applyWidgetHiding(node) {
  const hideWidgets = new Set([
    "action",
    "state",
    "block_size",
  ]);
  if (!node.widgets) return;
  let touched = false;
  for (const widget of node.widgets) {
    if (hideWidgets.has(widget?.name)) {
      widget.hidden = true;
      widget.computeSize = () => [0, 0];
      widget.draw = () => {};
      touched = true;
    }
  }
  if (touched) {
    node.__tetrisWidgetsHidden = true;
    node.setDirtyCanvas(true, true);
  }
}

function isValidLinkId(link) {
  return Number.isInteger(link) && link >= 0;
}

function getInputLink(node, name) {
  const input = node?.inputs?.find((inp) => inp?.name === name);
  if (!input || !isValidLinkId(input.link)) return null;
  let linkId = input.link;
  let link = null;
  let origin = null;
  for (let hop = 0; hop < 8; hop += 1) {
    link = node.graph?.links?.[linkId];
    if (!link) return null;
    origin = node.graph?._nodes_by_id?.[link.origin_id];
    if (!origin) return null;
    const isReroute = origin?.type === "Reroute" || origin?.comfyClass === "Reroute";
    if (!isReroute) {
      return { link, origin };
    }
    const rerouteInput = origin.inputs?.[0];
    if (!rerouteInput || !isValidLinkId(rerouteInput.link)) {
      return { link, origin };
    }
    linkId = rerouteInput.link;
  }
  return null;
}

function getInputValue(node, name) {
  const idx = node?.inputs?.findIndex((inp) => inp?.name === name);
  if (idx == null || idx < 0) return null;
  const input = node.inputs[idx];
  if (!isValidLinkId(input?.link)) return null;
  if (typeof node.getInputData !== "function") return null;
  const value = node.getInputData(idx);
  let candidate = value;
  if (value && typeof value === "object") {
    if ("value" in value) {
      candidate = value.value;
    } else if ("seed" in value) {
      candidate = value.seed;
    }
  }
  const coerced = coerceInt(candidate);
  return coerced != null ? coerced : null;
}

function coerceInt(value) {
  if (Number.isInteger(value)) return value;
  if (typeof value === "string" && value.trim() !== "") {
    const parsed = Number.parseInt(value, 10);
    if (Number.isInteger(parsed)) return parsed;
  }
  if (typeof value === "number" && Number.isFinite(value)) {
    return Math.trunc(value);
  }
  return null;
}

function getLinkedInputValue(node, name) {
  const resolved = getInputLink(node, name);
  if (!resolved) return null;
  const { link, origin } = resolved;
  const output = origin.outputs?.[link.origin_slot];
  if (output && output.value !== undefined) {
    const coerced = coerceInt(output.value);
    if (coerced != null) return coerced;
  }
  const outputName = output?.name;
  if (outputName && origin.widgets) {
    const widgetIndex = origin.widgets.findIndex((w) => w.name === outputName);
    if (widgetIndex >= 0) {
      const widgetValue = origin.widgets[widgetIndex]?.value;
      const coerced = coerceInt(widgetValue);
      if (coerced != null) return coerced;
      if (origin.widgets_values && origin.widgets_values.length > widgetIndex) {
        const coercedStored = coerceInt(origin.widgets_values[widgetIndex]);
        if (coercedStored != null) return coercedStored;
      }
    }
  }
  if (origin.widgets_values && origin.widgets_values.length) {
    const coerced = coerceInt(origin.widgets_values[0]);
    if (coerced != null) return coerced;
  }
  if (origin.widgets && origin.widgets.length) {
    const coerced = coerceInt(origin.widgets[0]?.value);
    if (coerced != null) return coerced;
  }
  return null;
}

function isSeedLinked(node) {
  return !!getInputLink(node, "seed");
}

function resolveSeed(value, allowRandomize) {
  const coerced = coerceInt(value);
  if (coerced == null) return null;
  if (coerced < 0) {
    if (!allowRandomize) return null;
    const max = 0xffffffff;
    return Math.floor(Math.random() * (max + 1));
  }
  return coerced;
}

function getSeedValue(node, options = {}) {
  const allowRandomize = options.allowRandomize === true;
  const liveInput = getInputValue(node, "seed");
  const liveResolved = resolveSeed(liveInput, allowRandomize);
  if (liveResolved != null) return liveResolved;
  const linked = getLinkedInputValue(node, "seed");
  const linkedResolved = resolveSeed(linked, allowRandomize);
  if (linkedResolved != null) return linkedResolved;
  const seedWidget = node.widgets?.find((w) => w.name === "seed");
  const fallback = resolveSeed(seedWidget?.value, allowRandomize);
  return fallback != null ? fallback : 0;
}

function normalizeBindingValue(value) {
  if (!value) return null;
  const rawValue = `${value}`;
  if (rawValue === " ") return " ";
  const raw = rawValue.trim().toLowerCase();
  if (!raw) return null;
  if (raw === "space" || raw === "spacebar") return " ";
  if (raw === "backslash") return "\\";
  if (raw === "slash" || raw === "forwardslash") return "/";
  if (raw === "control" || raw === "ctrl") return "control";
  if (raw === "shift") return "shift";
  if (raw === "none" || raw === "null") return null;
  return raw;
}

function getControlBindings(node) {
  const config = getConfig(node);
  const normalizeList = (values) =>
    (Array.isArray(values) ? values : [values])
      .map((value) => normalizeBindingValue(value))
      .filter((value) => value);
  return {
    moveLeft: normalizeList(config.bindings.move_left),
    moveRight: normalizeList(config.bindings.move_right),
    rotateCw: normalizeList(config.bindings.rotate_cw),
    rotateCcw: normalizeList(config.bindings.rotate_ccw),
    softDrop: normalizeList(config.bindings.soft_drop),
    hardDrop: normalizeList(config.bindings.hard_drop),
    hold: normalizeList(config.bindings.hold),
    reset: normalizeList(config.bindings.reset),
    pause: normalizeList(config.bindings.pause),
  };
}

function getQueueSize(node) {
  const parsed = Number.parseInt(`${getConfig(node).queue_size}`, 10);
  if (!Number.isFinite(parsed)) return 6;
  return Math.max(0, Math.min(6, parsed));
}

function getHoldEnabled(node) {
  return !!getConfig(node).hold_queue;
}

function getNextPieceEnabled(node) {
  return !!getConfig(node).next_piece;
}

function getShowControls(node) {
  return !!getConfig(node).show_controls;
}

function getGridEnabled(node) {
  return !!getConfig(node).grid_enabled;
}

function getGridColor(node) {
  const raw = getConfig(node).grid_color;
  const parsed = normalizeColor(raw, true);
  return parsed || "rgba(255,255,255,0.2)";
}

function formatKeyLabel(value) {
  if (!value) return "";
  if (value === "null" || value === "none") return "";
  if (value === " ") return "Space";
  if (value === "\\") return "\\";
  if (value === "/") return "/";
  if (value === "control") return "Ctrl";
  if (value === "shift") return "Shift";
  if (value === "escape") return "Esc";
  if (value === "enter") return "Enter";
  if (value === "tab") return "Tab";
  if (value === "backspace") return "Bksp";
  if (value === "delete") return "Del";
  if (value === "insert") return "Ins";
  if (value === "home") return "Home";
  if (value === "end") return "End";
  if (value === "pageup") return "PgUp";
  if (value === "pagedown") return "PgDn";
  if (value === "arrowleft") return "Left Arrow";
  if (value === "arrowright") return "Right Arrow";
  if (value === "arrowup") return "Up Arrow";
  if (value === "arrowdown") return "Down Arrow";
  if (value.startsWith("numpad")) {
    const suffix = value.replace("numpad", "");
    if (/^\d+$/.test(suffix)) return `${suffix} (Numpad)`;
    const label = suffix ? `${suffix[0].toUpperCase()}${suffix.slice(1)}` : "";
    return label ? `${label} (Numpad)` : "Numpad";
  }
  return value.toUpperCase();
}

function formatTimeMs(ms) {
  const total = Math.max(0, Math.floor(ms || 0));
  const minutes = Math.floor(total / 60000);
  const seconds = Math.floor((total % 60000) / 1000);
  const centis = Math.floor((total % 1000) / 10);
  const mm = `${minutes}`.padStart(2, "0");
  const ss = `${seconds}`.padStart(2, "0");
  const cc = `${centis}`.padStart(2, "0");
  return `${mm}:${ss}.${cc}`;
}

function normalizeEventKey(event) {
  const key = event.key ? event.key.toLowerCase() : "";
  const code = event.code ? event.code.toLowerCase() : "";
  return { key, code };
}

function bindingFromEvent(event) {
  if (event.altKey || event.metaKey) return null;
  if (["alt", "meta", "capslock", "numlock", "scrolllock"].includes(event.key?.toLowerCase())) {
    return null;
  }
  const { key, code } = normalizeEventKey(event);
  if (code && code.startsWith("numpad")) {
    return ALLOWED_KEYS.has(code) ? code : null;
  }
  if (key === " ") return " ";
  if (ALLOWED_KEYS.has(key)) return key;
  return null;
}

function keyMatches(event, binding) {
  if (!binding) return false;
  const bindings = Array.isArray(binding) ? binding : [binding];
  const { key, code } = normalizeEventKey(event);
  return bindings.some((value) => {
    if (!value) return false;
    if (value === " ") return key === " " || code === "space";
    if (value.startsWith("numpad")) {
      return code === value;
    }
    return key === value;
  });
}

function parseHexColor(value) {
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  const hex = trimmed.startsWith("#") ? trimmed.slice(1) : trimmed;
  if (!/^[0-9a-fA-F]{6}([0-9a-fA-F]{2})?$/.test(hex)) return null;
  const r = Number.parseInt(hex.slice(0, 2), 16);
  const g = Number.parseInt(hex.slice(2, 4), 16);
  const b = Number.parseInt(hex.slice(4, 6), 16);
  const a = hex.length === 8 ? Number.parseInt(hex.slice(6, 8), 16) / 255 : 1;
  return `rgba(${r},${g},${b},${Math.min(1, Math.max(0, a))})`;
}

function cloneDeep(value) {
  return JSON.parse(JSON.stringify(value));
}

function mergeConfig(defaults, stored) {
  if (!stored || typeof stored !== "object") return cloneDeep(defaults);
  const result = Array.isArray(defaults) ? [] : {};
  for (const [key, value] of Object.entries(defaults)) {
    if (value && typeof value === "object" && !Array.isArray(value)) {
      result[key] = mergeConfig(value, stored[key]);
    } else if (Array.isArray(value)) {
      const storedValue = stored[key];
      result[key] = Array.isArray(storedValue) ? storedValue.slice(0, 5) : value.slice();
    } else if (stored[key] !== undefined) {
      result[key] = stored[key];
    } else {
      result[key] = value;
    }
  }
  return result;
}

function getConfig(node) {
  if (!node) return cloneDeep(DEFAULT_CONFIG);
  if (!node.properties) node.properties = {};
  const stored = node.properties.tetrinode_config;
  const merged = mergeConfig(DEFAULT_CONFIG, stored);
  node.properties.tetrinode_config = merged;
  return merged;
}

function updateConfig(node, updater) {
  const current = getConfig(node);
  const next = updater(cloneDeep(current));
  node.properties.tetrinode_config = next;
  return next;
}

function getOptionsForState(node) {
  const config = getConfig(node);
  return {
    ghost_piece: !!config.ghost_piece,
    next_piece: !!config.next_piece,
    hold_queue: !!config.hold_queue,
    show_controls: !!config.show_controls,
    lock_down_mode: config.lock_down_mode,
    start_level: config.start_level,
    level_progression: config.level_progression,
    queue_size: config.queue_size,
    grid_enabled: !!config.grid_enabled,
    grid_color: config.grid_color,
    ...config.colors,
  };
}

function normalizeColor(value, allowAlpha = true) {
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  if (trimmed.startsWith("#")) {
    const parsed = parseHexColor(trimmed);
    return parsed;
  }
  const rgba = parseRgbaString(trimmed);
  if (rgba) {
    if (!allowAlpha) return rgba.replace(/,([0-9.]+)\)$/, ",1)");
    return rgba;
  }
  return null;
}

function parseRgbaString(value) {
  if (typeof value !== "string") return null;
  const rgbaMatch = value.match(
    /^rgba?\s*\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})(?:\s*,\s*([0-9]*\.?[0-9]+))?\s*\)$/i,
  );
  if (!rgbaMatch) return null;
  const r = Number.parseInt(rgbaMatch[1], 10);
  const g = Number.parseInt(rgbaMatch[2], 10);
  const b = Number.parseInt(rgbaMatch[3], 10);
  const a = rgbaMatch[4] != null ? Number.parseFloat(rgbaMatch[4]) : 1;
  if ([r, g, b].some((v) => !Number.isFinite(v) || v < 0 || v > 255)) return null;
  const clampedA = Math.min(1, Math.max(0, Number.isFinite(a) ? a : 1));
  return `rgba(${r},${g},${b},${clampedA})`;
}

function getColorPalette(node) {
  const palette = { ...COLORS };
  const config = getConfig(node);
  const mapping = {
    color_i: "I",
    color_j: "J",
    color_l: "L",
    color_o: "O",
    color_s: "S",
    color_t: "T",
    color_z: "Z",
    background_color: "X",
  };
  for (const [key, shape] of Object.entries(mapping)) {
    const raw = config.colors?.[key];
    const allowAlpha = key !== "background_color";
    const parsed = normalizeColor(raw, allowAlpha);
    if (parsed) palette[shape] = parsed;
  }
  return palette;
}

function isGhostEnabled(node) {
  return !!getConfig(node).ghost_piece;
}

function ensureSeedControlWidget(node) {
  if (!node?.widgets) return;
  const existing = node.widgets.find((w) => w.name === "control_after_generate");
  if (existing) return;
  const seedIndex = node.widgets.findIndex((w) => w.name === "seed");
  if (seedIndex < 0) return;
  const widget = node.addWidget(
    "combo",
    "control_after_generate",
    "randomize",
    () => {},
    { values: ["randomize", "increment", "decrement", "fixed"] }
  );
  const currentIndex = node.widgets.indexOf(widget);
  if (currentIndex >= 0) {
    node.widgets.splice(currentIndex, 1);
    node.widgets.splice(seedIndex + 1, 0, widget);
  }
}

function applySeedAfterGenerate(node) {
  if (isSeedLinked(node)) return;
  if (!node?.widgets) return;
  const seedWidget = node.widgets.find((w) => w.name === "seed");
  const controlWidget = node.widgets.find((w) => w.name === "control_after_generate");
  if (!seedWidget || !controlWidget) return;
  let mode = controlWidget.value;
  const controlIndex = node.widgets.indexOf(controlWidget);
  if (!mode && controlIndex >= 0 && node.widgets_values) {
    mode = node.widgets_values[controlIndex];
  }
  mode = `${mode || ""}`.toLowerCase();
  if (mode === "fixed") return;
  const min = coerceInt(seedWidget.options?.min) ?? 0;
  const maxOption = seedWidget.options?.max;
  if (maxOption != null && !Number.isSafeInteger(maxOption)) {
    return;
  }
  const max =
    Number.isFinite(maxOption) && Number.isSafeInteger(maxOption)
      ? maxOption
      : 0x7fffffff;
  const current = coerceInt(seedWidget.value) ?? min;
  let next = current;
  if (mode === "increment") {
    next = current >= max ? min : current + 1;
  } else if (mode === "decrement") {
    next = current <= min ? max : current - 1;
  } else if (mode === "randomize") {
    next = Math.floor(Math.random() * (max - min + 1)) + min;
  }
  seedWidget.value = next;
  const seedIndex = node.widgets.indexOf(seedWidget);
  if (!node.widgets_values) node.widgets_values = [];
  if (seedIndex >= 0) node.widgets_values[seedIndex] = next;
}

app.registerExtension({
  name: EXT_NAME,
  async nodeCreated(node) {
    if (node?.comfyClass !== NODE_CLASS) return;
    applyWidgetHiding(node);
    ensureSeedControlWidget(node);
    ensureUiState(node);
    getConfig(node);
    const seed = getSeedValue(node, { allowRandomize: true });
    const startLevel = getStartLevel(node);
    const progression = getLevelProgression(node);
    node.__tetrisLive = { state: createState(seed ?? 0, startLevel, progression) };

    if (!node.__tetrisSizeInitialized) {
      node.size = [750, 950];
      node.__tetrisSizeInitialized = true;
    }

    const originalDraw = node.onDrawForeground;
    node.onDrawForeground = function (ctx) {
      const result = originalDraw?.apply(this, arguments);
      drawNode(node, ctx);
      return result;
    };

    const originalMouseDown = node.onMouseDown;
    node.onMouseDown = function (event, pos, _graphcanvas) {
      if (handleToolbarClick(node, pos)) {
        node.setDirtyCanvas(true, true);
        return true;
      }
      return originalMouseDown?.apply(this, arguments);
    };

    const originalMouseMove = node.onMouseMove;
    node.onMouseMove = function (event, pos, _graphcanvas) {
      const ui = ensureUiState(node);
      const hovered = hitToolbarButton(node, pos, node.__tetrisLastLayout?.boardY);
      const next = hovered ? hovered.id : null;
      if (next !== (ui.hoverButton?.id || null)) {
        ui.hoverButton = hovered;
        node.setDirtyCanvas(true, true);
      }
      return originalMouseMove?.apply(this, arguments);
    };

    const originalRemoved = node.onRemoved;
    node.onRemoved = function () {
      closeModal(node);
      stopTimer(node);
      return originalRemoved?.apply(this, arguments);
    };
    const originalExecuted = node.onExecuted;
    node.onExecuted = function () {
      const result = originalExecuted?.apply(this, arguments);
      applySeedAfterGenerate(node);
      return result;
    };

    syncSeed(node.__tetrisLive.state, node);
    node.__tetrisLive.state.running = false;
    updateBackendState(node);
    ensureTimer(node);
    ensureBackgroundUpdater(node);
    if (!node.__tetrisLive.api) {
      node.__tetrisLive.api = {
        rotateCw: () => {
          rotate(node.__tetrisLive.state, 1);
          updateBackendState(node);
          node.setDirtyCanvas(true, true);
        },
        rotateCcw: () => {
          rotate(node.__tetrisLive.state, -1);
          updateBackendState(node);
          node.setDirtyCanvas(true, true);
        },
        hardDrop: () => {
          hardDrop(node.__tetrisLive.state);
          updateBackendState(node);
          node.setDirtyCanvas(true, true);
        },
      };
    }
  },
  async setup() {
    window.addEventListener("keydown", handleKey, true);
    window.addEventListener("keyup", handleKeyUp, true);
  },
});
